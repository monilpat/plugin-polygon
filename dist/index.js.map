{"version":3,"sources":["../src/index.ts","../src/actions/transfer.ts","../src/providers/PolygonWalletProvider.ts","../src/actions/delegateL1.ts","../src/services/PolygonRpcService.ts","../src/contracts/StakeManagerABI.json","../src/contracts/ValidatorShareABI.json","../src/contracts/RootChainManagerABI.json","../src/contracts/ERC20ABI.json","../src/contracts/CheckpointManagerABI.json","../src/services/GasService.ts","../src/templates/index.ts","../src/errors.ts","../src/actions/getCheckpointStatus.ts","../src/actions/proposeGovernance.ts","../src/actions/voteGovernance.ts","../src/actions/getValidatorInfo.ts","../src/actions/getDelegatorInfo.ts","../src/actions/withdrawRewardsL1.ts","../src/actions/bridgeDeposit.ts","../src/actions/getL2BlockNumber.ts","../src/actions/getMaticBalance.ts","../src/actions/getPolygonGasEstimates.ts","../src/actions/undelegateL1.ts","../src/utils.ts","../src/actions/restakeRewardsL1.ts","../src/actions/isL2BlockCheckpointed.ts","../src/actions/heimdallVoteAction.ts","../src/services/HeimdallService.ts","../src/actions/heimdallSubmitProposalAction.ts","../src/actions/heimdallTransferTokensAction.ts","../src/actions/getBalanceInfo.ts","../src/actions/getBlockInfo.ts","../src/utils/formatters.ts","../src/actions/getPolygonBlockDetails.ts"],"sourcesContent":["import {\n  type Plugin,\n  type IAgentRuntime,\n  type Action,\n  type Provider,\n  type ProviderResult,\n  logger,\n  type Service,\n  elizaLogger,\n} from '@elizaos/core';\nimport { z } from 'zod';\nimport { ethers } from 'ethers';\n\n// Add global handler for unhandled promise rejections to prevent Node crashes\nprocess.on('unhandledRejection', (reason, promise) => {\n  logger.error('Unhandled Promise Rejection:', reason);\n  // Don't crash, just log the error and continue\n});\n\nimport { transferPolygonAction } from './actions/transfer';\nimport { delegateL1Action } from './actions/delegateL1';\nimport { getCheckpointStatusAction } from './actions/getCheckpointStatus';\nimport { proposeGovernanceAction } from './actions/proposeGovernance';\nimport { voteGovernanceAction } from './actions/voteGovernance';\nimport { getValidatorInfoAction } from './actions/getValidatorInfo';\nimport { getDelegatorInfoAction } from './actions/getDelegatorInfo';\nimport { withdrawRewardsAction } from './actions/withdrawRewardsL1';\nimport { bridgeDepositAction } from './actions/bridgeDeposit';\nimport { getL2BlockNumberAction } from './actions/getL2BlockNumber';\nimport { getMaticBalanceAction } from './actions/getMaticBalance';\nimport { getPolygonGasEstimatesAction } from './actions/getPolygonGasEstimates';\nimport { undelegateL1Action } from './actions/undelegateL1';\nimport { restakeRewardsL1Action } from './actions/restakeRewardsL1';\nimport { isL2BlockCheckpointedAction } from './actions/isL2BlockCheckpointed';\nimport { heimdallVoteAction } from './actions/heimdallVoteAction';\nimport { heimdallSubmitProposalAction } from './actions/heimdallSubmitProposalAction';\nimport { heimdallTransferTokensAction } from './actions/heimdallTransferTokensAction';\n// import { getNativeBalanceAction, getERC20BalanceAction } from './actions/getBalanceInfo.js';\nimport { getUSDCBalanceAction, getWETHBalanceAction } from './actions/getBalanceInfo.js';\nimport { getBlockNumberAction, getBlockDetailsAction } from './actions/getBlockInfo.js';\nimport { getPolygonBlockDetailsAction } from './actions/getPolygonBlockDetails.js';\n\nimport {\n  WalletProvider,\n  initWalletProvider,\n  polygonWalletProvider,\n} from './providers/PolygonWalletProvider';\nimport {\n  PolygonRpcService,\n  type ValidatorInfo,\n  type DelegatorInfo,\n  ValidatorStatus,\n} from './services/PolygonRpcService';\nimport { HeimdallService } from './services/HeimdallService';\nimport { getGasPriceEstimates, type GasPriceEstimates } from './services/GasService';\nimport { parseBigIntString } from './utils'; // Import from utils\n\n// --- Configuration Schema --- //\nconst configSchema = z.object({\n  POLYGON_RPC_URL: z.string().url('Invalid Polygon RPC URL').min(1),\n  ETHEREUM_RPC_URL: z.string().url('Invalid Ethereum RPC URL').min(1),\n  PRIVATE_KEY: z.string().min(1, 'Private key is required'),\n  POLYGONSCAN_KEY: z.string().min(1, 'PolygonScan API Key is required'),\n  HEIMDALL_RPC_URL: z.string().url('Invalid Heimdall RPC URL').min(1).optional(),\n});\n\n// Infer the type from the schema\ntype PolygonPluginConfig = z.infer<typeof configSchema>;\n\n// --- Define Actions --- //\nconst polygonActions: Action[] = [\n  transferPolygonAction,\n  getValidatorInfoAction,\n  getDelegatorInfoAction,\n  bridgeDepositAction,\n  getCheckpointStatusAction,\n  proposeGovernanceAction,\n  voteGovernanceAction,\n  getL2BlockNumberAction,\n  getMaticBalanceAction,\n  getPolygonGasEstimatesAction,\n  delegateL1Action,\n  undelegateL1Action,\n  withdrawRewardsAction,\n  restakeRewardsL1Action,\n  isL2BlockCheckpointedAction,\n  heimdallVoteAction,\n  heimdallSubmitProposalAction,\n  heimdallTransferTokensAction,\n  getBlockNumberAction,\n  // getBlockDetailsAction,  // Temporarily disabled - uses old interface, conflicts with getPolygonBlockDetailsAction\n  getPolygonBlockDetailsAction,\n  getUSDCBalanceAction,\n  getWETHBalanceAction,\n];\n\n// Debug logging for action registration\nlogger.info(`[PolygonPlugin] Registering ${polygonActions.length} actions:`);\npolygonActions.forEach((action) => {\n  logger.info(\n    `[PolygonPlugin] - Action: ${action.name} (similes: ${action.similes?.join(', ') || 'none'})`\n  );\n});\nlogger.info(\n  `[PolygonPlugin] Actions with new interface: GET_MATIC_BALANCE, GET_L2_BLOCK_NUMBER, GET_POLYGON_BLOCK_DETAILS, GET_USDC_BALANCE, GET_WETH_BALANCE`\n);\n\n// --- Define Providers --- //\n\n/**\n * Provider to fetch and display Polygon-specific info like address, balance, gas.\n */\nconst polygonProviderInfo: Provider = {\n  name: 'Polygon Provider Info',\n  async get(runtime: IAgentRuntime, _message, state): Promise<ProviderResult> {\n    try {\n      // 1. Initialize WalletProvider to get address\n      const polygonWalletProviderInstance = await initWalletProvider(runtime);\n      if (!polygonWalletProviderInstance) {\n        // Renamed to avoid conflict\n        throw new Error(\n          'Failed to initialize PolygonWalletProvider - check PRIVATE_KEY configuration'\n        );\n      }\n      const agentAddress = polygonWalletProviderInstance.getAddress();\n      if (!agentAddress) throw new Error('Could not determine agent address from provider');\n\n      // 2. Get PolygonRpcService instance (should be already started)\n      const polygonRpcService = runtime.getService<PolygonRpcService>(\n        PolygonRpcService.serviceType\n      );\n      if (!polygonRpcService) {\n        throw new Error('PolygonRpcService not available or not started');\n      }\n\n      // 3. Get L2 (Polygon) MATIC balance\n      const maticBalanceWei = await polygonRpcService.getBalance(agentAddress, 'L2');\n      const maticBalanceFormatted = ethers.formatEther(maticBalanceWei);\n\n      // 4. Get Gas price info\n      const gasEstimates = await getGasPriceEstimates(runtime);\n\n      const agentName = state?.agentName || 'The agent';\n\n      // 5. Format the text output\n      let text = `${agentName}'s Polygon Status:\\\\n`;\n      text += `  Wallet Address: ${agentAddress}\\\\n`;\n      text += `  MATIC Balance: ${maticBalanceFormatted} MATIC\\\\n`;\n      text += '  Current Gas Prices (Max Priority Fee Per Gas - Gwei):\\\\n';\n      const safeLowGwei = gasEstimates.safeLow?.maxPriorityFeePerGas\n        ? ethers.formatUnits(gasEstimates.safeLow.maxPriorityFeePerGas, 'gwei')\n        : 'N/A';\n      const averageGwei = gasEstimates.average?.maxPriorityFeePerGas\n        ? ethers.formatUnits(gasEstimates.average.maxPriorityFeePerGas, 'gwei')\n        : 'N/A';\n      const fastGwei = gasEstimates.fast?.maxPriorityFeePerGas\n        ? ethers.formatUnits(gasEstimates.fast.maxPriorityFeePerGas, 'gwei')\n        : 'N/A';\n      const baseFeeGwei = gasEstimates.estimatedBaseFee\n        ? ethers.formatUnits(gasEstimates.estimatedBaseFee, 'gwei')\n        : 'N/A';\n\n      text += `    - Safe Low: ${safeLowGwei}\\\\n`;\n      text += `    - Average:  ${averageGwei}\\\\n`; // Adjusted name to average\n      text += `    - Fast:     ${fastGwei}\\\\n`;\n      text += `  Estimated Base Fee (Gwei): ${baseFeeGwei}\\\\n`;\n\n      return {\n        text,\n        data: {\n          address: agentAddress,\n          maticBalance: maticBalanceFormatted,\n          gasEstimates: {\n            safeLowGwei,\n            averageGwei,\n            fastGwei,\n            baseFeeGwei,\n          },\n        },\n        values: {\n          // Provide raw values or formatted strings as needed\n          address: agentAddress,\n          maticBalance: maticBalanceFormatted,\n          gas_safe_low_gwei: safeLowGwei,\n          gas_average_gwei: averageGwei, // Changed key name\n          gas_fast_gwei: fastGwei,\n          gas_base_fee_gwei: baseFeeGwei,\n        },\n      };\n    } catch (error) {\n      logger.error('Error getting Polygon provider info:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      // Create a more user-friendly message based on the error\n      const userMessage = errorMessage.includes('private key')\n        ? 'There was an issue with the wallet configuration. Please ensure PRIVATE_KEY is correctly set.'\n        : `Error getting Polygon provider info: ${errorMessage}`;\n\n      return {\n        text: userMessage,\n        data: { error: errorMessage },\n        values: { error: errorMessage },\n      };\n    }\n  },\n};\n\nconst polygonProviders: Provider[] = [polygonWalletProvider, polygonProviderInfo];\n\n// --- Define Services --- //\nconst polygonServices: (typeof Service)[] = [PolygonRpcService, HeimdallService];\n\n// --- Plugin Definition --- //\nexport const polygonPlugin: Plugin = {\n  name: '@elizaos/plugin-polygon',\n  description: 'Plugin for interacting with the Polygon PoS network and staking.',\n\n  // Configuration loaded from environment/character settings\n  config: {\n    POLYGON_RPC_URL: process.env.POLYGON_RPC_URL,\n    ETHEREUM_RPC_URL: process.env.ETHEREUM_RPC_URL,\n    PRIVATE_KEY: process.env.PRIVATE_KEY,\n    POLYGONSCAN_KEY: process.env.POLYGONSCAN_KEY,\n    HEIMDALL_RPC_URL: process.env.HEIMDALL_RPC_URL,\n  },\n\n  // Initialization logic\n  async init(config: Record<string, unknown>, runtime: IAgentRuntime) {\n    logger.info(`Initializing plugin: ${this.name}`);\n    try {\n      // Validate configuration\n      const validatedConfig = await configSchema.parseAsync(config);\n      logger.info('Polygon plugin configuration validated successfully.');\n\n      // Store validated config in runtime settings for services/actions/providers to access\n      // This assumes runtime has a way to store validated plugin config or settings are global\n      for (const [key, value] of Object.entries(validatedConfig)) {\n        if (!runtime.getSetting(key)) {\n          logger.warn(\n            `Setting ${key} was validated but not found via runtime.getSetting. Ensure it is loaded globally before plugin init.`\n          );\n        }\n      }\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        logger.error('Invalid Polygon plugin configuration:', error.errors);\n        throw new Error(\n          `Invalid Polygon plugin configuration: ${error.errors.map((e) => `${e.path.join('.')}: ${e.message}`).join('; ')}`\n        );\n      }\n      logger.error('Error during Polygon plugin initialization:', error);\n      throw error;\n    }\n  },\n\n  // Register components\n  actions: polygonActions,\n  providers: polygonProviders,\n  services: polygonServices,\n\n  // Optional lifecycle methods, models, tests, routes, events\n  models: {},\n  tests: [],\n  routes: [],\n  events: {},\n};\n\n// Default export for ElizaOS to load\nexport default polygonPlugin;\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  type ActionExample,\n  type TemplateType,\n} from '@elizaos/core';\n// import { type Chain, polygon as polygonChain, mainnet as ethereumChain } from 'viem/chains'; // Managed by Provider\nimport {\n  // createWalletClient, http, type WalletClient, // Provided by WalletProvider instance\n  parseEther,\n  type Address,\n  type Hex,\n  // PublicClient, createPublicClient, fallback, // Provided by WalletProvider instance\n  formatEther,\n  type Transport, // Not directly used\n  type Account, // Not directly used\n  type Chain, // For type annotation\n} from 'viem';\n// import { privateKeyToAccount } from 'viem/accounts'; // Handled by Provider\n\nimport { WalletProvider, initWalletProvider } from '../providers/PolygonWalletProvider';\n\n// Minimal ABI for ERC20 transfer (optional, if not using raw data)\nconst erc20TransferAbi = [\n  {\n    inputs: [\n      { name: 'to', type: 'address' },\n      { name: 'value', type: 'uint256' },\n    ],\n    name: 'transfer',\n    outputs: [{ name: '', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\n// REMOVE INLINE WalletProvider, ChainConfig, and initWalletProvider\n\ninterface TransferParams {\n  fromChain: string; // Name of the chain, e.g., \"polygon\"\n  toAddress: Address;\n  amount: string; // Amount as string, e.g., \"1.5\" for native currency\n  data?: Hex; // Optional data for contract interaction (e.g., ERC20 transfer)\n  tokenAddress?: Address; // Optional, for ERC20 transfers, toAddress would be this, data is encoded transfer\n}\n\ninterface Transaction {\n  hash: `0x${string}`;\n  from: Address;\n  to: Address;\n  value: bigint;\n  chainId: number;\n  data?: Hex;\n  logs: any[];\n}\n\nconst transferTemplateObj = {\n  name: 'Transfer MATIC or Tokens',\n  description:\n    'Generates parameters to transfer MATIC (native currency) or execute a token transaction. // Respond with a valid JSON object containing the extracted parameters.',\n  parameters: {\n    type: 'object',\n    properties: {\n      fromChain: {\n        type: 'string',\n        description: 'Blockchain name (e.g., polygon). Default: polygon.',\n        default: 'polygon',\n      },\n      toAddress: { type: 'string', description: 'Recipient address.' },\n      amount: {\n        type: 'string',\n        description:\n          'Amount of MATIC (native) to transfer. For ERC20, use \"0\" if value is in data.',\n      },\n      data: {\n        type: 'string',\n        description: 'Optional: Hex data for transaction (e.g., ERC20 transfer calldata).',\n      },\n      tokenAddress: { type: 'string', description: 'Optional: ERC20 token contract address.' },\n    },\n    required: ['toAddress', 'amount'],\n  },\n} as const; // Use as const for better type inference if TemplateType is structural\n\nclass PolygonTransferActionRunner {\n  constructor(private walletProvider: WalletProvider) {} // Use imported WalletProvider\n\n  async transfer(params: TransferParams): Promise<Transaction> {\n    const effectiveChain = (params.fromChain || 'polygon').toLowerCase();\n    const walletClient = this.walletProvider.getWalletClient(effectiveChain);\n    const publicClient = this.walletProvider.getPublicClient(effectiveChain);\n    const chainConfig = this.walletProvider.getChainConfigs(effectiveChain); // viem.Chain from provider\n    const [fromAddress] = await walletClient.getAddresses();\n\n    let txTo: Address = params.toAddress;\n    let txData: Hex | undefined = params.data === '0x' ? undefined : params.data;\n    let txValue = parseEther(params.amount); // Amount is native value unless it's an ERC20 call w/ data\n\n    if (params.tokenAddress) {\n      // ERC20 Transfer, data should be prepared by LLM or helper\n      txTo = params.tokenAddress; // Target is token contract\n      // If txData is not provided, and it's an ERC20, we might need to encode it.\n      // Assuming LLM provides it or params.data is already the encoded call.\n      if (!txData) {\n        logger.warn(\n          `ERC20 tokenAddress ${params.tokenAddress} provided, but no txData. This action will likely fail or do something unintended unless the LLM provides specific calldata for this token interaction.`\n        );\n      } else {\n        // If data is provided for an ERC20 token, amount (txValue) should typically be 0 for the main call,\n        // as the value transfer is encoded within the data.\n        // However, the original logic used params.amount as value. For consistency, we keep it unless it causes issues.\n        // txValue = BigInt(0); // Typically for ERC20 calls where value is in data.\n        logger.info(\n          `ERC20 interaction with token ${txTo}, data: ${txData}. Value field ${params.amount} ETH will be sent with this call.`\n        );\n      }\n    } else if (txData) {\n      logger.info(\n        `Raw transaction with data ${txData} to ${params.toAddress}. Value: ${params.amount} ETH.`\n      );\n      // For raw tx, toAddress is params.toAddress, value is params.amount, data is params.data\n    } else {\n      // Native currency transfer\n      logger.info(\n        `Native transfer: ${params.amount} ETH to ${params.toAddress} on ${effectiveChain}.`\n      );\n    }\n\n    try {\n      const kzg = {\n        blobToKzgCommitment: (_blob: any) => {\n          throw new Error('KZG not impl.');\n        },\n        computeBlobKzgProof: (_blob: any, _commit: any) => {\n          throw new Error('KZG not impl.');\n        },\n      };\n      const hash = await walletClient.sendTransaction({\n        account: fromAddress,\n        to: txTo,\n        value: txValue,\n        data: txData,\n        chain: chainConfig,\n        kzg,\n      });\n\n      logger.info(`Transaction sent: ${hash}. Waiting for receipt...`);\n      const receipt = await publicClient.waitForTransactionReceipt({ hash });\n\n      return {\n        hash,\n        from: fromAddress,\n        to: txTo,\n        value: txValue,\n        data: txData,\n        chainId: chainConfig.id,\n        logs: receipt.logs as any[],\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error(`Transfer failed: ${errMsg}`, error);\n      throw new Error(`Transfer failed: ${errMsg}`);\n    }\n  }\n}\n\nexport const transferPolygonAction: Action = {\n  name: 'TRANSFER_POLYGON',\n  similes: ['POLYGON_SEND', 'TRANSFER_MATIC_OR_TOKEN_POLYGON'],\n  description: 'Transfers MATIC (native currency) or executes a token transaction on Polygon.',\n\n  validate: async (runtime: IAgentRuntime, _m: Memory, _s: State | undefined): Promise<boolean> => {\n    logger.debug('Validating TRANSFER_POLYGON action...');\n    const checks = [\n      runtime.getSetting('WALLET_PRIVATE_KEY'),\n      runtime.getSetting('POLYGON_PLUGINS_ENABLED'),\n    ];\n    if (checks.some((check) => !check)) {\n      logger.error(\n        'Required settings (WALLET_PRIVATE_KEY, POLYGON_PLUGINS_ENABLED) are not configured.'\n      );\n      return false;\n    }\n    try {\n      await initWalletProvider(runtime);\n    } catch (e) {\n      const errMsg = e instanceof Error ? e.message : String(e);\n      logger.error(`WalletProvider initialization failed during validation: ${errMsg}`);\n      return false;\n    }\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: any,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    logger.info('Handling TRANSFER_POLYGON for message:', message.id);\n    try {\n      const walletProvider = await initWalletProvider(runtime);\n      const actionRunner = new PolygonTransferActionRunner(walletProvider);\n\n      const supportedChains = Object.keys(walletProvider.chains)\n        .map((c) => `\\\"${c}\\\"`)\n        .join(' | ');\n      const dynamicTransferTemplate = {\n        ...transferTemplateObj,\n        parameters: {\n          ...transferTemplateObj.parameters,\n          properties: {\n            ...transferTemplateObj.parameters.properties,\n            fromChain: {\n              type: 'string',\n              description: `The blockchain name (e.g., polygon). Supported: ${supportedChains}. Default is polygon.`,\n              default: 'polygon',\n            },\n          },\n        },\n      } as unknown as TemplateType;\n\n      const prompt = composePromptFromState({\n        state,\n        template: dynamicTransferTemplate,\n      });\n      const modelResponse = await runtime.useModel(ModelType.SMALL, { prompt });\n      let paramsJson;\n      try {\n        const jsonString = (modelResponse || '').replace(/^```json(\\r?\\n)?|(\\r?\\n)?```$/g, '');\n        paramsJson = JSON.parse(jsonString);\n      } catch (e) {\n        logger.error('Failed to parse LLM response for transfer params:', modelResponse, e);\n        throw new Error('Could not understand transfer parameters.');\n      }\n\n      if (!paramsJson.toAddress || typeof paramsJson.amount === 'undefined') {\n        throw new Error('Incomplete transfer parameters: toAddress and amount are required.');\n      }\n\n      const transferParams: TransferParams = {\n        fromChain: ((paramsJson.fromChain as string) || 'polygon').toLowerCase(),\n        toAddress: paramsJson.toAddress as Address,\n        amount: paramsJson.amount as string,\n        data: paramsJson.data as Hex | undefined,\n        tokenAddress: paramsJson.tokenAddress as Address | undefined,\n      };\n\n      logger.debug('Parsed transfer parameters:', transferParams);\n      const txResult = await actionRunner.transfer(transferParams);\n      const successMsg = `Successfully transferred ${transferParams.amount} ${transferParams.tokenAddress ? `token ${transferParams.tokenAddress}` : 'native currency'} to ${transferParams.toAddress} on ${transferParams.fromChain}. TxHash: ${txResult.hash}`;\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: { success: true, ...txResult, chain: transferParams.fromChain },\n          actions: ['TRANSFER_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: true, ...txResult, chain: transferParams.fromChain };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in TRANSFER_POLYGON handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error transferring assets: ${errMsg}`,\n          actions: ['TRANSFER_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'Transfer MATIC',\n        content: { text: 'Send 10.5 MATIC to 0xRecipientAddress on Polygon.' },\n      },\n    ],\n    [\n      {\n        name: 'Transfer USDC',\n        content: {\n          text: 'Transfer 100 USDC (0xTokenAddress) to 0xRecipient on Polygon. Calldata: 0xData.',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  createPublicClient,\n  createTestClient,\n  createWalletClient,\n  formatUnits,\n  http,\n  publicActions,\n  walletActions,\n} from 'viem';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport {\n  type IAgentRuntime,\n  type Provider,\n  type Memory,\n  type State,\n  elizaLogger,\n  type ProviderResult,\n} from '@elizaos/core';\nimport type {\n  Address,\n  WalletClient,\n  PublicClient,\n  Chain,\n  HttpTransport,\n  Account,\n  PrivateKeyAccount,\n  TestClient,\n} from 'viem';\nimport * as viemChains from 'viem/chains';\nimport { PhalaDeriveKeyProvider } from '@elizaos/plugin-tee';\nimport NodeCache from 'node-cache';\nimport * as path from 'node:path';\n\nimport type { SupportedChain } from '../types';\n\nconst ETH_MAINNET_KEY = 'ethereum';\n\nexport class WalletProvider {\n  private cache: NodeCache;\n  private cacheKey = 'polygon/wallet';\n  private currentChain: SupportedChain = ETH_MAINNET_KEY as SupportedChain;\n  private CACHE_EXPIRY_SEC = 5;\n  chains: Record<string, Chain> = {};\n  account: PrivateKeyAccount;\n  runtime: IAgentRuntime;\n\n  constructor(\n    accountOrPrivateKey: PrivateKeyAccount | `0x${string}`,\n    runtime: IAgentRuntime,\n    chains?: Record<string, Chain>\n  ) {\n    this.setAccount(accountOrPrivateKey);\n    this.setChains(chains);\n    this.runtime = runtime;\n\n    if (chains && Object.keys(chains).length > 0) {\n      this.setCurrentChain(Object.keys(chains)[0] as SupportedChain);\n    }\n\n    this.cache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\n  }\n\n  getAddress(): Address {\n    return this.account.address;\n  }\n\n  hasChain = (name: string) => Boolean(this.chains[name]);\n\n  getCurrentChain(): Chain {\n    return this.chains[this.currentChain];\n  }\n\n  getPublicClient(\n    chainName: SupportedChain\n  ): PublicClient<HttpTransport, Chain, Account | undefined> {\n    const transport = this.createHttpTransport(chainName);\n\n    const publicClient = createPublicClient({\n      chain: this.chains[chainName],\n      transport,\n    });\n    return publicClient;\n  }\n\n  getWalletClient(chainName: SupportedChain): WalletClient {\n    const transport = this.createHttpTransport(chainName);\n\n    const walletClient = createWalletClient({\n      chain: this.chains[chainName],\n      transport,\n      account: this.account,\n    });\n\n    return walletClient;\n  }\n\n  getTestClient(): TestClient {\n    return createTestClient({\n      chain: viemChains.hardhat,\n      mode: 'hardhat',\n      transport: http(),\n    })\n      .extend(publicActions)\n      .extend(walletActions);\n  }\n\n  getChainConfigs(chainName: SupportedChain): Chain {\n    const key = chainName === ETH_MAINNET_KEY ? 'mainnet' : chainName;\n    const chain = viemChains[key];\n\n    if (!chain?.id) {\n      throw new Error('Invalid chain name');\n    }\n\n    return chain;\n  }\n\n  async getWalletBalance(): Promise<string | null> {\n    try {\n      const client = this.getPublicClient(this.currentChain);\n      const balance = await client.getBalance({\n        address: this.account.address,\n      });\n      const balanceFormatted = formatUnits(balance, 18);\n      elizaLogger.log('Wallet balance cached for chain: ', this.currentChain);\n      return balanceFormatted;\n    } catch (error) {\n      console.error('Error getting wallet balance:', error);\n      return null;\n    }\n  }\n\n  async getWalletBalanceForChain(chainName: SupportedChain): Promise<string | null> {\n    try {\n      const client = this.getPublicClient(chainName);\n      const balance = await client.getBalance({\n        address: this.account.address,\n      });\n      return formatUnits(balance, 18);\n    } catch (error) {\n      console.error('Error getting wallet balance:', error);\n      return null;\n    }\n  }\n\n  addChain(chain: Record<string, Chain>) {\n    this.setChains(chain);\n  }\n\n  getActiveWalletClient(): WalletClient {\n    return this.getWalletClient(this.currentChain);\n  }\n\n  switchChain(chainName: SupportedChain, customRpcUrl?: string) {\n    if (!this.chains[chainName]) {\n      const chain = WalletProvider.genChainFromName(chainName, customRpcUrl);\n      this.addChain({ [chainName]: chain });\n    }\n    this.setCurrentChain(chainName);\n  }\n  async switchChainById(chainId: number): Promise<WalletClient> {\n    const entry = Object.entries(this.chains).find(([, c]) => c.id === chainId);\n    if (!entry) throw new Error(`Unsupported chainId ${chainId}`);\n    const [name] = entry as [SupportedChain, Chain];\n    this.setCurrentChain(name);\n    return this.getActiveWalletClient();\n  }\n\n  private setAccount = (accountOrPrivateKey: PrivateKeyAccount | `0x${string}`) => {\n    if (typeof accountOrPrivateKey === 'string') {\n      this.account = privateKeyToAccount(accountOrPrivateKey);\n    } else {\n      this.account = accountOrPrivateKey;\n    }\n  };\n\n  private setChains = (chains?: Record<string, Chain>) => {\n    if (!chains) {\n      return;\n    }\n    for (const chain of Object.keys(chains)) {\n      this.chains[chain] = chains[chain];\n    }\n  };\n\n  private setCurrentChain = (chain: SupportedChain) => {\n    this.currentChain = chain;\n  };\n\n  private createHttpTransport = (chainName: SupportedChain) => {\n    const chain = this.chains[chainName];\n\n    if (!chain) {\n      throw new Error(\n        `Unsupported chain \"${chainName}\". Available: ${Object.keys(this.chains).join(', ')}`\n      );\n    }\n\n    if (chain.rpcUrls.custom) {\n      return http(chain.rpcUrls.custom.http[0]);\n    }\n    return http(chain.rpcUrls.default.http[0]);\n  };\n\n  static genChainFromName(chainName: string, customRpcUrl?: string | null): Chain {\n    const baseChain = viemChains[chainName];\n\n    if (!baseChain?.id) {\n      throw new Error('Invalid chain name');\n    }\n\n    const viemChain: Chain = customRpcUrl\n      ? {\n          ...baseChain,\n          rpcUrls: {\n            ...baseChain.rpcUrls,\n            custom: {\n              http: [customRpcUrl],\n            },\n          },\n        }\n      : baseChain;\n\n    return viemChain;\n  }\n}\n\n// --- Adjusted Chain Configuration Logic --- //\n\nconst genChainsFromRuntime = (runtime: IAgentRuntime): Record<string, Chain> => {\n  const chains: Record<string, Chain> = {};\n\n  // 1. Get L2 Polygon RPC URL\n  const polygonRpcUrl = runtime.getSetting('POLYGON_RPC_URL');\n  if (polygonRpcUrl) {\n    // Attempt to determine if it's mainnet or testnet (Mumbai)\n    // Simple check for now, could be more robust\n    const isMainnet = !/mumbai/i.test(polygonRpcUrl);\n    const polygonChainName = isMainnet ? 'polygon' : 'polygonMumbai';\n    try {\n      const chain = WalletProvider.genChainFromName(polygonChainName, polygonRpcUrl);\n      chains[polygonChainName] = chain;\n      elizaLogger.info(`Configured Polygon chain: ${polygonChainName}`);\n    } catch (error) {\n      elizaLogger.error(`Error configuring Polygon chain (${polygonChainName}):`, error);\n    }\n  } else {\n    elizaLogger.warn('POLYGON_RPC_URL setting not found.');\n  }\n\n  // 2. Get L1 Ethereum RPC URL\n  const ethRpcUrl = runtime.getSetting('ETHEREUM_RPC_URL');\n  if (ethRpcUrl) {\n    // Attempt to determine if it's mainnet or testnet (e.g., Sepolia)\n    const isEthMainnet = !/(sepolia|goerli|ropsten|kovan)/i.test(ethRpcUrl);\n    const viemKeyForEth = isEthMainnet ? 'mainnet' : 'sepolia';\n    const storageKeyForEth = isEthMainnet ? ETH_MAINNET_KEY : 'sepolia'; // ETH_MAINNET_KEY is \"ethereum\"\n    try {\n      const chain = WalletProvider.genChainFromName(viemKeyForEth, ethRpcUrl);\n      chains[storageKeyForEth] = chain;\n      elizaLogger.info(\n        `Configured Ethereum L1 chain: ${storageKeyForEth} (using viem key: ${viemKeyForEth})`\n      );\n    } catch (error) {\n      elizaLogger.error(\n        `Error configuring Ethereum L1 chain (${storageKeyForEth} with viem key ${viemKeyForEth}):`,\n        error\n      );\n    }\n  } else {\n    elizaLogger.warn('ETHEREUM_RPC_URL setting not found.');\n  }\n\n  if (Object.keys(chains).length === 0) {\n    elizaLogger.error('No chains could be configured. WalletProvider may not function correctly.');\n  }\n\n  return chains;\n};\n\nexport const initWalletProvider = async (\n  runtime: IAgentRuntime\n): Promise<WalletProvider | null> => {\n  // TEE Mode handling (optional, keep if needed, ensure settings are correct)\n  const teeMode = runtime.getSetting('TEE_MODE') || 'OFF'; // Use correct setting if TEE is used\n\n  const chains = genChainsFromRuntime(runtime);\n  if (Object.keys(chains).length === 0) {\n    elizaLogger.error('Cannot initialize WalletProvider: No chains configured.');\n    return null; // Return null or throw error if no chains are essential\n  }\n\n  if (teeMode !== 'OFF') {\n    const walletSecretSalt = runtime.getSetting('WALLET_SECRET_SALT'); // Use correct TEE setting key if needed\n    if (!walletSecretSalt) {\n      throw new Error('WALLET_SECRET_SALT required when TEE_MODE is enabled');\n    }\n\n    try {\n      const deriveKeyProvider = new PhalaDeriveKeyProvider(teeMode);\n      const deriveKeyResult = await deriveKeyProvider.deriveEcdsaKeypair(\n        walletSecretSalt,\n        'polygon', // Use a unique context for polygon\n        runtime.agentId\n      );\n      elizaLogger.info('Initialized WalletProvider using TEE derived key.');\n      return new WalletProvider(\n        deriveKeyResult.keypair as unknown as PrivateKeyAccount,\n        runtime,\n        chains\n      );\n    } catch (error) {\n      elizaLogger.error('Failed to initialize WalletProvider with TEE:', error);\n      throw error; // Rethrow TEE initialization error\n    }\n  } else {\n    // Use PRIVATE_KEY defined in this plugin's config\n    const rawPrivateKey = runtime.getSetting('PRIVATE_KEY');\n    elizaLogger.info('PRIVATE_KEY setting retrieved (not showing actual key for security)');\n\n    if (!rawPrivateKey) {\n      elizaLogger.error(\n        'PRIVATE_KEY setting is missing or not loaded. Cannot initialize WalletProvider.'\n      );\n      throw new Error('PRIVATE_KEY setting is missing for WalletProvider initialization');\n    }\n\n    try {\n      // Format the private key correctly with 0x prefix if missing\n      const privateKey = rawPrivateKey.startsWith('0x')\n        ? (rawPrivateKey as `0x${string}`)\n        : (`0x${rawPrivateKey}` as `0x${string}`);\n\n      const provider = new WalletProvider(privateKey, runtime, chains);\n      elizaLogger.info('Initialized WalletProvider using PRIVATE_KEY setting.');\n      return provider;\n    } catch (error) {\n      elizaLogger.error('Failed to initialize WalletProvider with private key:', error);\n      throw error; // Rethrow wallet initialization error\n    }\n  }\n};\n\n// Fallback function to fetch wallet data directly\nasync function directFetchWalletData(\n  runtime: IAgentRuntime,\n  state?: State\n): Promise<ProviderResult> {\n  try {\n    const walletProvider = await initWalletProvider(runtime);\n    if (!walletProvider) {\n      throw new Error('Failed to initialize wallet provider');\n    }\n\n    const address = walletProvider.getAddress();\n\n    // Get balance for each configured chain\n    const chainBalances: Record<string, string> = {};\n    for (const chainName of Object.keys(walletProvider.chains)) {\n      try {\n        const balance = await walletProvider.getWalletBalanceForChain(chainName as SupportedChain);\n        if (balance) {\n          chainBalances[chainName] = balance;\n        }\n      } catch (error) {\n        elizaLogger.error(`Error getting balance for chain ${chainName}:`, error);\n      }\n    }\n\n    const agentName = state?.agentName || 'The agent';\n\n    // Format balances for all chains\n    const chainDetails = Object.entries(chainBalances).map(([chainName, balance]) => {\n      const chain = walletProvider.chains[chainName];\n      return {\n        chainName,\n        balance,\n        symbol: chain.nativeCurrency.symbol,\n        chainId: chain.id,\n        name: chain.name,\n      };\n    });\n\n    // Create a text representation of all chain balances\n    const balanceText = chainDetails\n      .map((chain) => `${chain.name}: ${chain.balance} ${chain.symbol}`)\n      .join('\\n');\n\n    return {\n      text: `${agentName}'s Polygon Wallet Address: ${address}\\n\\nBalances:\\n${balanceText}`,\n      data: {\n        address,\n        chains: chainDetails,\n      },\n      values: {\n        address: address as string,\n        chains: JSON.stringify(chainDetails),\n      },\n    };\n  } catch (error) {\n    elizaLogger.error('Error fetching wallet data directly:', error);\n    return {\n      text: `Error getting Polygon wallet provider: ${error instanceof Error ? error.message : String(error)}`,\n      data: { error: error instanceof Error ? error.message : String(error) },\n      values: { error: error instanceof Error ? error.message : String(error) },\n    };\n  }\n}\n\nexport const polygonWalletProvider: Provider = {\n  name: 'PolygonWalletProvider',\n  async get(runtime: IAgentRuntime, _message: Memory, state?: State): Promise<ProviderResult> {\n    try {\n      // Always use the direct fetch method for consistency\n      return await directFetchWalletData(runtime, state);\n    } catch (error) {\n      elizaLogger.error('Error in Polygon wallet provider:', error);\n      const errorText = error instanceof Error ? error.message : String(error);\n      return {\n        text: `Error in Polygon wallet provider: ${errorText}`,\n        data: { error: errorText },\n        values: { error: errorText },\n      };\n    }\n  },\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePrompt,\n  ModelType,\n  composePromptFromState,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { ethers, parseUnits } from 'ethers';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { delegateL1Template } from '../templates';\nimport { parseErrorMessage } from '../errors';\n\n// Define input schema for the LLM-extracted parameters\ninterface DelegateL1Params {\n  validatorId?: number;\n  amountWei?: string; // Amount in smallest unit (Wei)\n  error?: string;\n}\n\n// Helper function to extract params from text if LLM fails\n// This is a simplified example; a more robust regex might be needed.\nfunction extractParamsFromText(text: string): Partial<DelegateL1Params> {\n  const params: Partial<DelegateL1Params> = {};\n\n  // Extract validator ID (positive integer)\n  const validatorIdMatch = text.match(/validator(?: id)?\\\\s*[:#]?\\\\s*(\\\\d+)/i);\n  if (validatorIdMatch?.[1]) {\n    const id = Number.parseInt(validatorIdMatch[1], 10);\n    if (id > 0) {\n      params.validatorId = id;\n    }\n  }\n\n  // Extract amount (e.g., \"10 MATIC\", \"5.5 MATIC\", \"0.25 ether\")\n  // This regex requires a number followed by a unit keyword\n  const amountMatch = text.match(/(\\d+(?:\\.\\d+)?)\\s*(MATIC|ETH|ether)\\b/i);\n  if (amountMatch?.[1]) {\n    try {\n      // Convert to Wei. Assumes 18 decimal places for MATIC/ETH.\n      params.amountWei = parseUnits(amountMatch[1], 18).toString();\n    } catch (e) {\n      logger.warn(`Could not parse amount from text: ${amountMatch[1]}`, e);\n    }\n  }\n\n  return params;\n}\n\nexport const delegateL1Action: Action = {\n  name: 'DELEGATE_L1',\n  similes: ['STAKE_L1_MATIC', 'DELEGATE_TO_VALIDATOR_L1', 'STAKE_ON_ETHEREUM_L1'],\n  description:\n    'Delegates (stakes) MATIC/POL tokens to a specified Polygon validator on the Ethereum L1 network.',\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating DELEGATE_L1 action...');\n\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for delegation\n      'POLYGON_PLUGINS_ENABLED', // Ensure main plugin toggle is on\n    ];\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(`Required setting ${setting} not configured for DELEGATE_L1 action.`);\n        return false;\n      }\n    }\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized for DELEGATE_L1.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error('Error accessing PolygonRpcService during DELEGATE_L1 validation:', error);\n      return false;\n    }\n    return true;\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _recentMessages: Memory[] | undefined\n  ) => {\n    logger.info('Handling DELEGATE_L1 action for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let params: DelegateL1Params | null = null;\n\n    try {\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      const prompt = composePromptFromState({\n        state,\n        template: delegateL1Template,\n      });\n\n      // Try using parseJSONObjectFromText with TEXT_SMALL model\n      try {\n        const result = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n\n        params = parseJSONObjectFromText(result) as DelegateL1Params;\n        logger.debug('DELEGATE_L1: Extracted params via TEXT_SMALL:', params);\n\n        // Check if the model response contains an error\n        if (params.error) {\n          logger.warn(`DELEGATE_L1: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (e) {\n        logger.warn(\n          'DELEGATE_L1: Failed to parse JSON from model response, trying manual extraction',\n          e\n        );\n\n        // Fallback to manual extraction from raw message text\n        const manualParams = extractParamsFromText(rawMessageText);\n        if (manualParams.validatorId && manualParams.amountWei) {\n          params = {\n            validatorId: manualParams.validatorId,\n            amountWei: manualParams.amountWei,\n          };\n          logger.debug('DELEGATE_L1: Extracted params via manual text parsing:', params);\n        } else {\n          throw new Error('Could not determine validator ID or amount from the message.');\n        }\n      }\n\n      // Validate the extracted parameters\n      if (!params?.validatorId || !params.amountWei) {\n        throw new Error('Validator ID or amount is missing after extraction attempts.');\n      }\n\n      const { validatorId, amountWei } = params;\n      logger.debug(`DELEGATE_L1 parameters: validatorId: ${validatorId}, amountWei: ${amountWei}`);\n\n      // Convert the amount to BigInt for the service\n      const amountBigInt = BigInt(amountWei);\n      const txHash = await polygonService.delegate(validatorId, amountBigInt);\n      const amountFormatted = ethers.formatEther(amountWei);\n\n      const successMsg = `Successfully initiated delegation of ${amountFormatted} MATIC to validator ${validatorId}. Transaction hash: ${txHash}`;\n      logger.info(successMsg);\n\n      const responseContent: Content = {\n        text: successMsg,\n        actions: ['DELEGATE_L1'],\n        source: message.content.source,\n        data: {\n          transactionHash: txHash,\n          status: 'pending',\n          validatorId: validatorId,\n          amountDelegatedMatic: amountFormatted,\n          amountDelegatedWei: amountWei,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    } catch (error: unknown) {\n      const parsedError = parseErrorMessage(error);\n      logger.error('Error in DELEGATE_L1 handler:', parsedError);\n\n      // Check if it's an \"insufficient funds\" error and provide more specific guidance\n      let errorText = parsedError.message;\n\n      if (errorText.includes('insufficient funds')) {\n        try {\n          // Try to extract amounts from error message if possible\n          const matches = errorText.match(/address (0x[a-fA-F0-9]+) have ([\\d.]+) want ([\\d.]+)/i);\n          if (matches && matches.length >= 4) {\n            const have = ethers.parseEther(matches[2]);\n            const want = ethers.parseEther(matches[3]);\n            const missing = want - have;\n\n            errorText = `Insufficient ETH for delegation. You have ${ethers.formatEther(have)} ETH but need ${ethers.formatEther(want)} ETH (missing ${ethers.formatEther(missing)} ETH). Please fund your wallet with more ETH to cover the transaction cost.`;\n\n            // Add diagnostic information when the requested amount seems unusually high\n            if (want > ethers.parseEther('0.05')) {\n              errorText +=\n                '\\n\\nNOTE: The required ETH amount appears unusually high. This typically indicates one of two issues:\\n' +\n                '1. Your MATIC amount is being sent as transaction value instead of using token approval\\n' +\n                \"2. Gas price is being calculated incorrectly (possibly using 18 decimals instead of 'gwei')\\n\" +\n                'The normal gas cost for delegation is ~0.005-0.015 ETH.';\n            }\n          } else {\n            // Generic improved message for insufficient funds\n            errorText =\n              'Insufficient ETH to cover transaction fees. Please fund your wallet with more ETH (typically 0.005-0.015 ETH is enough) and try again.';\n          }\n        } catch (parseErr) {\n          logger.warn('Error parsing amounts from insufficient funds error:', parseErr);\n          // Fall back to generic message if parsing fails\n          errorText =\n            'Insufficient ETH to cover transaction fees. Please fund your wallet with ~0.01 ETH and try again.';\n        }\n      }\n\n      const errorContent: Content = {\n        text: `Error delegating MATIC (L1): ${errorText}`,\n        actions: ['DELEGATE_L1'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: parsedError.message,\n          details: parsedError.details,\n          // Add diagnostic information about the transaction parameters\n          diagnostics: {\n            validatorId: params?.validatorId,\n            amountMaticRequested: params?.amountWei\n              ? ethers.formatEther(params.amountWei)\n              : 'unknown',\n            amountWei: params?.amountWei || 'unknown',\n          },\n        },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'I want to delegate 10 MATIC to validator 123 on L1',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Stake 5.5 MATIC with the Polygon validator ID 42 for L1 staking',\n        },\n      },\n    ],\n  ],\n};\n","import { Service, type IAgentRuntime, logger } from '@elizaos/core';\nimport {\n  ethers,\n  JsonRpcProvider,\n  type Provider as EthersProvider,\n  type Signer,\n  Wallet, // Import Wallet for signer creation\n  type TransactionResponse,\n  type TransactionReceipt,\n  type Block,\n  Contract,\n  type BigNumberish,\n  ZeroAddress,\n  type TransactionRequest,\n  MaxUint256, // Import MaxUint256 for approval checks\n} from 'ethers'; // Assuming ethers v6+\n\n// Import JSON ABIs\nimport StakeManagerABI from '../contracts/StakeManagerABI.json' assert { type: 'json' };\nimport ValidatorShareABI from '../contracts/ValidatorShareABI.json' assert { type: 'json' };\nimport RootChainManagerABI from '../contracts/RootChainManagerABI.json' assert { type: 'json' };\nimport Erc20ABI from '../contracts/ERC20ABI.json' assert { type: 'json' };\nimport CheckpointManagerABI from '../contracts/CheckpointManagerABI.json' assert { type: 'json' };\n\n// Re-import GasService components\nimport { getGasPriceEstimates, type GasPriceEstimates } from './GasService.js';\n\nexport type NetworkType = 'L1' | 'L2';\n\n// --- Staking Contract Addresses (Ethereum Mainnet) ---\nconst STAKE_MANAGER_ADDRESS_L1 = '0x5e3Ef299fDDf15eAa0432E6e66473ace8c13D908';\nconst ROOT_CHAIN_MANAGER_ADDRESS_L1 = '0xA0c68C638235ee32657e8f720a23ceC1bFc77C77'; // Added RootChainManager Address\n\n// --- Type Definitions for Staking Info ---\n\n// Enum mapping based on StakeManager contract inspection (adjust if needed)\nexport enum ValidatorStatus { // Renamed for clarity\n  Inactive = 0,\n  Active = 1,\n  Unbonding = 2,\n  Jailed = 3,\n}\n\nexport interface ValidatorInfo {\n  status: ValidatorStatus;\n  totalStake: bigint; // Combined self-stake + delegated amount\n  commissionRate: number; // Percentage (e.g., 0.1 for 10%)\n  signerAddress: string;\n  activationEpoch: bigint;\n  deactivationEpoch: bigint;\n  jailEndEpoch: bigint;\n  contractAddress: string; // Address of the ValidatorShare contract\n  lastRewardUpdateEpoch: bigint;\n  // Add other relevant fields from the struct if needed\n}\n\nexport interface DelegatorInfo {\n  delegatedAmount: bigint;\n  pendingRewards: bigint;\n}\n\nexport class PolygonRpcService extends Service {\n  static serviceType = 'polygonRpc';\n  capabilityDescription =\n    'Provides access to Ethereum (L1) and Polygon (L2) JSON-RPC nodes and L1 staking operations.';\n\n  private runtime: IAgentRuntime;\n  private l1Provider: EthersProvider | null = null;\n  private l2Provider: EthersProvider | null = null;\n  private l1Signer: Signer | null = null; // Added L1 Signer\n  private stakeManagerContractL1: Contract | null = null; // Added for L1 StakeManager\n  private rootChainManagerContractL1: Contract | null = null; // Added RootChainManager instance\n\n  constructor(runtime: IAgentRuntime) {\n    super();\n    this.runtime = runtime;\n  }\n\n  private async initializeProviders(): Promise<void> {\n    if (this.l1Provider && this.l2Provider && this.rootChainManagerContractL1) {\n      return;\n    }\n    if (!this.runtime) {\n      throw new Error('Runtime required');\n    }\n\n    const l1RpcUrl = this.runtime.getSetting('ETHEREUM_RPC_URL');\n    const l2RpcUrl = this.runtime.getSetting('POLYGON_RPC_URL');\n    const privateKey = this.runtime.getSetting('PRIVATE_KEY'); // Get private key\n\n    if (!l1RpcUrl || !l2RpcUrl) {\n      throw new Error('Missing L1/L2 RPC URLs');\n    }\n    if (!privateKey) {\n      throw new Error('Missing PRIVATE_KEY for signer initialization');\n    }\n\n    try {\n      this.l1Provider = new JsonRpcProvider(l1RpcUrl);\n      this.l2Provider = new JsonRpcProvider(l2RpcUrl);\n      // Initialize L1 Signer\n      this.l1Signer = new Wallet(privateKey, this.l1Provider);\n      logger.info('PolygonRpcService initialized L1/L2 providers and L1 signer.');\n\n      // Initialize StakeManager contract instance (using L1 Provider for reads)\n      this.stakeManagerContractL1 = new Contract(\n        STAKE_MANAGER_ADDRESS_L1,\n        StakeManagerABI,\n        this.l1Provider\n      );\n      // Test connection by calling a valid function (e.g., epoch instead of validatorThreshold)\n      await this.stakeManagerContractL1.epoch(); // Test connection\n      logger.info('StakeManager L1 contract instance created and connection verified.');\n\n      this.rootChainManagerContractL1 = new Contract(\n        ROOT_CHAIN_MANAGER_ADDRESS_L1,\n        RootChainManagerABI,\n        this.l1Signer // Use signer for sending transactions\n      );\n      // Optional: Test RootChainManager connectivity (e.g., read chainId)\n      // const chainId = await this.rootChainManagerContractL1.chainID();\n      // logger.info(`RootChainManager L1 contract connection verified (Chain ID: ${chainId}).`);\n      logger.info('RootChainManager L1 contract instance created.');\n\n      logger.debug('RootChainManager contract details:', {\n        address: ROOT_CHAIN_MANAGER_ADDRESS_L1,\n        methods: this.rootChainManagerContractL1.interface.fragments\n          .map((f: { name?: string }) => (typeof f === 'object' && f.name ? f.name : 'unnamed'))\n          .join(', '),\n      });\n    } catch (error) {\n      logger.error('Failed during PolygonRpcService initialization:', error);\n      this.l1Provider = null;\n      this.l2Provider = null;\n      this.l1Signer = null;\n      this.stakeManagerContractL1 = null;\n      this.rootChainManagerContractL1 = null;\n      throw new Error('Failed to initialize PolygonRpcService components');\n    }\n  }\n\n  static async start(runtime: IAgentRuntime): Promise<PolygonRpcService> {\n    logger.info('Starting PolygonRpcService...');\n    const service = new PolygonRpcService(runtime);\n    await service.initializeProviders();\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime): Promise<void> {\n    logger.info('Stopping PolygonRpcService...');\n    const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (service) {\n      await service.stop();\n    }\n  }\n\n  async stop(): Promise<void> {\n    logger.info('PolygonRpcService instance stopped.');\n    this.l1Provider = null;\n    this.l2Provider = null;\n    this.l1Signer = null; // Clear signer\n    this.stakeManagerContractL1 = null; // Clear contract instance\n    this.rootChainManagerContractL1 = null; // Clear RCM instance\n  }\n\n  private getProvider(network: NetworkType): EthersProvider {\n    const provider = network === 'L1' ? this.l1Provider : this.l2Provider;\n    if (!provider) {\n      throw new Error(`Provider ${network} not initialized.`);\n    }\n    return provider;\n  }\n\n  // Get L1 Signer (ensure initialized)\n  private getL1Signer(): Signer {\n    if (!this.l1Signer) {\n      throw new Error('L1 Signer is not initialized.');\n    }\n    return this.l1Signer;\n  }\n\n  // Helper to get initialized StakeManager contract\n  private getStakeManagerContract(): Contract {\n    if (!this.stakeManagerContractL1) {\n      throw new Error('StakeManager L1 contract is not initialized.');\n    }\n    return this.stakeManagerContractL1;\n  }\n\n  // Helper to get initialized RootChainManager contract\n  private getRootChainManagerContract(): Contract {\n    if (!this.rootChainManagerContractL1) {\n      throw new Error('RootChainManager L1 contract is not initialized.');\n    }\n    return this.rootChainManagerContractL1;\n  }\n\n  // --- Helper: Get Signer-Aware ValidatorShare Contract ---\n  private async _getValidatorShareContract(validatorId: number): Promise<Contract> {\n    const stakeManager = this.getStakeManagerContract();\n    const signer = this.getL1Signer(); // Use L1 Signer\n\n    logger.debug(`Fetching ValidatorShare contract address for validator ${validatorId}...`);\n    const validatorShareAddress = await stakeManager.getValidatorContract(validatorId);\n\n    if (!validatorShareAddress || validatorShareAddress === ZeroAddress) {\n      logger.error(\n        `ValidatorShare contract address not found or zero for validator ID ${validatorId}.`\n      );\n      throw new Error(`Validator ${validatorId} does not have a valid ValidatorShare contract.`);\n    }\n    logger.debug(`Found ValidatorShare address: ${validatorShareAddress}`);\n\n    // Return instance connected to the L1 Signer\n    const validatorShareContract = new Contract(validatorShareAddress, ValidatorShareABI, signer);\n\n    // Attempt to verify contract interface by checking one of the required methods\n    try {\n      if (!validatorShareContract.interface.getFunction('buyVoucher(uint256,uint256)')) {\n        logger.warn(\n          `ValidatorShare contract at ${validatorShareAddress} may not have expected interface - buyVoucher(uint256,uint256) not found.`\n        );\n      }\n    } catch (error: unknown) {\n      // Log but don't throw - individual method calls will validate specific functions\n      logger.warn(\n        `Could not verify ValidatorShare contract interface: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n\n    return validatorShareContract;\n  }\n\n  // --- Core EVM Wrappers --- (remain the same)\n  async getBlockNumber(network: NetworkType): Promise<number> {\n    try {\n      const provider = this.getProvider(network);\n      return await provider.getBlockNumber();\n    } catch (error) {\n      logger.error(`Error in getBlockNumber (${network}):`, error);\n      throw error; // Re-throw for upstream handling\n    }\n  }\n\n  async getBalance(address: string, network: NetworkType): Promise<bigint> {\n    try {\n      const provider = this.getProvider(network);\n      return await provider.getBalance(address);\n    } catch (error) {\n      logger.error(`Error in getBalance (${network}) for ${address}:`, error);\n      throw error;\n    }\n  }\n\n  async getTransaction(txHash: string, network: NetworkType): Promise<TransactionResponse | null> {\n    try {\n      const provider = this.getProvider(network);\n      return await provider.getTransaction(txHash);\n    } catch (error) {\n      logger.error(`Error in getTransaction (${network}) for ${txHash}:`, error);\n      throw error;\n    }\n  }\n\n  async getTransactionReceipt(\n    txHash: string,\n    network: NetworkType\n  ): Promise<TransactionReceipt | null> {\n    try {\n      const provider = this.getProvider(network);\n      return await provider.getTransactionReceipt(txHash);\n    } catch (error) {\n      logger.error(`Error in getTransactionReceipt (${network}) for ${txHash}:`, error);\n      throw error;\n    }\n  }\n\n  async getBlock(blockIdentifier: string | number, network: NetworkType): Promise<Block | null> {\n    try {\n      const provider = this.getProvider(network);\n      return await provider.getBlock(blockIdentifier);\n    } catch (error) {\n      logger.error(`Error in getBlock (${network}) for ${blockIdentifier}:`, error);\n      throw error;\n    }\n  }\n\n  async call(transaction: TransactionRequest, network: NetworkType): Promise<string> {\n    try {\n      const provider = this.getProvider(network);\n      // Ensure blockTag is handled if needed, defaulting to latest\n      return await provider.call(transaction);\n    } catch (error) {\n      logger.error(`Error in call (${network}):`, error);\n      throw error;\n    }\n  }\n\n  async sendRawTransaction(signedTx: string, network: NetworkType): Promise<TransactionResponse> {\n    try {\n      const provider = this.getProvider(network);\n      // ethers v6 returns a TransactionResponse directly\n      return await provider.broadcastTransaction(signedTx);\n    } catch (error) {\n      logger.error(`Error in sendRawTransaction (${network}):`, error);\n      throw error;\n    }\n  }\n\n  // --- Polygon L2 Specific Read Functions --- (Existing methods remain unchanged)\n  async getCurrentBlockNumber(): Promise<number> {\n    logger.debug('Getting current L2 block number...');\n    return this.getBlockNumber('L2');\n  }\n\n  async getBlockDetails(identifier: string | number): Promise<Block | null> {\n    logger.debug(`Getting L2 block details for: ${identifier}`);\n    return this.getBlock(identifier, 'L2');\n  }\n\n  /**\n   * Gets transaction details and receipt for a given hash on Polygon (L2).\n   * @param txHash Transaction hash.\n   * @returns An object containing the transaction response and receipt, or null if not found.\n   */\n  async getTransactionDetails(txHash: string): Promise<{\n    transaction: TransactionResponse | null;\n    receipt: TransactionReceipt | null;\n  } | null> {\n    logger.debug(`Getting L2 transaction details for: ${txHash}`);\n    try {\n      const [transaction, receipt] = await Promise.all([\n        this.getTransaction(txHash, 'L2'),\n        this.getTransactionReceipt(txHash, 'L2'),\n      ]);\n\n      if (!transaction && !receipt) {\n        return null; // Neither found\n      }\n      return { transaction, receipt };\n    } catch (error) {\n      // Errors are logged in underlying wrappers, re-throw if needed\n      logger.error(`Failed to get full transaction details for ${txHash} on L2.`);\n      throw error;\n    }\n  }\n\n  async getNativeBalance(address: string): Promise<bigint> {\n    logger.debug(`Getting native L2 balance for: ${address}`);\n    return this.getBalance(address, 'L2');\n  }\n\n  async getErc20Balance(tokenAddress: string, accountAddress: string): Promise<bigint> {\n    logger.debug(\n      `Getting ERC20 balance for token ${tokenAddress} on account ${accountAddress} on L2...`\n    );\n    try {\n      // Use getProvider to ensure service is initialized\n      const l2Provider = this.getProvider('L2');\n      const contract = new Contract(tokenAddress, Erc20ABI, l2Provider);\n      const balance: BigNumberish = await contract.balanceOf(accountAddress);\n      // Ensure balance is returned as bigint\n      return BigInt(balance.toString());\n    } catch (error) {\n      logger.error(`Error fetching ERC20 balance for ${tokenAddress} / ${accountAddress}:`, error);\n      // Handle specific errors like invalid address or contract not found if possible\n      throw error;\n    }\n  }\n\n  // --- Staking Read Operations (L1) ---\n\n  /**\n   * Fetches detailed information about a specific validator from the L1 StakeManager.\n   * @param validatorId The ID of the validator.\n   * @returns A promise resolving to ValidatorInfo or null if not found.\n   */\n  async getValidatorInfo(validatorId: number): Promise<ValidatorInfo | null> {\n    logger.debug(`Getting L1 validator info for ID: ${validatorId}`);\n    try {\n      const stakeManager = this.getStakeManagerContract();\n\n      // We need to use multiple contract calls to build the validator info\n      // First, check if the validator exists by trying to get their stake\n      try {\n        // Check if we can get the stake - this will throw if validator doesn't exist\n        await stakeManager.validatorStake(validatorId);\n      } catch (e: unknown) {\n        logger.warn(\n          `Validator ID ${validatorId} not found or inactive. ${e instanceof Error ? e.message : String(e)}`\n        );\n        return null;\n      }\n\n      // Gather basic information using separate calls\n      const [\n        stake,\n        validatorShareAddress,\n        // Add other relevant calls as needed\n      ] = await Promise.all([\n        stakeManager.validatorStake(validatorId),\n        stakeManager.getValidatorContract(validatorId),\n        // Add other contract methods here\n      ]);\n\n      // Calculate total stake (validator's own stake + delegated amount)\n      const validatorStake = BigInt(stake.toString());\n      let totalStake = validatorStake;\n      try {\n        const delegated = await stakeManager.delegatedAmount(validatorId);\n        totalStake = totalStake + BigInt(delegated.toString());\n      } catch (e: unknown) {\n        logger.warn(\n          `Could not get delegated amount for validator ${validatorId}: ${e instanceof Error ? e.message : String(e)}`\n        );\n      }\n\n      // Determine status - since we don't have direct status info, assume Active\n      // if they have a contract address and non-zero stake\n      let status = ValidatorStatus.Inactive;\n      if (validatorShareAddress && validatorShareAddress !== ZeroAddress && totalStake > 0n) {\n        status = ValidatorStatus.Active;\n      }\n\n      // Try to get commission rate from ValidatorShare contract\n      let commissionRate = 0;\n      const lastRewardUpdateEpoch = 0n;\n      let signerAddress = '';\n\n      if (validatorShareAddress && validatorShareAddress !== ZeroAddress) {\n        try {\n          const validatorShareContract = new Contract(\n            validatorShareAddress,\n            ValidatorShareABI,\n            this.getProvider('L1')\n          );\n\n          // Try to get commission rate from validator share contract\n          if (typeof validatorShareContract.commissionRate === 'function') {\n            try {\n              const commissionRateResult = await validatorShareContract.commissionRate();\n              commissionRate = Number(commissionRateResult) / 10000; // Convert from basis points (100 = 1%)\n            } catch (e: unknown) {\n              logger.debug(\n                `Commission rate not available for validator ${validatorId}: ${e instanceof Error ? e.message : String(e)}`\n              );\n            }\n          }\n\n          // Try to get validator address/signer\n          if (typeof validatorShareContract.owner === 'function') {\n            try {\n              signerAddress = await validatorShareContract.owner();\n            } catch (e: unknown) {\n              logger.debug(\n                `Owner address not available for validator ${validatorId}: ${e instanceof Error ? e.message : String(e)}`\n              );\n            }\n          }\n        } catch (e: unknown) {\n          logger.warn(\n            `Error interacting with ValidatorShare contract: ${e instanceof Error ? e.message : String(e)}`\n          );\n        }\n      }\n\n      // Build the validator info object with the data we were able to retrieve\n      const info: ValidatorInfo = {\n        status: status,\n        totalStake: totalStake,\n        commissionRate: commissionRate,\n        signerAddress: signerAddress || ZeroAddress,\n        activationEpoch: 0n, // We don't have this info directly\n        deactivationEpoch: 0n, // We don't have this info directly\n        jailEndEpoch: 0n, // We don't have this info directly\n        contractAddress: validatorShareAddress || ZeroAddress,\n        lastRewardUpdateEpoch: lastRewardUpdateEpoch,\n      };\n\n      return info;\n    } catch (error) {\n      logger.error(\n        `Error fetching validator info for ID ${validatorId} from L1 StakeManager:`,\n        error\n      );\n      // Handle specific errors (e.g., contract revert) if possible\n      throw error; // Re-throw for upstream handling\n    }\n  }\n\n  /**\n   * Fetches staking details for a specific delegator address related to a specific validator.\n   * @param validatorId The ID of the validator.\n   * @param delegatorAddress The address of the delegator.\n   * @returns A promise resolving to DelegatorInfo or null if validator/delegator relationship not found.\n   */\n  async getDelegatorInfo(\n    validatorId: number,\n    delegatorAddress: string\n  ): Promise<DelegatorInfo | null> {\n    logger.debug(\n      `Getting L1 delegator info for validator ${validatorId} and delegator ${delegatorAddress}`\n    );\n    try {\n      const stakeManager = this.getStakeManagerContract();\n      const l1Provider = this.getProvider('L1');\n\n      // Step 1: Get ValidatorShare contract address\n      const validatorShareAddress = await stakeManager.getValidatorContract(validatorId);\n\n      if (!validatorShareAddress || validatorShareAddress === ZeroAddress) {\n        logger.warn(`ValidatorShare contract address not found for validator ID ${validatorId}.`);\n        return null;\n      }\n\n      // Step 2: Instantiate ValidatorShare contract\n      const validatorShareContract = new Contract(\n        validatorShareAddress,\n        ValidatorShareABI,\n        l1Provider\n      );\n\n      // Step 3 & 4: Get delegated amount and pending rewards\n      // Verify exact function names from ABI ('getTotalStake', 'getLiquidRewards' or 'pendingRewards')\n      const [delegatedAmountResult, pendingRewardsResult] = await Promise.all([\n        validatorShareContract.getTotalStake(delegatorAddress), // Verify name\n        validatorShareContract.getLiquidRewards(delegatorAddress), // Verify name (often 'getLiquidRewards')\n      ]);\n\n      const info: DelegatorInfo = {\n        delegatedAmount: BigInt(delegatedAmountResult.toString()),\n        pendingRewards: BigInt(pendingRewardsResult.toString()),\n      };\n\n      // Optional: Check if delegatedAmount is zero to consider if delegator exists for this validator\n      // if (info.delegatedAmount === 0n) { return null; }\n\n      return info;\n    } catch (error) {\n      logger.error(\n        `Error fetching delegator info for V:${validatorId}/D:${delegatorAddress} from L1:`,\n        error\n      );\n      // Handle specific errors (e.g., contract revert if delegator never staked)\n      // Often reverts happen if delegator has no stake - might return null instead of throwing\n      if (\n        error instanceof Error &&\n        (error.message.includes('delegator never staked') ||\n          ('code' in error && (error as any).code === 'CALL_EXCEPTION'))\n      ) {\n        // Example error check\n        logger.warn(\n          `Delegator ${delegatorAddress} likely has no stake with validator ${validatorId}.`\n        );\n        return null;\n      }\n      throw error; // Re-throw for upstream handling\n    }\n  }\n\n  // --- L1 Staking Write Operations ---\n\n  /**\n   * Delegates MATIC to a validator on L1.\n   * @param validatorId The ID of the validator.\n   * @param amountWei Amount of MATIC/POL to delegate in Wei.\n   * @returns Transaction hash of the delegation transaction.\n   */\n  async delegate(validatorId: number, amountWei: bigint): Promise<string> {\n    logger.info(\n      `Initiating delegation of ${ethers.formatEther(amountWei)} MATIC to validator ${validatorId} on L1...`\n    );\n    if (amountWei <= 0n) {\n      throw new Error('Delegation amount must be greater than zero.');\n    }\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n\n    try {\n      // Get the ValidatorShare contract for this validator\n      const validatorShareContract = await this._getValidatorShareContract(validatorId);\n\n      // Validate that the required function exists\n      if (!validatorShareContract.interface.getFunction('buyVoucher(uint256,uint256)')) {\n        throw new Error('ValidatorShare contract does not expose buyVoucher(uint256,uint256)');\n      }\n\n      // Get MATIC token contract and approve spending\n      const maticToken = this.getMaticToken();\n      const signerAddress = await signer.getAddress();\n\n      // Check allowance and approve if needed\n      logger.debug(\n        `Checking MATIC token allowance for validator share contract ${validatorShareContract.target}...`\n      );\n      const allowance = await maticToken.allowance(signerAddress, validatorShareContract.target);\n\n      if (allowance < amountWei) {\n        logger.info(`Approving ${ethers.formatEther(amountWei)} MATIC for delegation...`);\n        const approveTx = await maticToken.approve(validatorShareContract.target, amountWei);\n        logger.info(\n          `MATIC approval transaction sent: ${approveTx.hash}. Waiting for confirmation...`\n        );\n        await approveTx.wait(1); // Wait for 1 confirmation\n        logger.info('MATIC approval confirmed. Proceeding with delegation.');\n      } else {\n        logger.info(\n          `Existing allowance of ${ethers.formatEther(allowance)} MATIC is sufficient. Skipping approval.`\n        );\n      }\n\n      // Prepare transaction data for buyVoucher WITHOUT fee details\n      // The buyVoucher function takes (amount, minSharesToMint)\n      // For minSharesToMint, we'll use 0 to accept whatever the contract calculates\n      const txData = await validatorShareContract.buyVoucher.populateTransaction(amountWei, 0);\n\n      // Estimate gas BEFORE adding fee details\n      // Important: DO NOT include value in gas estimation - this is an ERC20 transfer\n      const gasLimit = await signer.estimateGas({\n        ...txData,\n      });\n      const gasLimitBuffered = (gasLimit * 120n) / 100n; // Add 20% buffer\n\n      // AFTER estimating gas, get fee details\n      const { maxFeePerGas, maxPriorityFeePerGas } = await this._getL1FeeDetails();\n\n      // ------------------------------------------------------------------\n      // Dynamic balance guard  replaces any hard-coded \"need 0.1 ETH\" logic\n      // ------------------------------------------------------------------\n      const walletBalance = await l1Provider.getBalance(signerAddress);\n\n      // Calculate estimated fee plus safety margin\n      const estFee = gasLimitBuffered * maxFeePerGas; // wei\n      const safety = ethers.parseUnits('0.002', 'ether'); // 0.002 ETH  10 %\n\n      if (walletBalance < estFee + safety) {\n        throw new Error(\n          `Insufficient ETH: you have ${ethers.formatEther(walletBalance)} but need about ${ethers.formatEther(estFee + safety)} for gas.`\n        );\n      }\n\n      // Construct Full Transaction\n      const tx: TransactionRequest = {\n        ...txData,\n        // Do not set value - this is an ERC20 transfer, not ETH\n        gasLimit: gasLimitBuffered,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId, // Ensure correct chain ID\n      };\n\n      // Get current nonce before signing\n      const nonce = await signer.getNonce();\n      tx.nonce = nonce;\n\n      // Add debugging info\n      logger.debug('Transaction details:', {\n        to: tx.to,\n        gasLimit: tx.gasLimit?.toString(),\n        maxFeePerGas: tx.maxFeePerGas?.toString(),\n        maxPriorityFeePerGas: tx.maxPriorityFeePerGas?.toString(),\n        value: tx.value?.toString() || 'undefined (correct - no ETH value should be sent)',\n      });\n\n      // Sign Transaction\n      logger.debug('Signing delegation transaction...');\n      const signedTx = await signer.signTransaction(tx);\n\n      // Broadcast Transaction\n      logger.info(`Broadcasting L1 delegation transaction for validator ${validatorId}...`);\n      const txResponse = await this.sendRawTransaction(signedTx, 'L1');\n      logger.info(`Delegation transaction sent: ${txResponse.hash}`);\n\n      // Return Hash\n      return txResponse.hash;\n    } catch (error: unknown) {\n      logger.error(`Delegation to validator ${validatorId} failed:`, error);\n      // Add more specific error handling (insufficient funds, etc.)\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Delegation failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Gets the MATIC token contract on Ethereum L1\n   * @returns The MATIC token contract connected to the signer\n   */\n  private getMaticToken(): Contract {\n    // Ethereum Mainnet MATIC token address\n    const MATIC_TOKEN_ADDRESS = '0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0';\n    const signer = this.getL1Signer();\n\n    return new Contract(MATIC_TOKEN_ADDRESS, Erc20ABI, signer);\n  }\n\n  /**\n   * Initiates undelegation (unbonding) of shares from a validator on L1.\n   * @param validatorId The ID of the validator.\n   * @param sharesAmountWei Amount of Validator Shares to undelegate (in Wei).\n   * @returns Transaction hash of the undelegation transaction.\n   */\n  async undelegate(validatorId: number, sharesAmountWei: bigint): Promise<string> {\n    logger.info(\n      `Initiating undelegation of ${sharesAmountWei} shares from validator ${validatorId} on L1...`\n    );\n    if (sharesAmountWei <= 0n) {\n      throw new Error('Undelegation shares amount must be greater than zero.');\n    }\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n    const contract = await this._getValidatorShareContract(validatorId);\n\n    try {\n      // Validate that the required function exists\n      if (!contract.interface.getFunction('sellVoucher(uint256,uint256)')) {\n        throw new Error('ValidatorShare contract does not expose sellVoucher(uint256,uint256)');\n      }\n\n      // 1. Prepare Transaction Data (Verify function name: sellVoucher or similar)\n      // Using sellVoucher(uint256 _amount, uint256 _minClaimAmount)\n      const txData = await contract.sellVoucher.populateTransaction(sharesAmountWei, 0n); // _minClaimAmount = 0\n\n      // 2. Estimate Gas Limit BEFORE fee details\n      const gasLimit = await signer.estimateGas({ ...txData });\n      const gasLimitBuffered = (gasLimit * 120n) / 100n;\n\n      // 3. Get Gas Estimates AFTER estimating gas\n      const { maxFeePerGas, maxPriorityFeePerGas } = await this._getL1FeeDetails();\n\n      // 4. Construct Full Transaction\n      const tx: TransactionRequest = {\n        ...txData,\n        // No value field for undelegate\n        gasLimit: gasLimitBuffered,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId,\n      };\n\n      // 5. Sign Transaction\n      logger.debug('Signing undelegation transaction...', tx);\n      const signedTx = await signer.signTransaction(tx);\n\n      // 6. Broadcast Transaction\n      logger.info(`Broadcasting L1 undelegation transaction for validator ${validatorId}...`);\n      const txResponse = await this.sendRawTransaction(signedTx, 'L1');\n      logger.info(`Undelegation transaction sent: ${txResponse.hash}`);\n\n      // 7. Return Hash\n      return txResponse.hash;\n    } catch (error: unknown) {\n      logger.error(`Undelegation from validator ${validatorId} failed:`, error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Undelegation failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Withdraws pending rewards from a specific validator on L1.\n   * @param validatorId The ID of the validator.\n   * @returns Transaction hash of the reward withdrawal transaction.\n   */\n  async withdrawRewards(validatorId: number): Promise<string> {\n    logger.info(`Initiating reward withdrawal from validator ${validatorId} on L1...`);\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n    const contract = await this._getValidatorShareContract(validatorId);\n\n    try {\n      // Validate that the required function exists\n      if (!contract.interface.getFunction('withdrawRewards()')) {\n        throw new Error('ValidatorShare contract does not expose withdrawRewards()');\n      }\n\n      // 1. Prepare Transaction Data (Verify function name: withdrawRewards)\n      const txData = await contract.withdrawRewards.populateTransaction();\n\n      // 2. Estimate Gas Limit BEFORE fee details\n      const gasLimit = await signer.estimateGas({ ...txData });\n      const gasLimitBuffered = (gasLimit * 120n) / 100n;\n\n      // 3. Get Gas Estimates AFTER estimating gas\n      const { maxFeePerGas, maxPriorityFeePerGas } = await this._getL1FeeDetails();\n\n      // 4. Construct Full Transaction\n      const tx: TransactionRequest = {\n        ...txData,\n        // No value field for withdraw\n        gasLimit: gasLimitBuffered,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId,\n      };\n\n      // 5. Sign Transaction\n      logger.debug('Signing reward withdrawal transaction...', tx);\n      const signedTx = await signer.signTransaction(tx);\n\n      // 6. Broadcast Transaction\n      logger.info(`Broadcasting L1 reward withdrawal transaction for validator ${validatorId}...`);\n      const txResponse = await this.sendRawTransaction(signedTx, 'L1');\n      logger.info(`Reward withdrawal transaction sent: ${txResponse.hash}`);\n\n      // 7. Return Hash\n      return txResponse.hash;\n    } catch (error: unknown) {\n      logger.error(`Reward withdrawal from validator ${validatorId} failed:`, error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Reward withdrawal failed: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Convenience method to withdraw rewards and immediately restake them to the same validator.\n   * @param validatorId The ID of the validator.\n   * @returns Transaction hash of the *delegation* transaction, or null if no rewards to restake.\n   */\n  async restakeRewards(validatorId: number): Promise<string | null> {\n    logger.info(`Initiating restake for validator ${validatorId} on L1...`);\n    const signer = this.getL1Signer();\n    const delegatorAddress = await signer.getAddress();\n    const l1Provider = this.getProvider('L1');\n    const validatorShareContract = await this._getValidatorShareContract(validatorId);\n\n    try {\n      // Validate that the required functions exist\n      if (!validatorShareContract.interface.getFunction('getLiquidRewards(address)')) {\n        throw new Error('ValidatorShare contract does not expose getLiquidRewards(address)');\n      }\n      if (!validatorShareContract.interface.getFunction('withdrawRewards()')) {\n        throw new Error('ValidatorShare contract does not expose withdrawRewards()');\n      }\n\n      // 1. Get pending rewards *before* withdrawing\n      const delegatorInfo = await this.getDelegatorInfo(validatorId, delegatorAddress);\n      const rewardsToRestake = delegatorInfo?.pendingRewards;\n\n      if (!rewardsToRestake || rewardsToRestake <= 0n) {\n        logger.warn(\n          `No pending rewards found for ${delegatorAddress} on validator ${validatorId}. Nothing to restake.`\n        );\n        return null;\n      }\n      logger.info(`Found ${ethers.formatEther(rewardsToRestake)} MATIC rewards to restake.`);\n\n      // 2. Withdraw Rewards\n      const withdrawTxHash = await this.withdrawRewards(validatorId);\n      logger.info(`Withdrawal tx sent (${withdrawTxHash}). Waiting for confirmation...`);\n\n      // 3. Wait for Confirmation (Important!)\n      const receipt = await l1Provider.waitForTransaction(withdrawTxHash, 1, 120000); // Wait 1 conf, timeout 2min\n      if (!receipt || receipt.status !== 1) {\n        logger.error(\n          `Withdrawal transaction (${withdrawTxHash}) failed or timed out. Status: ${receipt?.status}`\n        );\n        throw new Error(`Reward withdrawal transaction failed (Hash: ${withdrawTxHash})`);\n      }\n      logger.info('Withdrawal transaction confirmed.');\n\n      // 4. Delegate the withdrawn amount (which equals the previously fetched pendingRewards)\n      logger.info(\n        `Proceeding to delegate ${ethers.formatEther(rewardsToRestake)} MATIC rewards...`\n      );\n      const delegateTxHash = await this.delegate(validatorId, rewardsToRestake);\n\n      return delegateTxHash; // Return the hash of the second (delegate) transaction\n    } catch (error: unknown) {\n      logger.error(`Restake operation for validator ${validatorId} failed:`, error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Restake failed: ${errorMessage}`);\n    }\n  }\n\n  // --- L1 -> L2 Bridge Deposit ---\n\n  /**\n   * Bridges an ERC20 token (including POL) from Ethereum L1 to Polygon L2.\n   * Handles approval if necessary.\n   * @param tokenAddressL1 Address of the ERC20 token contract on L1.\n   * @param amountWei Amount of the token to bridge in Wei.\n   * @param recipientAddressL2 Optional address to receive tokens on L2, defaults to sender.\n   * @returns Transaction hash of the final deposit transaction.\n   */\n  async bridgeDeposit(\n    tokenAddressL1: string,\n    amountWei: bigint,\n    recipientAddressL2?: string\n  ): Promise<string> {\n    logger.info(\n      `Initiating L1->L2 bridge deposit of ${ethers.formatUnits(amountWei)} units for token ${tokenAddressL1}...`\n    );\n    if (amountWei <= 0n) {\n      throw new Error('Bridge deposit amount must be greater than zero.');\n    }\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n    const rootChainManager = this.getRootChainManagerContract();\n    const userAddress = recipientAddressL2 || (await signer.getAddress()); // Default to sender if no recipient\n\n    try {\n      // 1. Approve RootChainManager to spend the token\n      // This helper handles checking allowance and sending tx only if needed\n      await this._approveErc20IfNeeded(tokenAddressL1, amountWei, ROOT_CHAIN_MANAGER_ADDRESS_L1);\n      // Approval (if sent) is confirmed within the helper\n\n      // 2. Prepare and send the depositFor transaction\n      const txDepositData = await rootChainManager.depositFor.populateTransaction(\n        userAddress,\n        tokenAddressL1,\n        amountWei\n      );\n\n      const { maxFeePerGas, maxPriorityFeePerGas } = await this._getL1FeeDetails();\n\n      const gasLimitDeposit = await signer.estimateGas({\n        ...txDepositData,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId,\n      });\n\n      // 3. Construct Full Transaction\n      const tx: TransactionRequest = {\n        ...txDepositData,\n        gasLimit: gasLimitDeposit,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId,\n      };\n\n      // 4. Sign Transaction\n      logger.debug('Signing depositFor transaction...', tx);\n      const signedTx = await signer.signTransaction(tx);\n\n      // 5. Broadcast Transaction\n      logger.info(`Broadcasting L1 depositFor transaction for token ${tokenAddressL1}...`);\n      const txResponse = await this.sendRawTransaction(signedTx, 'L1');\n      logger.info(`Bridge deposit transaction sent: ${txResponse.hash}`);\n\n      // 6. Return Hash of the deposit transaction\n      return txResponse.hash;\n    } catch (error: unknown) {\n      logger.error(`Bridge deposit for token ${tokenAddressL1} failed:`, error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Bridge deposit failed: ${errorMessage}`);\n    }\n  }\n\n  // --- Helper: Approve ERC20 spending if needed ---\n  private async _approveErc20IfNeeded(\n    tokenAddressL1: string,\n    amountWei: bigint,\n    spenderAddress: string\n  ): Promise<string | null> {\n    // Returns approve tx hash if sent, null otherwise\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n    const ownerAddress = await signer.getAddress();\n    const tokenContract = new Contract(tokenAddressL1, Erc20ABI, signer);\n\n    logger.debug(\n      `Checking allowance for ${ownerAddress} to spend ${tokenAddressL1} via ${spenderAddress}`\n    );\n    const currentAllowance: bigint = BigInt(\n      (await tokenContract.allowance(ownerAddress, spenderAddress)).toString()\n    );\n\n    if (currentAllowance >= amountWei) {\n      logger.info(\n        `Sufficient allowance (${ethers.formatUnits(currentAllowance)} tokens) already exists for ${tokenAddressL1}. Skipping approval.`\n      );\n      return null; // No approval needed\n    }\n\n    if (currentAllowance > 0n) {\n      // Reset allowance to 0 before setting new allowance - common mitigation for some ERC20 bugs\n      logger.warn(\n        `Existing allowance (${ethers.formatUnits(currentAllowance)}) is less than required. Resetting to 0 before approving new amount.`\n      );\n      try {\n        const resetTxHash = await this._sendApproveTx(tokenContract, spenderAddress, 0n);\n        await l1Provider.waitForTransaction(resetTxHash, 1, 120000); // Wait for reset confirmation\n      } catch (error) {\n        logger.error('Failed to reset ERC20 allowance to 0:', error);\n        throw new Error('Failed to reset existing allowance before approving.');\n      }\n    }\n\n    logger.info(\n      `Approving ${spenderAddress} to spend ${ethers.formatUnits(amountWei)} of ${tokenAddressL1}...`\n    );\n    // Approve slightly more or MaxUint256 for simplicity, depending on strategy\n    const approveAmount = MaxUint256; // Approve maximum often simplest\n    const approveTxHash = await this._sendApproveTx(tokenContract, spenderAddress, approveAmount);\n\n    logger.info(`Approve transaction sent (${approveTxHash}). Waiting for confirmation...`);\n    const receipt = await l1Provider.waitForTransaction(approveTxHash, 1, 120000); // Wait 1 conf, timeout 2min\n\n    if (!receipt || receipt.status !== 1) {\n      logger.error(\n        `Approve transaction (${approveTxHash}) failed or timed out. Status: ${receipt?.status}`\n      );\n      throw new Error(`ERC20 approval transaction failed (Hash: ${approveTxHash})`);\n    }\n\n    logger.info(`Approval confirmed for ${tokenAddressL1}.`);\n    return approveTxHash;\n  }\n\n  // Internal helper to construct and send an approve transaction\n  private async _sendApproveTx(\n    tokenContract: Contract,\n    spender: string,\n    amount: bigint\n  ): Promise<string> {\n    const signer = this.getL1Signer();\n    const l1Provider = this.getProvider('L1');\n\n    try {\n      const txData = await tokenContract.approve.populateTransaction(spender, amount);\n\n      const { maxFeePerGas, maxPriorityFeePerGas } = await this._getL1FeeDetails();\n\n      const gasLimit = await signer.estimateGas({ ...txData });\n      const gasLimitBuffered = (gasLimit * 150n) / 100n; // Increase buffer for approve? 50%\n\n      const tx: TransactionRequest = {\n        ...txData,\n        gasLimit: gasLimitBuffered,\n        maxFeePerGas: maxFeePerGas,\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        chainId: (await l1Provider.getNetwork()).chainId,\n      };\n\n      // Get current nonce before signing\n      const nonce = await signer.getNonce();\n      tx.nonce = nonce;\n\n      logger.debug('Signing approve transaction...', tx);\n      const signedTx = await signer.signTransaction(tx);\n      logger.info(`Broadcasting L1 approve transaction for token ${tokenContract.target}...`);\n      const txResponse = await this.sendRawTransaction(signedTx, 'L1');\n      return txResponse.hash;\n    } catch (error: unknown) {\n      logger.error(`ERC20 approve transaction failed for token ${tokenContract.target}:`, error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      throw new Error(`Approval failed: ${errorMessage}`);\n    }\n  }\n\n  // Helper for L1 Fee Details\n  private async _getL1FeeDetails(): Promise<{\n    maxFeePerGas: bigint;\n    maxPriorityFeePerGas: bigint;\n  }> {\n    if (!this.l1Provider) throw new Error('L1 provider not initialized for fee data.');\n    // Runtime check is inside getGasPriceEstimates, but good to be explicit if we use it directly often\n    if (!this.runtime) throw new Error('Runtime not available for GasService access.');\n\n    try {\n      logger.debug('Fetching gas prices from GasService...');\n      const gasServiceEstimates = await getGasPriceEstimates(this.runtime);\n      // Check if GasService provided sufficient EIP-1559 data\n      if (\n        gasServiceEstimates?.estimatedBaseFee &&\n        gasServiceEstimates?.average?.maxPriorityFeePerGas\n      ) {\n        const maxPriorityFeePerGas = gasServiceEstimates.average.maxPriorityFeePerGas;\n        const maxFeePerGas = gasServiceEstimates.estimatedBaseFee + maxPriorityFeePerGas;\n\n        // Log the values to help diagnose issues\n        logger.debug('Gas price details from GasService:', {\n          baseFeeWei: gasServiceEstimates.estimatedBaseFee?.toString(),\n          baseFeeGwei: ethers.formatUnits(gasServiceEstimates.estimatedBaseFee || 0n, 'gwei'),\n          priorityFeeWei: maxPriorityFeePerGas.toString(),\n          priorityFeeGwei: ethers.formatUnits(maxPriorityFeePerGas, 'gwei'),\n          totalFeeWei: maxFeePerGas.toString(),\n          totalFeeGwei: ethers.formatUnits(maxFeePerGas, 'gwei'),\n        });\n\n        // Compare numbers, not strings, and warn only above ~500 gwei\n        if (Number(ethers.formatUnits(maxFeePerGas, 'gwei')) > 500) {\n          logger.warn(\n            `Unusually high gas price (${ethers.formatUnits(maxFeePerGas, 'gwei')} gwei)  double-check the fee source or unit conversion.`\n          );\n        }\n\n        logger.debug('Using L1 fee details from GasService.');\n        return { maxFeePerGas, maxPriorityFeePerGas };\n      }\n    } catch (gsError: unknown) {\n      logger.warn(\n        `GasService call failed or returned insufficient data: ${gsError instanceof Error ? gsError.message : String(gsError)}. Falling back to l1Provider.getFeeData().`\n      );\n    }\n\n    // Fallback to l1Provider.getFeeData()\n    logger.debug('Falling back to l1Provider.getFeeData() for L1 fee details.');\n    const feeData = await this.l1Provider.getFeeData();\n    let maxFeePerGas = feeData.maxFeePerGas;\n    let maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n\n    if (maxFeePerGas === null || maxPriorityFeePerGas === null) {\n      if (feeData.gasPrice !== null) {\n        logger.warn(\n          'L1 fee data: maxFeePerGas or maxPriorityFeePerGas is null, using gasPrice as fallback (legacy transaction type).'\n        );\n        // For legacy tx, or if EIP-1559 not fully supported by provider via getFeeData, use gasPrice.\n        // maxFeePerGas and maxPriorityFeePerGas will effectively be the same as gasPrice.\n        maxFeePerGas = feeData.gasPrice;\n        maxPriorityFeePerGas = feeData.gasPrice;\n      } else {\n        throw new Error(\n          'Unable to obtain L1 fee data: getFeeData() returned all null for EIP-1559 fields and gasPrice.'\n        );\n      }\n    }\n\n    if (maxFeePerGas === null || maxPriorityFeePerGas === null) {\n      // This should ideally not be reached if gasPrice fallback worked.\n      throw new Error('Unable to determine L1 fee details even after fallback attempts.');\n    }\n\n    // Log the values from provider.getFeeData() as well\n    logger.debug('Gas price details from provider.getFeeData():', {\n      maxFeePerGasWei: maxFeePerGas.toString(),\n      maxFeePerGasGwei: ethers.formatUnits(maxFeePerGas, 'gwei'),\n      maxPriorityFeePerGasWei: maxPriorityFeePerGas.toString(),\n      maxPriorityFeePerGasGwei: ethers.formatUnits(maxPriorityFeePerGas, 'gwei'),\n    });\n\n    // Compare numbers, not strings, and warn only above ~500 gwei\n    if (Number(ethers.formatUnits(maxFeePerGas, 'gwei')) > 500) {\n      logger.warn(\n        `Unusually high gas price from provider (${ethers.formatUnits(maxFeePerGas, 'gwei')} gwei)  double-check the fee source or unit conversion.`\n      );\n    }\n\n    return { maxFeePerGas, maxPriorityFeePerGas };\n  }\n\n  // --- L2 Checkpoint Status Check (L1) ---\n\n  /**\n   * Fetches the last L2 block number included in a checkpoint on L1.\n   * @returns A promise resolving to the last checkpointed L2 block number as a bigint.\n   */\n  async getLastCheckpointedL2Block(): Promise<bigint> {\n    logger.debug(\n      'Getting last checkpointed L2 block number from L1 RootChainManager/CheckpointManager...'\n    );\n    try {\n      // Get RootChainManager contract\n      const rootChainManager = this.getRootChainManagerContract();\n      if (!this.l1Provider) {\n        throw new Error('L1 provider not initialized for CheckpointManager interaction.');\n      }\n\n      // Get CheckpointManager address\n      logger.debug('Retrieving CheckpointManager address from RootChainManager...');\n      let checkpointManagerAddr: string;\n      try {\n        checkpointManagerAddr = await rootChainManager.checkpointManagerAddress();\n        logger.debug(`CheckpointManager address retrieved: ${checkpointManagerAddr}`);\n      } catch (error: unknown) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        logger.error(`Failed to get checkpointManagerAddress from RootChainManager: ${errMsg}`);\n        logger.debug('RootChainManager contract details:', {\n          address: ROOT_CHAIN_MANAGER_ADDRESS_L1,\n          methods: rootChainManager.interface.fragments\n            .map((f: { name?: string }) => (typeof f === 'object' && f.name ? f.name : 'unnamed'))\n            .join(', '),\n        });\n        throw new Error(`Failed to get CheckpointManager address from RootChainManager: ${errMsg}`);\n      }\n\n      if (!checkpointManagerAddr || checkpointManagerAddr === ZeroAddress) {\n        logger.error('Invalid CheckpointManager address:', checkpointManagerAddr);\n        throw new Error(\n          'CheckpointManager address not found or is zero address from RootChainManager.'\n        );\n      }\n\n      // Create CheckpointManager contract instance\n      logger.debug(\n        `Creating CheckpointManager contract instance for address: ${checkpointManagerAddr}...`\n      );\n      const checkpointManager = new Contract(\n        checkpointManagerAddr,\n        CheckpointManagerABI,\n        this.l1Provider\n      );\n\n      // Test if contract exists at the address by calling a simple view function\n      try {\n        // Try to call a simple method first to check if contract exists and responds\n        await this.l1Provider.getCode(checkpointManagerAddr);\n        logger.debug('Contract code exists at CheckpointManager address');\n      } catch (error: unknown) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        logger.error(\n          `Failed to verify CheckpointManager contract at ${checkpointManagerAddr}: ${errMsg}`\n        );\n        throw new Error(\n          `CheckpointManager contract not found at ${checkpointManagerAddr}: ${errMsg}`\n        );\n      }\n\n      // Get current header block number\n      logger.debug('Retrieving currentHeaderBlock from CheckpointManager...');\n      let lastHeaderNum: bigint;\n      try {\n        lastHeaderNum = await checkpointManager.currentHeaderBlock();\n        logger.debug(`Last header block number: ${lastHeaderNum}`);\n      } catch (error: unknown) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        logger.error(`Failed to retrieve currentHeaderBlock from CheckpointManager: ${errMsg}`);\n        logger.debug('CheckpointManager contract details:', {\n          address: checkpointManagerAddr,\n          methods: checkpointManager.interface.fragments\n            .map((f: { name?: string }) => (typeof f === 'object' && f.name ? f.name : 'unnamed'))\n            .join(', '),\n        });\n        throw new Error(`Failed to retrieve currentHeaderBlock from CheckpointManager: ${errMsg}`);\n      }\n\n      if (lastHeaderNum === undefined || lastHeaderNum === null) {\n        logger.error('Invalid currentHeaderBlock value:', lastHeaderNum);\n        throw new Error('Failed to retrieve currentHeaderBlock from CheckpointManager.');\n      }\n\n      // Get header block details\n      logger.debug(`Retrieving header block details for block ${lastHeaderNum}...`);\n      let headerBlockDetails: Record<string, unknown>;\n      try {\n        headerBlockDetails = await checkpointManager.headerBlocks(lastHeaderNum);\n        logger.debug(\n          'HeaderBlock details retrieved:',\n          JSON.stringify(headerBlockDetails, (_, v) => (typeof v === 'bigint' ? v.toString() : v))\n        );\n      } catch (error: unknown) {\n        const errMsg = error instanceof Error ? error.message : String(error);\n        logger.error(\n          `Failed to retrieve headerBlocks(${lastHeaderNum}) from CheckpointManager: ${errMsg}`\n        );\n        throw new Error(\n          `Failed to retrieve headerBlock details for block ${lastHeaderNum}: ${errMsg}`\n        );\n      }\n\n      if (!headerBlockDetails) {\n        logger.error('headerBlockDetails is null or undefined');\n        throw new Error('Failed to retrieve headerBlock details: null or undefined result.');\n      }\n\n      // Verify that endBlock exists and is valid\n      // The headerBlocks function returns a struct that might be represented as an array-like object\n      // with numeric indices or a map with named properties, depending on the ethers.js version\n\n      // First, try accessing it as a named property (endBlock or end)\n      let endBlock = headerBlockDetails.endBlock || headerBlockDetails.end;\n\n      // If not found, it might be at index 2 as per the ABI definition (root, start, end, ...)\n      if (endBlock === undefined && Array.isArray(headerBlockDetails)) {\n        endBlock = headerBlockDetails[2];\n      } else if (endBlock === undefined && typeof headerBlockDetails === 'object') {\n        // Try numeric indices if it's an object with numeric keys\n        endBlock = headerBlockDetails[2];\n      }\n\n      if (endBlock === undefined || endBlock === null) {\n        logger.error(\n          'endBlock not found or is null in headerBlockDetails, full details:',\n          JSON.stringify(headerBlockDetails, (_, v) => (typeof v === 'bigint' ? v.toString() : v))\n        );\n        throw new Error('Failed to retrieve endBlock from headerBlockDetails.');\n      }\n\n      // Convert to bigint\n      const lastBlock = BigInt(endBlock.toString());\n      logger.info(`Last L2 block checkpointed on L1 (via CheckpointManager): ${lastBlock}`);\n      return lastBlock;\n    } catch (error: unknown) {\n      logger.error('Error fetching last checkpointed L2 block from L1:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      // Rethrow with a more specific message\n      throw new Error(`Failed to get last checkpointed L2 block: ${errorMessage}`);\n    }\n  }\n\n  /**\n   * Checks if a given Polygon L2 block number has been included in a checkpoint on L1.\n   * @param l2BlockNumber The L2 block number to check.\n   * @returns A promise resolving to true if the block is checkpointed, false otherwise.\n   */\n  async isL2BlockCheckpointed(l2BlockNumber: number | bigint): Promise<boolean> {\n    const targetBlock = BigInt(l2BlockNumber.toString());\n    logger.debug(`Checking if L2 block ${targetBlock} is checkpointed on L1...`);\n    try {\n      logger.debug('Retrieving last checkpointed block from L1...');\n      const lastCheckpointedBlock = await this.getLastCheckpointedL2Block();\n\n      logger.debug(\n        `Comparing target block ${targetBlock} with last checkpointed block ${lastCheckpointedBlock}`\n      );\n      const isCheckpointed = targetBlock <= lastCheckpointedBlock;\n\n      logger.info(\n        `L2 block ${targetBlock} checkpointed status: ${isCheckpointed} (Last Checkpointed: ${lastCheckpointedBlock})`\n      );\n      return isCheckpointed;\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(\n        `Could not determine checkpoint status for L2 block ${targetBlock} due to error fetching last checkpoint: ${errorMessage}`,\n        error\n      );\n\n      // Consistent with user plan: if getLastCheckpointedL2Block fails, this should also fail rather than return false.\n      throw new Error(\n        `Failed to determine checkpoint status for L2 block ${targetBlock}: ${errorMessage}`\n      );\n    }\n  }\n}\n","[\n  {\n    \"inputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_registry\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_rootchain\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_token\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_NFTContract\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_stakingLogger\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_validatorShareFactory\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_governance\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_extensionCode\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"isOwner\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getRegistry\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"tokenId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ownerOf\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"epoch\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"withdrawalDelay\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"validatorStake\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"user\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getValidatorId\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegatedAmount\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"delegatorsReward\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"validatorReward\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"currentValidatorSetSize\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"currentValidatorSetTotalStake\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"getValidatorContract\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"isValidator\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"enabled\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"setDelegationEnabled\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"forceUnstake\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_currentEpoch\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setCurrentEpoch\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_token\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setStakingToken\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"newThreshold\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"updateValidatorThreshold\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_blocks\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"updateCheckPointBlockInterval\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"newReward\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"updateCheckpointReward\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"heimdallFee\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"topUpForFee\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"heimdallFee\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"acceptDelegation\",\n        \"type\": \"bool\"\n      },\n      {\n        \"name\": \"signerPubkey\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"stakeFor\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstake\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstakeClaim\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"stakeRewards\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"name\": \"restake\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"withdrawRewards\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"fromValidatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"toValidatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"migrateDelegation\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"amount\",\n        \"type\": \"int256\"\n      }\n    ],\n    \"name\": \"updateValidatorState\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"decreaseValidatorDelegatedAmount\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"signerPubkey\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"updateSigner\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"blockInterval\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"voteHash\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"name\": \"stateRoot\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"name\": \"proposer\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"sigs\",\n        \"type\": \"uint256[3][]\"\n      }\n    ],\n    \"name\": \"checkSignatures\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"name\": \"newCommissionRate\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"updateCommissionRate\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_slashingInfoList\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"slash\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"validatorId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unjail\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]\n","[\n  {\n    \"inputs\": [],\n    \"name\": \"buyVoucher\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minSharesToMint\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"buyVoucher\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"restake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_unbondNonce\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstakeClaimTokens\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"claimAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unstakeClaimTokens\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"sellVoucher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_minClaimAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"sellVoucher\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"withdrawRewards\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getLiquidRewards\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"getTotalStake\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"validatorId\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"activeAmount\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"amountStaked\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"exchangeRate\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"unbonds\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"withdrawEpoch\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ShareMinted\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ShareBurned\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"RewardClaimed\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"nonce\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"claimAmount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Unbonded\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"nonce\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"amount\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"UnbondClaimed\",\n    \"type\": \"event\"\n  }\n]\n","[\n  {\n    \"inputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"constructor\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"tokenType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"predicateAddress\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"PredicateRegistered\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"rootToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"childToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"bytes32\",\n        \"name\": \"tokenType\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"TokenMapped\",\n    \"type\": \"event\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"DEPOSIT\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"ETHER_ADDRESS\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"MAP_TOKEN\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"MAPPER_ROLE\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"checkpointManagerAddress\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"childChainManagerAddress\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"rootToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"childToken\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"cleanMapToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"rootToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"depositData\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"depositFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"user\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"depositEtherFor\",\n    \"outputs\": [],\n    \"stateMutability\": \"payable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"inputData\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"exit\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"initialize\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"initializeEIP712\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"rootToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"childToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"tokenType\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"mapToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"processedExits\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"tokenType\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"predicateAddress\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"registerPredicate\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"rootToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"childToken\",\n        \"type\": \"address\"\n      },\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"tokenType\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"remapToken\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newCheckpointManager\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setCheckpointManager\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newChildChainManager\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setChildChainManagerAddress\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newStateSender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"setStateSender\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"setupContractId\",\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"inputs\": [],\n    \"name\": \"stateSenderAddress\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"stateMutability\": \"payable\",\n    \"type\": \"receive\"\n  }\n]\n","[\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"name\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"decimals\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"symbol\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"allowance\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"approve\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"totalSupply\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_from\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transferFrom\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"_owner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"balanceOf\",\n    \"outputs\": [\n      {\n        \"name\": \"balance\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"name\": \"_to\",\n        \"type\": \"address\"\n      },\n      {\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"transfer\",\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"payable\": true,\n    \"stateMutability\": \"payable\",\n    \"type\": \"fallback\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"owner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"spender\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Approval\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"name\": \"from\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"name\": \"to\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": false,\n        \"name\": \"value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"Transfer\",\n    \"type\": \"event\"\n  }\n]","[\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"proposer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"headerBlockId\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"reward\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"start\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"uint256\",\n        \"name\": \"end\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"indexed\": false,\n        \"internalType\": \"bytes32\",\n        \"name\": \"root\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"name\": \"NewHeaderBlock\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"previousOwner\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"OwnershipTransferred\",\n    \"type\": \"event\"\n  },\n  {\n    \"anonymous\": false,\n    \"inputs\": [\n      {\n        \"indexed\": true,\n        \"internalType\": \"address\",\n        \"name\": \"proposer\",\n        \"type\": \"address\"\n      },\n      {\n        \"indexed\": true,\n        \"internalType\": \"uint256\",\n        \"name\": \"headerBlockId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"ResetHeaderBlock\",\n    \"type\": \"event\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"CHAINID\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"VOTE_TYPE\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint8\",\n        \"name\": \"\",\n        \"type\": \"uint8\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"_nextHeaderBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"currentHeaderBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"getLastChildBlock\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"headerBlocks\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"root\",\n        \"type\": \"bytes32\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"start\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"end\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"createdAt\",\n        \"type\": \"uint256\"\n      },\n      {\n        \"internalType\": \"address\",\n        \"name\": \"proposer\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"heimdallId\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes32\",\n        \"name\": \"\",\n        \"type\": \"bytes32\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"isOwner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bool\",\n        \"name\": \"\",\n        \"type\": \"bool\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"networkId\",\n    \"outputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": true,\n    \"inputs\": [],\n    \"name\": \"owner\",\n    \"outputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"\",\n        \"type\": \"address\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"view\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [],\n    \"name\": \"renounceOwnership\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"string\",\n        \"name\": \"_heimdallId\",\n        \"type\": \"string\"\n      }\n    ],\n    \"name\": \"setHeimdallId\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"_value\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"setNextHeaderBlock\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [],\n    \"name\": \"slash\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"uint256[3][]\",\n        \"name\": \"sigs\",\n        \"type\": \"uint256[3][]\"\n      }\n    ],\n    \"name\": \"submitCheckpoint\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"data\",\n        \"type\": \"bytes\"\n      },\n      {\n        \"internalType\": \"bytes\",\n        \"name\": \"sigs\",\n        \"type\": \"bytes\"\n      }\n    ],\n    \"name\": \"submitHeaderBlock\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"address\",\n        \"name\": \"newOwner\",\n        \"type\": \"address\"\n      }\n    ],\n    \"name\": \"transferOwnership\",\n    \"outputs\": [],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  },\n  {\n    \"constant\": false,\n    \"inputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"numDeposits\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"name\": \"updateDepositId\",\n    \"outputs\": [\n      {\n        \"internalType\": \"uint256\",\n        \"name\": \"depositId\",\n        \"type\": \"uint256\"\n      }\n    ],\n    \"payable\": false,\n    \"stateMutability\": \"nonpayable\",\n    \"type\": \"function\"\n  }\n]","import axios from 'axios';\nimport { parseUnits, formatUnits } from 'ethers'; // Assuming ethers v6 for bigint handling\nimport type { IAgentRuntime } from '@elizaos/core';\nimport { elizaLogger } from '@elizaos/core';\n\n// Placeholder for core RPC interaction wrapper - replace with actual ElizaOS mechanism\nconst coreRpc = {\n  eth_gasPrice: async (): Promise<bigint> => {\n    // In a real scenario, this would call the configured Polygon RPC endpoint\n    elizaLogger.warn('Using fallback eth_gasPrice RPC method.');\n    // Simulating a typical gas price in Wei (e.g., 50 Gwei)\n    return parseUnits('50', 'gwei');\n  },\n};\n\n/**\n * Structure of the expected successful response from the PolygonScan Gas Oracle API.\n * Prices are typically returned in Gwei as strings.\n */\ninterface PolygonScanGasResult {\n  LastBlock: string;\n  SafeGasPrice: string;\n  ProposeGasPrice: string;\n  FastGasPrice: string;\n  suggestBaseFee: string; // Base fee estimate in Gwei\n  gasUsedRatio: string;\n}\n\ninterface PolygonScanGasOracleResponse {\n  status: string;\n  message: string;\n  result: PolygonScanGasResult;\n}\n\n/**\n * Standardized return structure for gas price estimates.\n * All values are represented in Wei as bigints.\n * Fields can be null if data is unavailable (e.g., during fallback).\n */\nexport interface GasPriceEstimates {\n  safeLow: {\n    maxPriorityFeePerGas: bigint | null; // Corresponds to SafeGasPrice\n    // maxFeePerGas might be calculated later using baseFee + priorityFee\n  } | null;\n  average: {\n    maxPriorityFeePerGas: bigint | null; // Corresponds to ProposeGasPrice\n  } | null;\n  fast: {\n    maxPriorityFeePerGas: bigint | null; // Corresponds to FastGasPrice\n  } | null;\n  /** Estimated next block base fee in Wei. */\n  estimatedBaseFee: bigint | null; // Corresponds to suggestBaseFee\n  /** Fallback gas price from eth_gasPrice in Wei, if used. */\n  fallbackGasPrice?: bigint | null;\n}\n\nconst POLYGONSCAN_API_URL = 'https://api.polygonscan.com/api';\n\n/**\n * Converts a Gwei string value to a Wei bigint value.\n * Handles potential decimal values in the Gwei string.\n * @param gweiString Value in Gwei (as string).\n * @returns Value in Wei (as bigint).\n */\nfunction gweiToWei(gweiString: string): bigint {\n  try {\n    // Use parseUnits which handles decimals correctly\n    return parseUnits(gweiString, 'gwei');\n  } catch (error) {\n    elizaLogger.error(`Error converting Gwei string \"${gweiString}\" to Wei:`, error);\n    throw new Error(`Invalid Gwei value format: ${gweiString}`);\n  }\n}\n\n/**\n * Fetches gas price estimates from PolygonScan API with fallback to eth_gasPrice.\n *\n * @returns A promise resolving to GasPriceEstimates object with values in Wei.\n */\nexport const getGasPriceEstimates = async (runtime: IAgentRuntime): Promise<GasPriceEstimates> => {\n  const apiKey = runtime.getSetting('POLYGONSCAN_KEY');\n\n  if (!apiKey) {\n    elizaLogger.warn('POLYGONSCAN_KEY not found in configuration. Falling back to eth_gasPrice.');\n    return fetchFallbackGasPrice();\n  }\n\n  const params = {\n    module: 'gastracker',\n    action: 'gasoracle',\n    apikey: apiKey,\n  };\n\n  try {\n    const response = await axios.get<PolygonScanGasOracleResponse>(POLYGONSCAN_API_URL, { params });\n\n    if (response.status !== 200) {\n      throw new Error(`PolygonScan API request failed with status ${response.status}`);\n    }\n\n    const data = response.data;\n\n    // PolygonScan sometimes returns status \"0\" with a message for errors (like invalid key)\n    if (data.status !== '1' || !data.result) {\n      elizaLogger.error(\n        `PolygonScan API returned an error: ${data.message} (Status: ${data.status})`\n      );\n      elizaLogger.warn('Falling back to eth_gasPrice.');\n      return fetchFallbackGasPrice();\n    }\n\n    const { SafeGasPrice, ProposeGasPrice, FastGasPrice, suggestBaseFee } = data.result;\n\n    // Convert Gwei strings to Wei bigints\n    const safeWei = gweiToWei(SafeGasPrice);\n    const proposeWei = gweiToWei(ProposeGasPrice);\n    const fastWei = gweiToWei(FastGasPrice);\n    const baseFeeWei = gweiToWei(suggestBaseFee);\n\n    return {\n      safeLow: { maxPriorityFeePerGas: safeWei },\n      average: { maxPriorityFeePerGas: proposeWei },\n      fast: { maxPriorityFeePerGas: fastWei },\n      estimatedBaseFee: baseFeeWei,\n      fallbackGasPrice: null, // Indicate fallback was not used\n    };\n  } catch (error) {\n    elizaLogger.error('Error fetching or parsing PolygonScan gas estimates:', error);\n    elizaLogger.warn('Falling back to eth_gasPrice.');\n    return fetchFallbackGasPrice();\n  }\n};\n\n/**\n * Fetches gas price using the eth_gasPrice RPC method as a fallback.\n *\n * @returns A promise resolving to a simplified GasPriceEstimates object.\n */\nconst fetchFallbackGasPrice = async (): Promise<GasPriceEstimates> => {\n  try {\n    const gasPriceWei = await coreRpc.eth_gasPrice();\n\n    // When using fallback, we only have a single gas price.\n    // We might assign it to 'average' priority or provide it separately.\n    // We set priority fees and base fee to null as they aren't directly available.\n    // Providing the raw fallback value allows consumers to decide how to use it.\n    return {\n      safeLow: null,\n      average: null, // Or potentially { maxPriorityFeePerGas: gasPriceWei } if treating as priority\n      fast: null,\n      estimatedBaseFee: null,\n      fallbackGasPrice: gasPriceWei, // Provide the fallback value explicitly\n    };\n  } catch (rpcError) {\n    elizaLogger.error('Error fetching fallback gas price via eth_gasPrice:', rpcError);\n    // Return empty estimates if fallback also fails\n    return {\n      safeLow: null,\n      average: null,\n      fast: null,\n      estimatedBaseFee: null,\n      fallbackGasPrice: null,\n    };\n  }\n};\n","export const getValidatorInfoTemplate = `You are an AI assistant. Your task is to extract the validator ID from the user\\'s message.\nThe validator ID must be a positive integer.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID.\n\nRespond with a JSON markdown block containing only the extracted validator ID.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number\n}\n\\`\\`\\`\n\nIf no valid validator ID is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID not found or invalid. Please specify a positive integer for the validator ID.\"\n}\n\\`\\`\\`\n`;\n\nexport const getDelegatorInfoTemplate = `You are an AI assistant. Your task is to extract the validator ID and optionally a delegator address from the user\\'s message.\nThe validator ID must be a positive integer.\nThe delegator address, if provided by the user, must be a valid Ethereum-style address (starting with 0x).\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID and delegator address (if specified by the user).\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number,\n    \"delegatorAddress\"?: string\n}\n\\`\\`\\`\nIf \\'delegatorAddress\\' is not mentioned by the user, omit it from the JSON.\n\nIf no valid validator ID is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID not found or invalid. Please specify a positive integer for the validator ID.\"\n}\n\\`\\`\\`\n`;\n\nexport const delegateL1Template = `You are an AI assistant. Your task is to extract the validator ID and the amount to delegate from the user\\'s message.\nThe validator ID must be a positive integer.\nThe amount must be a positive number, representing the amount in the smallest unit (Wei) as a string.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID and the amount to delegate.\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number,\n    \"amountWei\": string\n}\n\\`\\`\\`\n\nIf no valid validator ID or amount is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID or amount not found or invalid. Please specify a positive integer for the validator ID and a positive amount in Wei (as a string).\"\n}\n\\`\\`\\`\n`;\n\nexport const undelegateL1Template = `You are an AI assistant. Your task is to extract the validator ID and the amount of shares to undelegate from the user\\'s message.\nThe validator ID must be a positive integer.\nThe shares amount must be a positive number, representing the amount of validator shares in the smallest unit (Wei) as a string.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID and the amount of shares to undelegate.\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number,\n    \"sharesAmountWei\": string\n}\n\\`\\`\\`\n\nIf no valid validator ID or shares amount is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID or shares amount not found or invalid. Please specify a positive integer for the validator ID and a positive amount of shares in Wei (as a string).\"\n}\n\\`\\`\\`\n`;\n\nexport const withdrawRewardsTemplate = `You are an AI assistant. Your task is to extract the validator ID from the user\\'s message for withdrawing staking rewards.\nThe validator ID must be a positive integer.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID from which to withdraw rewards.\n\nRespond with a JSON markdown block containing only the extracted validator ID.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number\n}\n\\`\\`\\`\n\nIf no valid validator ID is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID not found or invalid. Please specify a positive integer for the validator ID.\"\n}\n\\`\\`\\`\n`;\n\nexport const restakeRewardsL1Template = `You are an AI assistant. Your task is to extract the validator ID from the user\\'s message for a restake rewards operation on L1.\nThe validator ID must be a positive integer.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the validator ID for which to restake rewards.\n\nRespond with a JSON markdown block containing only the extracted validator ID.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"validatorId\": number\n}\n\\`\\`\\`\n\nIf no valid validator ID is found, or if the user\\'s intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Validator ID not found or invalid. Please specify a positive integer for the validator ID.\"\n}\n\\`\\`\\`\n`;\n\nexport const getPolygonGasEstimatesTemplate = `You are an AI assistant. Your task is to determine if the user is asking for Polygon gas estimates.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, determine if the user is requesting information about gas prices or gas estimates on the Polygon network.\n\nRespond with a JSON markdown block indicating whether to retrieve gas estimates.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"getGasEstimates\": boolean\n}\n\\`\\`\\`\n\nIf the user's intent is unclear or unrelated to Polygon gas estimates, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"It's unclear if you're asking for Polygon gas estimates. Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const bridgeDepositPolygonTemplate = `You are an AI assistant. Your task is to extract parameters for a bridge deposit between blockchain networks.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, extract the following parameters:\n- fromChain: The source blockchain network (e.g., \"ethereum\", \"polygon\", \"arbitrum\")\n- toChain: The destination blockchain network (e.g., \"ethereum\", \"polygon\", \"arbitrum\")\n- fromToken: The token address on the source chain (string starting with 0x)\n- toToken: The token address on the destination chain (string starting with 0x)\n- amount: The amount to bridge (string, representing the human-readable amount)\n- toAddress (optional): The recipient address on the destination chain (string starting with 0x)\n\nImportant notes: \n- Always use \"ethereum\" (not \"mainnet\") when referring to the Ethereum network\n- Always use \"polygon\" when referring to the Polygon network\n- Always use \"arbitrum\" when referring to the Arbitrum network\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure and MUST NOT include any comments:\n\\`\\`\\`json\n{\n    \"fromChain\": string,\n    \"toChain\": string,\n    \"fromToken\": string,\n    \"toToken\": string,\n    \"amount\": string,\n    \"toAddress\"?: string\n}\n\\`\\`\\`\nIf 'toAddress' is not mentioned by the user, omit it from the JSON.\n\nIMPORTANT: Your JSON response must be valid JSON without any comments or explanatory text. Do not include // comments or /* */ style comments in the JSON.\n\nIf the required parameters are not found or invalid, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Missing or invalid parameters. Please provide source chain, destination chain, token addresses and amount.\"\n}\n\\`\\`\\`\n\nExample valid tokens:\n- Ethereum MATIC: 0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0\n- Ethereum USDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n- Ethereum WETH: 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n- Polygon MATIC: 0x0000000000000000000000000000000000001010\n- Polygon USDC: 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\n- Polygon WETH: 0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619\n- Arbitrum USDC: 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8\n- Arbitrum WETH: 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1\n\nAlways use the appropriate token address for the specified chains.`;\n\nexport const proposeGovernanceActionTemplate = `You are an AI assistant. Your task is to extract parameters for submitting a new governance proposal.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- chain: The blockchain name (e.g., \"polygon\").\n- governorAddress: The address of the Governor contract.\n- targets: An array of target contract addresses.\n- values: An array of ETH values (strings) for each action.\n- calldatas: An array of hex-encoded calldata for each action.\n- description: The full text description of the proposal.\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"chain\": \"string\",\n    \"governorAddress\": \"0xstring\",\n    \"targets\": [\"0xstring\"],\n    \"values\": [\"string\"],\n    \"calldatas\": [\"0xstring\"],\n    \"description\": \"string\"\n}\n\\`\\`\\`\n\nIf any required parameters are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all required governance proposal parameters (chain, governorAddress, targets, values, calldatas, description). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const voteGovernanceActionTemplate = `You are an AI assistant. Your task is to extract parameters for voting on a governance proposal.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- chain: The blockchain name (e.g., \"polygon\").\n- governorAddress: The address of the Governor contract.\n- proposalId: The ID of the proposal to vote on.\n- support: The vote option (0 for Against, 1 for For, 2 for Abstain).\n- reason (optional): The reason for the vote.\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"chain\": \"string\",\n    \"governorAddress\": \"0xstring\",\n    \"proposalId\": \"string\",\n    \"support\": number,\n    \"reason\"?: \"string\"\n}\n\\`\\`\\`\n\nIf any required parameters (chain, governorAddress, proposalId, support) are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all required voting parameters (chain, governorAddress, proposalId, support). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const queueGovernanceActionTemplate = `You are an AI assistant. Your task is to extract parameters for queueing a passed governance proposal.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- chain: The blockchain name (e.g., \"polygon\").\n- governorAddress: The address of the Governor contract.\n- targets: An array of target contract addresses.\n- values: An array of ETH values (strings) for each action.\n- calldatas: An array of hex-encoded calldata for each action.\n- description: The full text description of the proposal (must match the original proposal).\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"chain\": \"string\",\n    \"governorAddress\": \"0xstring\",\n    \"targets\": [\"0xstring\"],\n    \"values\": [\"string\"],\n    \"calldatas\": [\"0xstring\"],\n    \"description\": \"string\"\n}\n\\`\\`\\`\n\nIf any required parameters are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all parameters for queueing the proposal (chain, governorAddress, targets, values, calldatas, description). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const executeGovernanceActionTemplate = `You are an AI assistant. Your task is to extract parameters for executing a queued governance proposal.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- chain: The blockchain name (e.g., \"polygon\").\n- governorAddress: The address of the Governor contract.\n- targets: An array of target contract addresses.\n- values: An array of ETH values (strings) for each action.\n- calldatas: An array of hex-encoded calldata for each action.\n- description: The full text description of the proposal (must match the original proposal).\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"chain\": \"string\",\n    \"governorAddress\": \"0xstring\",\n    \"targets\": [\"0xstring\"],\n    \"values\": [\"string\"],\n    \"calldatas\": [\"0xstring\"],\n    \"description\": \"string\"\n}\n\\`\\`\\`\n\nIf any required parameters are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all parameters for executing the proposal (chain, governorAddress, targets, values, calldatas, description). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const heimdallVoteActionTemplate = `You are an AI assistant. Your task is to extract parameters for voting on a Heimdall governance proposal.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- proposalId: The ID of the Heimdall proposal (string or number).\n- option: The vote option (numeric value like 0, 1, 2, 3, 4, or string like YES, NO, ABSTAIN).\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"proposalId\": \"string | number\",\n    \"option\": \"number | string\"\n}\n\\`\\`\\`\n\nIf any required parameters (proposalId, option) are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all required Heimdall voting parameters (proposalId, option). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const heimdallSubmitProposalActionTemplate = `You are an AI assistant. Your task is to extract parameters for submitting a new governance proposal (Text or ParameterChange) to Heimdall.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify:\n- content: An object representing the proposal content. It must have a \"type\" field (\"TextProposal\" or \"ParameterChangeProposal\").\n  - For TextProposal: \"title\" (string), \"description\" (string).\n  - For ParameterChangeProposal: \"title\" (string), \"description\" (string), \"changes\" (array of {subspace: string, key: string, value: string}).\n- initialDepositAmount: The amount of the initial deposit for the proposal (string, e.g., \"10000000\").\n- initialDepositDenom (optional): The denomination of the initial deposit (default: \"matic\").\n\nRespond with a JSON markdown block containing only the extracted values.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"content\": {\n        \"type\": \"TextProposal\" | \"ParameterChangeProposal\",\n        \"title\": \"string\",\n        \"description\": \"string\",\n        \"changes\": [{ \"subspace\": \"string\", \"key\": \"string\", \"value\": \"string\" }] // Only for ParameterChangeProposal\n    },\n    \"initialDepositAmount\": \"string\",\n    \"initialDepositDenom\": \"string\" // e.g., \"matic\"\n}\n\\`\\`\\`\n\nExample for TextProposal content:\n{\n    \"type\": \"TextProposal\",\n    \"title\": \"Network Upgrade Info\",\n    \"description\": \"Details about upcoming v2 upgrade.\"\n}\n\nExample for ParameterChangeProposal content:\n{\n    \"type\": \"ParameterChangeProposal\",\n    \"title\": \"Update Staking Param\",\n    \"description\": \"Increase max validators\",\n    \"changes\": [\n        { \"subspace\": \"staking\", \"key\": \"MaxValidators\", \"value\": \"120\" }\n    ]\n}\n\nIf any required parameters are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all required Heimdall proposal parameters (content type, title, description, initialDepositAmount, and changes if ParameterChangeProposal). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const heimdallTransferTokensActionTemplate = `You are an AI assistant. Your task is to extract parameters for transferring native tokens on the Heimdall network.\\n\\nReview the recent messages:\\n<recent_messages>\\n{{recentMessages}}\\n</recent_messages>\\n\\nBased on the conversation, identify:\\n- recipientAddress: The Heimdall address of the recipient (must start with \\\"heimdall\\\" or \\\"heimdallvaloper\\\").\\n- amount: The amount of tokens to transfer in Wei (string of digits, e.g., \\\"1000000000000000000\\\").\\n- denom (optional): The denomination of the tokens (default: \\\"matic\\\").\\n\\nRespond with a JSON markdown block containing only the extracted values.\\nThe JSON should have this structure:\\n\\`\\`\\`json\n{\n    \"recipientAddress\": \"string\",\n    \"amount\": \"string\",\n    \"denom\": \"string\" // e.g., \"matic\" or \"uatom\"\n}\n\\`\\`\\`\n\nIf any required parameters (recipientAddress, amount) are missing or unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Could not determine all required Heimdall transfer parameters (recipientAddress, amount). Please clarify your request.\"\n}\n\\`\\`\\`\n`;\n\nexport const getCheckpointStatusTemplate = `You are an AI assistant. Your task is to extract the block number from the user's message to check its checkpoint status.\nThe block number must be a positive integer.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the Polygon L2 block number to check.\n\nRespond with a JSON markdown block containing only the extracted block number.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"blockNumber\": number\n}\n\\`\\`\\`\n\nIf no valid block number is found, or if the user's intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Block number not found or invalid. Please specify a positive integer for the block number.\"\n}\n\\`\\`\\`\n`;\n\nexport const isL2BlockCheckpointedTemplate = `You are an AI assistant. Your task is to extract the block number from the user's message to check if it has been checkpointed.\nThe block number must be a positive integer. Extract the block number from the user's most recent message if multiple messages are provided.\nDo not return anything other than the block number requested to be checked in the following json format.\n\nReview the recent messages:\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nBased on the conversation, identify the Polygon L2 block number to check if it has been checkpointed.\n\nRespond with a JSON markdown block containing only the extracted block number.\nThe JSON should have this structure:\n\\`\\`\\`json\n{\n    \"l2BlockNumber\": number\n}\n\\`\\`\\`\n\nIf no valid block number is found, or if the user's intent is unclear, you MUST respond with the following JSON structure:\n\\`\\`\\`json\n{\n    \"error\": \"Block number not found or invalid. Please specify a positive integer for the block number.\"\n}\n\\`\\`\\`\n`;\n","/**\n * Custom error classes for the Polygon plugin\n * These provide more specific error handling and better error messages for users\n */\n\n/**\n * Base error class for RPC-related errors\n * Used for errors communicating with Ethereum or Polygon RPC endpoints\n */\nexport class PolygonRpcError extends Error {\n  constructor(\n    message: string,\n    public readonly cause?: unknown\n  ) {\n    super(message);\n    this.name = 'PolygonRpcError';\n  }\n}\n\n/**\n * Error class for input validation failures\n * Used when user inputs or configuration are invalid\n */\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n/**\n * Error class for transaction failures\n * Used when a blockchain transaction fails or reverts\n */\nexport class TransactionError extends Error {\n  constructor(\n    message: string,\n    public readonly txHash?: string\n  ) {\n    super(message);\n    this.name = 'TransactionError';\n  }\n}\n\n/**\n * Error class for contract-related errors\n * Used for errors interacting with smart contracts\n */\nexport class ContractError extends Error {\n  constructor(\n    message: string,\n    public readonly contractAddress?: string,\n    public readonly functionName?: string\n  ) {\n    super(message);\n    this.name = 'ContractError';\n  }\n}\n\n/**\n * Error class for provider initialization errors\n * Used when providers fail to initialize\n */\nexport class ProviderError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ProviderError';\n  }\n}\n\n/**\n * Error class for service initialization errors\n * Used when services fail to initialize\n */\nexport class ServiceError extends Error {\n  constructor(\n    message: string,\n    public readonly serviceName?: string\n  ) {\n    super(message);\n    this.name = 'ServiceError';\n  }\n}\n\n/**\n * Helper function to format error messages consistently\n */\nexport function formatErrorMessage(action: string, message: string, details?: string): string {\n  let formattedMessage = `${action} failed: ${message}`;\n  if (details) {\n    formattedMessage += `. Details: ${details}`;\n  }\n  return formattedMessage;\n}\n\ninterface ParsedError {\n  message: string;\n  details?: string;\n}\n\n/**\n * Helper function to parse error objects from different sources\n * Attempts to extract the most useful error message and details from various error formats.\n * Always returns an object with a message and optional details.\n */\nexport function parseErrorMessage(error: unknown): ParsedError {\n  if (error instanceof Error) {\n    // For standard Error objects, message is primary, stack could be details\n    return { message: error.message, details: error.stack };\n  }\n\n  if (typeof error === 'string') {\n    return { message: error }; // Simple string error\n  }\n\n  if (typeof error === 'object' && error !== null) {\n    let message = 'Unknown object error';\n    let details: string | undefined;\n\n    // Try to handle common error shapes from RPC calls or other libraries\n    if ('message' in error && typeof error.message === 'string') {\n      message = error.message;\n    }\n\n    if ('reason' in error && typeof error.reason === 'string') {\n      message = error.reason; // Often used in ethers.js errors\n    }\n\n    if ('data' in error && typeof error.data === 'string') {\n      details = error.data; // E.g., revert reason from ethers\n    } else if ('stack' in error && typeof error.stack === 'string') {\n      details = error.stack;\n    }\n\n    // Check for nested error objects (common in some RPC error wrappers)\n    if (\n      message === 'Unknown object error' &&\n      'error' in error &&\n      typeof error.error === 'object' &&\n      error.error !== null\n    ) {\n      const nestedError = error.error as Record<string, unknown>; // Type assertion\n      if ('message' in nestedError && typeof nestedError.message === 'string') {\n        message = nestedError.message;\n      }\n      if ('data' in nestedError && typeof nestedError.data === 'string') {\n        details = `${details ? `${details}; ` : ''}${nestedError.data}`;\n      }\n    }\n\n    // If still default message, try to stringify the object as a last resort for details\n    if (message === 'Unknown object error') {\n      try {\n        details = JSON.stringify(error);\n      } catch (e) {\n        details = 'Unserializable error object';\n      }\n    }\n\n    return { message, details };\n  }\n\n  return { message: 'Unknown error' }; // Fallback for truly unknown types\n}\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { getCheckpointStatusTemplate } from '../templates';\n\n// Define the structure for checkpoint status information\ninterface CheckpointStatus {\n  blockNumber: number;\n  isCheckpointed: boolean;\n  lastCheckpointedBlock: bigint;\n}\n\n// Define input schema for the LLM-extracted parameters\ninterface CheckpointParams {\n  blockNumber?: number;\n  error?: string;\n}\n\nexport const getCheckpointStatusAction: Action = {\n  name: 'GET_CHECKPOINT_STATUS',\n  similes: ['CHECK_CHECKPOINT', 'POLYGON_CHECKPOINT_STATE'],\n  description: 'Checks if a Polygon L2 block has been checkpointed to Ethereum L1.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating GET_CHECKPOINT_STATUS action...');\n\n    // Check for required settings\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for checkpoint verification\n      'POLYGON_RPC_URL', // L2 RPC for completeness\n      'POLYGON_PLUGINS_ENABLED',\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(\n          `Required setting ${setting} not configured for GET_CHECKPOINT_STATUS action.`\n        );\n        return false;\n      }\n    }\n\n    // Verify PolygonRpcService is available\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error('Error accessing PolygonRpcService during validation:', error);\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    logger.info('Handling GET_CHECKPOINT_STATUS action for message:', message.id);\n\n    try {\n      // Get the PolygonRpcService\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      // Extract parameters using LLM with proper template\n      const prompt = composePromptFromState({\n        state,\n        template: getCheckpointStatusTemplate,\n      });\n\n      // Try using the model to extract block number\n      const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n      let params: CheckpointParams;\n\n      try {\n        params = parseJSONObjectFromText(modelResponse) as CheckpointParams;\n        logger.debug('GET_CHECKPOINT_STATUS: Extracted params:', params);\n\n        if (params.error) {\n          // Check if the model response contains an error\n          logger.warn(`GET_CHECKPOINT_STATUS: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (error: unknown) {\n        logger.error(\n          'Failed to parse LLM response for checkpoint parameters:',\n          modelResponse,\n          error\n        );\n        throw new Error('Could not understand checkpoint parameters.');\n      }\n\n      if (params.blockNumber === undefined) {\n        throw new Error('Block number parameter not extracted properly.');\n      }\n\n      logger.debug('Checkpoint parameters:', params);\n\n      // Get latest L2 block number if needed for context\n      const currentBlockNumber = await polygonService.getCurrentBlockNumber();\n\n      // Get the last checkpoint block\n      const lastCheckpointedBlock = await polygonService.getLastCheckpointedL2Block();\n\n      // Check if the specified block is checkpointed\n      const isCheckpointed = await polygonService.isL2BlockCheckpointed(params.blockNumber);\n\n      // Build the status object\n      const status: CheckpointStatus = {\n        blockNumber: params.blockNumber,\n        isCheckpointed,\n        lastCheckpointedBlock,\n      };\n\n      // Prepare response message\n      let responseMsg = `Polygon block ${params.blockNumber} ${isCheckpointed ? 'is' : 'is not'} checkpointed on Ethereum.`;\n      responseMsg += ` Last checkpointed block: ${lastCheckpointedBlock.toString()}`;\n\n      if (!isCheckpointed && params.blockNumber > Number(lastCheckpointedBlock)) {\n        const blocksRemaining = params.blockNumber - Number(lastCheckpointedBlock);\n        responseMsg += ` (${blocksRemaining} blocks pending)`;\n      }\n\n      if (params.blockNumber > currentBlockNumber) {\n        responseMsg += ` Note: Block ${params.blockNumber} is in the future (current block: ${currentBlockNumber})`;\n      }\n\n      logger.info(responseMsg);\n\n      // Format the response content\n      const responseContent: Content = {\n        text: responseMsg,\n        actions: ['GET_CHECKPOINT_STATUS'],\n        source: message.content.source,\n        data: {\n          blockNumber: params.blockNumber,\n          currentBlockNumber,\n          lastCheckpointedBlock: lastCheckpointedBlock.toString(),\n          isCheckpointed,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    } catch (error: unknown) {\n      // Handle errors\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in GET_CHECKPOINT_STATUS handler:', errMsg, error);\n\n      // Format error response\n      const errorContent: Content = {\n        text: `Error checking checkpoint status: ${errMsg}`,\n        actions: ['GET_CHECKPOINT_STATUS'],\n        source: message.content.source,\n        data: { success: false, error: errMsg },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Check if Polygon block 42000000 has been checkpointed',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Has block 41500000 on Polygon been checkpointed to Ethereum yet?',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  type ActionExample,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\n// import { type Chain, polygon as polygonChain, mainnet as ethereumChain } from 'viem/chains'; // Chains managed by Provider\nimport {\n  // createWalletClient, http, type WalletClient, // Provided by WalletProvider instance\n  encodeFunctionData,\n  type Address,\n  type Hex,\n  // PublicClient, createPublicClient, fallback, // Provided by WalletProvider instance\n  type Transport, // Not directly used, but WalletProvider uses it\n  type Account, // Not directly used, but WalletProvider uses it\n  type Chain, // For type annotation\n  type Log,\n  parseUnits, // Added for currency parsing\n} from 'viem';\n// import { privateKeyToAccount } from 'viem/accounts'; // Handled by Provider\n\nimport { type WalletProvider, initWalletProvider } from '../providers/PolygonWalletProvider';\nimport { proposeGovernanceActionTemplate } from '../templates';\n\n// Minimal ABI for OZ Governor propose function\nconst governorProposeAbi = [\n  {\n    inputs: [\n      { name: 'targets', type: 'address[]' },\n      { name: 'values', type: 'uint256[]' },\n      { name: 'calldatas', type: 'bytes[]' },\n      { name: 'description', type: 'string' },\n    ],\n    name: 'propose',\n    outputs: [{ name: 'proposalId', type: 'uint256' }],\n    stateMutability: 'nonpayable', // or 'payable' if it can receive value\n    type: 'function',\n  },\n] as const; // Use 'as const' for better type inference with viem\n\n// REMOVE INLINE WalletProvider, ChainConfig, and initWalletProvider\n\ninterface ProposeGovernanceParams {\n  chain: string; // e.g., \"polygon\", \"ethereum\"\n  governorAddress: Address;\n  targets: Address[];\n  values: string[]; // Array of ETH values as strings (e.g., \"0\", \"0.1\") to be converted to BigInt\n  calldatas: Hex[];\n  description: string;\n}\n\ninterface GovernanceTransaction extends Transaction {\n  // Assuming Transaction type from bridgeDeposit\n  logs?: Log[]; // viem Log[]\n  proposalId?: bigint; // Extracted from logs if possible\n}\ninterface Transaction {\n  hash: `0x${string}`;\n  from: `0x${string}`;\n  to: `0x${string}`;\n  value: bigint;\n  chainId: number;\n  data?: Hex;\n}\n\n// Helper function to extract params from text if LLM fails\nfunction extractProposeGovernanceParamsFromText(text: string): Partial<ProposeGovernanceParams> {\n  const params: Partial<ProposeGovernanceParams> = {};\n  logger.debug(`Attempting to extract ProposeGovernanceParams from text: \"${text}\"`);\n\n  const chainMatch = text.match(/\\b(?:on\\s+|chain\\s*[:\\-]?\\s*)(\\w+)/i);\n  if (chainMatch?.[1]) params.chain = chainMatch[1].toLowerCase();\n\n  const governorMatch = text.match(/\\b(?:governor\\s*(?:address\\s*)?[:\\-]?\\s*)(0x[a-fA-F0-9]{40})/i);\n  if (governorMatch?.[1]) params.governorAddress = governorMatch[1] as Address;\n\n  // Targets: \"targets: [0x123, 0xabc]\" or \"target: 0x123\" or \"targets 0x123, 0x456\"\n  const targetsRgx = /\\btargets?\\s*[:\\-]?\\s*\\[?((?:0x[a-fA-F0-9]{40}(?:\\s*,\\s*|\\s+)?)+)\\]?/i;\n  const targetsMatch = text.match(targetsRgx);\n  if (targetsMatch?.[1]) {\n    params.targets = targetsMatch[1]\n      .split(/[\\s,]+/)\n      .filter((t) => /^0x[a-fA-F0-9]{40}$/.test(t)) as Address[];\n  }\n\n  // Values: \"values: [0, 100]\" or \"value: 0\" or \"values 0, 100\"\n  const valuesRgx = /\\bvalues?\\s*[:\\-]?\\s*\\[?((?:\\d+(?:\\.\\d+)?(?:\\s*,\\s*|\\s+)?)+)\\]?/i;\n  const valuesMatch = text.match(valuesRgx);\n  if (valuesMatch?.[1]) {\n    params.values = valuesMatch[1].split(/[\\s,]+/).filter((v) => /^\\d+(?:\\.\\d+)?$/.test(v));\n  }\n\n  // Calldatas: \"calldatas: [0xabc, 0xdef]\" or \"calldata: 0xabc\" or \"calldatas 0xabc, 0xdef\"\n  const calldatasRgx = /\\bcalldatas?\\s*[:\\-]?\\s*\\[?((?:0x[a-fA-F0-9]+(?:\\s*,\\s*|\\s+)?)+)\\]?/i;\n  const calldatasMatch = text.match(calldatasRgx);\n  if (calldatasMatch?.[1]) {\n    params.calldatas = calldatasMatch[1]\n      .split(/[\\s,]+/)\n      .filter((c) => /^0x[a-fA-F0-9]+$/.test(c)) as Hex[];\n  }\n\n  // Description: \"desc: \"My Proposal\"\" or \"description is 'Another one'\"\n  // This regex tries to capture quoted strings or up to the end of the line/next parameter.\n  const descriptionMatch = text.match(\n    /\\b(?:desc(?:ription)?\\s*[:\\-]?\\s*)(?:(?:['\"\"\"](.+?)['\"'\"])|(.*?)(?:\\s*\\b(?:chain|governor|targets|values|calldatas)\\b|$))/i\n  );\n  if (descriptionMatch) {\n    params.description = (descriptionMatch[1] || descriptionMatch[2])?.trim();\n  }\n\n  logger.debug('Manually extracted ProposeGovernanceParams:', params);\n  return params;\n}\n\nclass PolygonProposeGovernanceActionRunner {\n  constructor(private walletProvider: WalletProvider) {} // Use imported WalletProvider\n\n  async propose(params: ProposeGovernanceParams): Promise<GovernanceTransaction> {\n    const walletClient = this.walletProvider.getWalletClient(params.chain);\n    const publicClient = this.walletProvider.getPublicClient(params.chain);\n    const chainConfig = this.walletProvider.getChainConfigs(params.chain); // viem.Chain from provider\n\n    if (!walletClient.account) {\n      throw new Error('Wallet client account is not available.');\n    }\n    const senderAddress = walletClient.account.address;\n\n    // Convert currency strings (e.g., \"0.5 ETH\") to wei strings\n    const processedValues = params.values.map((valueStr) => {\n      const lowerValueStr = valueStr.toLowerCase();\n      const decimals = 18; // Default to 18 for ETH/MATIC\n\n      if (lowerValueStr.includes('eth') || lowerValueStr.includes('matic')) {\n        // Extract numeric part, removing the unit. Regex backslash is escaped for code_edit.\n        const numericPart = valueStr.replace(/\\\\s*(eth|matic)/i, '').trim();\n        try {\n          // parseUnits expects a string for the amount\n          return parseUnits(numericPart, decimals).toString();\n        } catch (e) {\n          logger.warn(\n            `Could not parse value \"${valueStr}\" with parseUnits. Attempting direct BigInt conversion of numeric part \"${numericPart}\".`\n          );\n          // If parseUnits fails, return the extracted numericPart for BigInt to try.\n          return numericPart;\n        }\n      }\n      // If no unit, assume it's already in wei or a plain number string\n      return valueStr;\n    });\n\n    const numericValues = processedValues.map((v) => {\n      try {\n        return BigInt(v);\n      } catch (e) {\n        logger.error(\n          `Failed to convert processed value \"${v}\" to BigInt. Original param values: ${JSON.stringify(params.values)}`\n        );\n        throw new Error(\n          `Invalid numeric value for transaction: \"${v}\". Expected a number string convertible to BigInt (wei).`\n        );\n      }\n    });\n\n    const txData = encodeFunctionData({\n      abi: governorProposeAbi,\n      functionName: 'propose',\n      args: [params.targets, numericValues, params.calldatas, params.description],\n    });\n\n    try {\n      logger.debug(\n        `Proposing on ${params.chain} to ${params.governorAddress} with description \"${params.description}\"`\n      );\n      const kzg = {\n        blobToKzgCommitment: (_blob: unknown) => {\n          throw new Error('KZG not impl.');\n        },\n        computeBlobKzgProof: (_blob: unknown, _commit: unknown) => {\n          throw new Error('KZG not impl.');\n        },\n      };\n      const hash = await walletClient.sendTransaction({\n        account: senderAddress,\n        to: params.governorAddress,\n        value: BigInt(0),\n        data: txData,\n        chain: chainConfig as Chain,\n        kzg,\n      });\n\n      logger.info(`Proposal transaction sent. Hash: ${hash}. Waiting for receipt...`);\n      const receipt = await publicClient.waitForTransactionReceipt({ hash });\n      logger.debug('Transaction receipt:', receipt);\n\n      let proposalId: bigint | undefined;\n      // Attempt to find ProposalCreated event (OpenZeppelin Governor standard)\n      // Example: { eventName: 'ProposalCreated', args: { proposalId: ... } }\n      const proposalCreatedEventAbi = governorProposeAbi.find((item) => item.name === 'propose');\n      // This is not an event, ABI is for the function. Parsing logs for proposalId is complex and ABI-dependent.\n      // For now, we'll leave proposalId undefined unless a clearer generic method is found.\n      // Often, the proposalId is returned by the function call in some Governor versions, or emitted in a specific event.\n      // If `outputs: [{ name: 'proposalId', type: 'uint256' }]` is standard, viem might return it or parse from logs.\n      // However, direct return value from sendTransaction is just the hash.\n      // Parsing from `receipt.logs` requires knowing the exact event signature and topics.\n\n      return {\n        hash,\n        from: senderAddress,\n        to: params.governorAddress,\n        value: BigInt(0),\n        data: txData,\n        chainId: chainConfig.id,\n        logs: receipt.logs as Log[],\n        proposalId,\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error(`Governance proposal failed: ${errMsg}`, error);\n      throw new Error(`Governance proposal failed: ${errMsg}`);\n    }\n  }\n}\n\nexport const proposeGovernanceAction: Action = {\n  name: 'PROPOSE_GOVERNANCE_POLYGON',\n  similes: ['CREATE_POLYGON_PROPOSAL', 'SUBMIT_POLYGON_GOVERNANCE_ACTION'],\n  description: 'Submits a new governance proposal using the Polygon WalletProvider.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating PROPOSE_GOVERNANCE_POLYGON action...');\n    const checks = [\n      runtime.getSetting('WALLET_PRIVATE_KEY'),\n      runtime.getSetting('POLYGON_PLUGINS_ENABLED'),\n    ];\n    if (checks.some((check) => !check)) {\n      logger.error(\n        'Required settings (WALLET_PRIVATE_KEY, POLYGON_PLUGINS_ENABLED) are not configured.'\n      );\n      return false;\n    }\n    try {\n      await initWalletProvider(runtime);\n    } catch (e) {\n      const errMsg = e instanceof Error ? e.message : String(e);\n      logger.error(`WalletProvider initialization failed during validation: ${errMsg}`);\n      return false;\n    }\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    logger.info('Handling PROPOSE_GOVERNANCE_POLYGON for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let extractedParams: (Partial<ProposeGovernanceParams> & { error?: string }) | null = null;\n\n    try {\n      const walletProvider = await initWalletProvider(runtime);\n      const actionRunner = new PolygonProposeGovernanceActionRunner(walletProvider);\n\n      const prompt = composePromptFromState({\n        state,\n        template: proposeGovernanceActionTemplate,\n      });\n\n      const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n\n      try {\n        const parsed = parseJSONObjectFromText(modelResponse);\n        if (parsed) {\n          extractedParams = parsed as Partial<ProposeGovernanceParams> & {\n            error?: string;\n          };\n        }\n        logger.debug(\n          'PROPOSE_GOVERNANCE_POLYGON: Extracted params via TEXT_SMALL:',\n          extractedParams\n        );\n\n        if (extractedParams?.error) {\n          logger.warn(\n            `PROPOSE_GOVERNANCE_POLYGON: Model responded with error: ${extractedParams.error}`\n          );\n          throw new Error(extractedParams.error);\n        }\n      } catch (e: unknown) {\n        const errorMsg = e instanceof Error ? e.message : String(e);\n        logger.warn(\n          `PROPOSE_GOVERNANCE_POLYGON: Failed to parse JSON from model response or model returned error (Proceeding to manual extraction): ${errorMsg}`\n        );\n      }\n\n      // If model failed, or returned an error (which would make extractedParams null or have an error), or is incomplete:\n      if (\n        !extractedParams ||\n        extractedParams.error ||\n        !extractedParams.chain ||\n        !extractedParams.governorAddress ||\n        !extractedParams.targets ||\n        !extractedParams.values ||\n        !extractedParams.calldatas ||\n        !extractedParams.description\n      ) {\n        logger.info(\n          'PROPOSE_GOVERNANCE_POLYGON: Model extraction insufficient, attempting manual parameter extraction from text.'\n        );\n        const manualParams = extractProposeGovernanceParamsFromText(rawMessageText);\n\n        // If model gave partial valid params, merge with manual. Otherwise, use manual.\n        // Prioritize manually extracted fields if model fields are missing.\n        if (extractedParams && !extractedParams.error) {\n          extractedParams = {\n            chain: extractedParams.chain || manualParams.chain,\n            governorAddress: extractedParams.governorAddress || manualParams.governorAddress,\n            targets:\n              extractedParams.targets && extractedParams.targets.length > 0\n                ? extractedParams.targets\n                : manualParams.targets,\n            values:\n              extractedParams.values && extractedParams.values.length > 0\n                ? extractedParams.values\n                : manualParams.values,\n            calldatas:\n              extractedParams.calldatas && extractedParams.calldatas.length > 0\n                ? extractedParams.calldatas\n                : manualParams.calldatas,\n            description: extractedParams.description || manualParams.description,\n          };\n        } else {\n          extractedParams = manualParams;\n        }\n        logger.debug(\n          'PROPOSE_GOVERNANCE_POLYGON: Params after manual extraction attempt:',\n          extractedParams\n        );\n      }\n\n      // Final validation of parameters\n      if (\n        !extractedParams?.chain ||\n        !extractedParams.governorAddress ||\n        !extractedParams.targets ||\n        !(extractedParams.targets.length > 0) || // Ensure targets is not empty\n        !extractedParams.values ||\n        !(extractedParams.values.length > 0) || // Ensure values is not empty\n        !extractedParams.calldatas ||\n        !(extractedParams.calldatas.length > 0) || // Ensure calldatas is not empty\n        !extractedParams.description\n      ) {\n        logger.error(\n          'PROPOSE_GOVERNANCE_POLYGON: Incomplete parameters after all extraction attempts.',\n          extractedParams\n        );\n        throw new Error(\n          'Incomplete or invalid proposal parameters extracted after all attempts. Required: chain, governorAddress, targets, values, calldatas, description.'\n        );\n      }\n\n      // Type assertion because we've validated all fields\n      const proposeParams = extractedParams as ProposeGovernanceParams;\n\n      logger.debug('Propose governance parameters for runner:', proposeParams);\n      const txResult = await actionRunner.propose(proposeParams);\n\n      let successMsg = `Proposed governance action on ${proposeParams.chain} to ${proposeParams.governorAddress}. Desc: \"${proposeParams.description}\". TxHash: ${txResult.hash}.`;\n      if (txResult.proposalId) {\n        successMsg += ` Proposal ID: ${txResult.proposalId}`;\n      }\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: { success: true, ...txResult },\n          actions: ['PROPOSE_GOVERNANCE_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: true, ...txResult };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in PROPOSE_GOVERNANCE_POLYGON handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error proposing governance action: ${errMsg}`,\n          actions: ['PROPOSE_GOVERNANCE_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Propose on polygon to governor 0x123 targets [0x456] values [0] calldatas [0x789] with description \"Test proposal\"',\n        },\n      },\n      {\n        name: 'user',\n        content: {\n          text: \"Create a new proposal. Chain: polygon. Governor: 0xabc. Targets: [0xdef]. Values: ['0']. Calldatas: ['0xghi']. Description: Hello world.\",\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  type ActionExample,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { encodeFunctionData, type Address, type Chain, type Hex, type Log } from 'viem';\nimport { type WalletProvider, initWalletProvider } from '../providers/PolygonWalletProvider';\nimport { voteGovernanceActionTemplate } from '../templates'; // Import the new template\n\n// Minimal ABI for OZ Governor castVote function\nconst governorVoteAbi = [\n  {\n    inputs: [\n      { name: 'proposalId', type: 'uint256' },\n      { name: 'support', type: 'uint8' }, // 0 = Against, 1 = For, 2 = Abstain\n      // { name: 'reason', type: 'string' }, // For castVoteWithReason (optional)\n    ],\n    name: 'castVote', // or castVoteWithReason\n    outputs: [], // Typically returns a boolean success or nothing, tx receipt is key\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\n// ABI for castVoteWithReason (if you intend to support it)\nconst governorVoteWithReasonAbi = [\n  {\n    inputs: [\n      { name: 'proposalId', type: 'uint256' },\n      { name: 'support', type: 'uint8' },\n      { name: 'reason', type: 'string' },\n    ],\n    name: 'castVoteWithReason',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n] as const;\n\ninterface VoteGovernanceParams {\n  chain: string;\n  governorAddress: Address;\n  proposalId: string; // string for LLM, convert to BigInt for tx\n  support: number; // 0, 1, or 2\n  reason?: string; // Optional\n}\n\ninterface VoteTransaction {\n  hash: `0x${string}`;\n  from: `0x${string}`;\n  to: `0x${string}`;\n  value: bigint;\n  chainId: number;\n  data?: Hex;\n  logs?: Log[];\n  proposalId: string; // Keep as string from params for consistency\n  support: number;\n  reason?: string;\n}\n\n// Helper function to extract params from text\nfunction extractVoteGovernanceParamsFromText(text: string): Partial<VoteGovernanceParams> {\n  const params: Partial<VoteGovernanceParams> = {};\n  logger.debug(`Attempting to extract VoteGovernanceParams from text: \"${text}\"`);\n\n  const chainMatch = text.match(/\\b(?:on\\s+|chain\\s*[:\\-]?\\s*)(\\w+)/i);\n  if (chainMatch?.[1]) params.chain = chainMatch[1].toLowerCase();\n\n  const governorMatch = text.match(/\\b(?:governor\\s*(?:address\\s*)?[:\\-]?\\s*)(0x[a-fA-F0-9]{40})/i);\n  if (governorMatch?.[1]) params.governorAddress = governorMatch[1] as Address;\n\n  const proposalIdMatch = text.match(/\\b(?:proposal\\s*id|prop\\s*id)\\s*[:\\-]?\\s*([\\w\\d\\-]+)/i); // Allow hex, numbers, or GUID-like\n  if (proposalIdMatch?.[1]) params.proposalId = proposalIdMatch[1];\n\n  // Support: 0 (Against), 1 (For), 2 (Abstain)\n  // Look for keywords like \"for\", \"yes\", \"against\", \"no\", \"abstain\"\n  // Or numbers 0, 1, 2\n  const supportForMatch = text.match(/\\b(?:vote|support|option)\\s*[:\\-]?\\s*(for|yes|aye)\\b/i);\n  const supportAgainstMatch = text.match(\n    /\\b(?:vote|support|option)\\s*[:\\-]?\\s*(against|no|nay)\\b/i\n  );\n  const supportAbstainMatch = text.match(/\\b(?:vote|support|option)\\s*[:\\-]?\\s*(abstain)\\b/i);\n  const supportNumericMatch = text.match(/\\b(?:vote|support|option)\\s*[:\\-]?\\s*([012])\\b/i);\n\n  if (supportForMatch) params.support = 1;\n  else if (supportAgainstMatch) params.support = 0;\n  else if (supportAbstainMatch) params.support = 2;\n  else if (supportNumericMatch?.[1]) params.support = Number.parseInt(supportNumericMatch[1], 10);\n\n  const reasonMatch = text.match(\n    /\\b(?:reason|rationale)\\s*[:\\-]?\\s*(?:['\"](.+?)['\"]|(.+?)(?:\\s*\\b(?:chain|governor|proposalId|support)\\b|$))/i\n  );\n  if (reasonMatch) {\n    params.reason = (reasonMatch[1] || reasonMatch[2])?.trim();\n  }\n\n  logger.debug('Manually extracted VoteGovernanceParams:', params);\n  return params;\n}\n\nclass PolygonVoteGovernanceActionRunner {\n  constructor(private walletProvider: WalletProvider) {}\n\n  async vote(params: VoteGovernanceParams): Promise<VoteTransaction> {\n    const walletClient = this.walletProvider.getWalletClient(params.chain);\n    const publicClient = this.walletProvider.getPublicClient(params.chain);\n    const chainConfig = this.walletProvider.getChainConfigs(params.chain);\n\n    if (!walletClient.account) {\n      throw new Error('Wallet client account is not available.');\n    }\n    const senderAddress = walletClient.account.address;\n\n    const proposalIdBigInt = BigInt(params.proposalId); // Convert proposalId to BigInt\n\n    let txData: Hex;\n    if (params.reason && params.reason.trim() !== '') {\n      txData = encodeFunctionData({\n        abi: governorVoteWithReasonAbi,\n        functionName: 'castVoteWithReason',\n        args: [proposalIdBigInt, params.support, params.reason],\n      });\n    } else {\n      txData = encodeFunctionData({\n        abi: governorVoteAbi,\n        functionName: 'castVote',\n        args: [proposalIdBigInt, params.support],\n      });\n    }\n\n    try {\n      logger.debug(\n        `Voting on chain ${params.chain}, governor ${params.governorAddress}, proposal ${params.proposalId}, support ${params.support}, reason: \"${params.reason || ''}\"`\n      );\n      const kzg = {\n        blobToKzgCommitment: (_blob: unknown) => {\n          throw new Error('KZG not impl.');\n        },\n        computeBlobKzgProof: (_blob: unknown, _commit: unknown) => {\n          throw new Error('KZG not impl.');\n        },\n      };\n      const hash = await walletClient.sendTransaction({\n        account: senderAddress,\n        to: params.governorAddress,\n        value: BigInt(0),\n        data: txData,\n        chain: chainConfig as Chain,\n        kzg,\n      });\n\n      logger.info(`Vote transaction sent. Hash: ${hash}. Waiting for receipt...`);\n      const receipt = await publicClient.waitForTransactionReceipt({ hash });\n      logger.debug('Transaction receipt:', receipt);\n\n      return {\n        hash,\n        from: senderAddress,\n        to: params.governorAddress,\n        value: BigInt(0),\n        data: txData,\n        chainId: chainConfig.id,\n        logs: receipt.logs as Log[],\n        proposalId: params.proposalId,\n        support: params.support,\n        reason: params.reason,\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error(`Governance vote failed: ${errMsg}`, error);\n      throw new Error(`Governance vote failed: ${errMsg}`);\n    }\n  }\n}\n\nexport const voteGovernanceAction: Action = {\n  name: 'VOTE_GOVERNANCE_POLYGON',\n  similes: ['CAST_VOTE_POLYGON', 'SUPPORT_PROPOSAL_POLYGON', 'VOTE_ON_PROPOSAL_POLYGON'],\n  description: 'Casts a vote on a governance proposal using the Polygon WalletProvider.',\n\n  validate: async (runtime: IAgentRuntime): Promise<boolean> => {\n    logger.debug('Validating VOTE_GOVERNANCE_POLYGON action...');\n    if (\n      !runtime.getSetting('WALLET_PRIVATE_KEY') ||\n      !runtime.getSetting('POLYGON_PLUGINS_ENABLED')\n    ) {\n      logger.error(\n        'Required settings (WALLET_PRIVATE_KEY, POLYGON_PLUGINS_ENABLED) are not configured.'\n      );\n      return false;\n    }\n    try {\n      await initWalletProvider(runtime);\n    } catch (e) {\n      const errMsg = e instanceof Error ? e.message : String(e);\n      logger.error(`WalletProvider initialization failed during validation: ${errMsg}`);\n      return false;\n    }\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    logger.info('Handling VOTE_GOVERNANCE_POLYGON for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let extractedParams: (Partial<VoteGovernanceParams> & { error?: string }) | null = null;\n\n    try {\n      const walletProvider = await initWalletProvider(runtime);\n      const actionRunner = new PolygonVoteGovernanceActionRunner(walletProvider);\n\n      const prompt = composePromptFromState({\n        state,\n        template: voteGovernanceActionTemplate, // Use the new string template\n      });\n\n      const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n\n      try {\n        const parsed = parseJSONObjectFromText(modelResponse);\n        if (parsed) {\n          extractedParams = parsed as Partial<VoteGovernanceParams> & {\n            error?: string;\n          };\n        }\n        logger.debug('VOTE_GOVERNANCE_POLYGON: Extracted params via TEXT_SMALL:', extractedParams);\n\n        if (extractedParams?.error) {\n          logger.warn(\n            `VOTE_GOVERNANCE_POLYGON: Model responded with error: ${extractedParams.error}`\n          );\n          throw new Error(extractedParams.error);\n        }\n      } catch (e: unknown) {\n        const errorMsg = e instanceof Error ? e.message : String(e);\n        logger.warn(\n          `VOTE_GOVERNANCE_POLYGON: Failed to parse JSON from model response or model returned error (Proceeding to manual extraction): ${errorMsg}`\n        );\n      }\n\n      if (\n        !extractedParams ||\n        extractedParams.error ||\n        !extractedParams.chain ||\n        !extractedParams.governorAddress ||\n        extractedParams.proposalId === undefined ||\n        extractedParams.support === undefined // Support can be 0\n      ) {\n        logger.info(\n          'VOTE_GOVERNANCE_POLYGON: Model extraction insufficient or failed, attempting manual parameter extraction.'\n        );\n        const manualParams = extractVoteGovernanceParamsFromText(rawMessageText);\n\n        if (extractedParams && !extractedParams.error) {\n          extractedParams = {\n            chain: extractedParams.chain || manualParams.chain,\n            governorAddress: extractedParams.governorAddress || manualParams.governorAddress,\n            proposalId: extractedParams.proposalId || manualParams.proposalId,\n            support:\n              extractedParams.support !== undefined\n                ? extractedParams.support\n                : manualParams.support, // Check for undefined explicitly for support\n            reason: extractedParams.reason || manualParams.reason,\n          };\n        } else {\n          extractedParams = manualParams;\n        }\n        logger.debug(\n          'VOTE_GOVERNANCE_POLYGON: Params after manual extraction attempt:',\n          extractedParams\n        );\n      }\n\n      if (\n        !extractedParams?.chain ||\n        !extractedParams.governorAddress ||\n        extractedParams.proposalId === undefined || // Check for undefined\n        typeof extractedParams.support !== 'number' || // Check for number type and range\n        ![0, 1, 2].includes(extractedParams.support)\n      ) {\n        logger.error(\n          'VOTE_GOVERNANCE_POLYGON: Incomplete or invalid parameters after all extraction attempts.',\n          extractedParams\n        );\n        throw new Error(\n          'Incomplete or invalid vote parameters: chain, governorAddress, proposalId, and support (0, 1, or 2) are required.'\n        );\n      }\n\n      const voteParams = extractedParams as VoteGovernanceParams;\n\n      logger.debug('Vote governance parameters for runner:', voteParams);\n      const txResult = await actionRunner.vote(voteParams);\n\n      const successMsg = `Successfully voted on proposal ${voteParams.proposalId} on chain ${voteParams.chain} for governor ${voteParams.governorAddress}. Support: ${voteParams.support}. TxHash: ${txResult.hash}.`;\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: { success: true, ...txResult },\n          actions: ['VOTE_GOVERNANCE_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: true, ...txResult };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in VOTE_GOVERNANCE_POLYGON handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error voting on proposal: ${errMsg}`,\n          actions: ['VOTE_GOVERNANCE_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Vote FOR proposal 123 on Polygon governor 0xGov. Chain: polygon.',\n        },\n      },\n      {\n        name: 'user',\n        content: {\n          text: 'Support proposal 0xPropId with option 1 on governor 0xGovAddress for ethereum chain.',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger as coreLogger,\n  composePromptFromState,\n  ModelType,\n  type TemplateType,\n} from '@elizaos/core';\nimport { formatUnits } from 'viem'; // Changed from ethers to viem\nimport { PolygonRpcService, ValidatorStatus } from '../services/PolygonRpcService';\nimport {\n  ValidationError,\n  ServiceError,\n  ContractError,\n  formatErrorMessage,\n  parseErrorMessage,\n} from '../errors';\nimport { getValidatorInfoTemplate } from '../templates';\n\n// Define input schema for the LLM-extracted parameters\ninterface ValidatorParams {\n  validatorId: number;\n  error?: string; // To catch error messages from LLM\n}\n\n// Helper function to attempt extraction of validator ID from text or XML\nasync function attemptParamExtraction(responseText: string): Promise<ValidatorParams> {\n  coreLogger.debug('Raw responseText for extraction:', responseText);\n\n  // First try to extract as JSON\n  try {\n    // Look for JSON code blocks\n    const jsonMatch = responseText.match(/```(?:json)?\\s*({[\\s\\S]*?})\\s*```/);\n    if (jsonMatch?.[1]) {\n      const params = JSON.parse(jsonMatch[1]);\n      coreLogger.debug(`Extracted params from JSON code block: ${JSON.stringify(params)}`);\n      return params;\n    }\n\n    // Try JSON without code blocks\n    if (responseText.trim().startsWith('{') && responseText.trim().endsWith('}')) {\n      const params = JSON.parse(responseText.trim());\n      coreLogger.debug(`Extracted params from plain JSON: ${JSON.stringify(params)}`);\n      return params;\n    }\n  } catch (jsonError) {\n    coreLogger.debug('Failed to parse as JSON, trying direct extraction');\n  }\n\n  // Direct approach - look for validator number mentions anywhere in the text\n  const validatorPattern = /validator\\s+(?:id\\s+)?(\\d+)|validator[^\\d]*?(\\d+)|validator.*?(\\d+)/i;\n  const validatorMatch = responseText.match(validatorPattern);\n\n  coreLogger.debug('Validator match:', validatorMatch);\n\n  if (validatorMatch) {\n    // Find the first non-undefined group (the actual number)\n    const numberGroup = validatorMatch.slice(1).find((g) => g !== undefined);\n    if (numberGroup) {\n      const validatorId = Number.parseInt(numberGroup, 10);\n      coreLogger.debug(`Extracted validatorId ${validatorId} from text pattern match`);\n      return { validatorId };\n    }\n  }\n\n  // Last resort: extract any number from the text as a potential validator ID\n  const anyNumberMatch = responseText.match(/\\b(\\d+)\\b/);\n  if (anyNumberMatch?.[1]) {\n    const validatorId = Number.parseInt(anyNumberMatch[1], 10);\n    coreLogger.debug(`Found potential validatorId ${validatorId} from text as last resort`);\n    return { validatorId };\n  }\n\n  throw new ValidationError('Could not extract validator ID from response');\n}\n\nexport const getValidatorInfoAction: Action = {\n  name: 'GET_VALIDATOR_INFO',\n  similes: ['QUERY_VALIDATOR', 'VALIDATOR_DETAILS', 'GET_L1_VALIDATOR_INFO'],\n  description: 'Retrieves information about a specific Polygon validator.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    coreLogger.debug('Validating GET_VALIDATOR_INFO action...');\n\n    // Check for required settings\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for validator info\n      'POLYGON_RPC_URL', // L2 RPC for completeness\n      'POLYGON_PLUGINS_ENABLED',\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        coreLogger.error(\n          `Required setting ${setting} not configured for GET_VALIDATOR_INFO action.`\n        );\n        return false;\n      }\n    }\n\n    // Verify PolygonRpcService is available\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        throw new ServiceError('PolygonRpcService not initialized', 'PolygonRpcService');\n      }\n    } catch (error: unknown) {\n      const errorMsg = parseErrorMessage(error);\n      coreLogger.error('Error accessing PolygonRpcService during validation:', error);\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    coreLogger.info('Handling GET_VALIDATOR_INFO action for message:', message.id);\n\n    try {\n      // Get the PolygonRpcService\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new ServiceError('PolygonRpcService not available', 'PolygonRpcService');\n      }\n\n      // Extract parameters using template prompt\n      const prompt = composePromptFromState({\n        state,\n        template: getValidatorInfoTemplate,\n      });\n\n      let params: ValidatorParams;\n\n      try {\n        // First try using OBJECT_LARGE model type for structured output\n        try {\n          // The plugin-evm approach is to directly use ModelType.OBJECT_LARGE\n          // and handle any potential errors in the catch block\n          params = (await runtime.useModel(ModelType.OBJECT_LARGE, {\n            prompt,\n          })) as ValidatorParams;\n          coreLogger.debug('[GET_VALIDATOR_INFO_ACTION] Parsed LLM parameters:', params);\n\n          // Check if the model returned an error field\n          if (params.error) {\n            throw new ValidationError(params.error);\n          }\n        } catch (error) {\n          // If OBJECT_LARGE fails, fall back to TEXT_LARGE\n          coreLogger.debug(\n            '[GET_VALIDATOR_INFO_ACTION] OBJECT_LARGE model failed, falling back to TEXT_LARGE',\n            error instanceof Error ? error : undefined\n          );\n\n          const responseText = await runtime.useModel(ModelType.LARGE, {\n            prompt,\n          });\n          coreLogger.debug('[GET_VALIDATOR_INFO_ACTION] Raw text response from LLM:', responseText);\n\n          // Extract parameters from text\n          params = await attemptParamExtraction(responseText);\n        }\n\n        // Validate params after extraction\n        if (params.validatorId === undefined) {\n          throw new ValidationError('Validator ID parameter not extracted properly');\n        }\n\n        if (typeof params.validatorId !== 'number' || params.validatorId <= 0) {\n          throw new ValidationError(\n            `Invalid validator ID: ${params.validatorId}. Must be a positive integer.`\n          );\n        }\n\n        coreLogger.debug('Validator parameters:', params);\n      } catch (error: unknown) {\n        const errorMsg = parseErrorMessage(error);\n        coreLogger.error(\n          'Failed to parse LLM response for validator parameters:',\n          error instanceof Error ? error.message : String(error),\n          error\n        );\n\n        const errorContent: Content = {\n          text: formatErrorMessage(\n            'Parameter extraction',\n            'Could not understand validator parameters. Please provide a valid validator ID (number).',\n            errorMsg.details || undefined\n          ),\n          actions: ['GET_VALIDATOR_INFO'],\n          source: message.content?.source,\n          data: {\n            success: false,\n            error: 'Invalid validator ID parameter',\n          },\n          success: false,\n        };\n\n        if (callback) {\n          await callback(errorContent);\n        }\n        return errorContent;\n      }\n\n      // Get validator information\n      try {\n        const validatorInfo = await polygonService.getValidatorInfo(params.validatorId);\n\n        if (!validatorInfo) {\n          throw new ContractError(\n            `Validator with ID ${params.validatorId} not found or is inactive.`,\n            'STAKE_MANAGER_ADDRESS_L1',\n            'validators'\n          );\n        }\n\n        // Format the validator status as a string\n        const statusLabels = {\n          [ValidatorStatus.Inactive]: 'Inactive',\n          [ValidatorStatus.Active]: 'Active',\n          [ValidatorStatus.Unbonding]: 'Unbonding',\n          [ValidatorStatus.Jailed]: 'Jailed',\n        };\n\n        const statusLabel = statusLabels[validatorInfo.status] || 'Unknown';\n\n        // Format total stake as human-readable MATIC\n        // viem formatUnits takes bigint and number directly, no need for .toString()\n        const totalStakeMatic = formatUnits(validatorInfo.totalStake, 18);\n\n        // Prepare response message\n        const responseMsg = `Validator #${params.validatorId} Info:\n- Status: ${statusLabel}\n- Total Staked: ${totalStakeMatic} MATIC\n- Commission Rate: ${validatorInfo.commissionRate * 100}%\n- Signer Address: ${validatorInfo.signerAddress}\n- Contract Address: ${validatorInfo.contractAddress}`;\n\n        coreLogger.info(`Retrieved validator info for validator ID ${params.validatorId}`);\n\n        // Format the response content\n        const responseContent: Content = {\n          text: responseMsg,\n          actions: ['GET_VALIDATOR_INFO'],\n          source: message.content.source,\n          data: {\n            validatorId: params.validatorId,\n            validator: {\n              ...validatorInfo,\n              status: statusLabel,\n              totalStake: validatorInfo.totalStake.toString(),\n              totalStakeFormatted: totalStakeMatic,\n              activationEpoch: validatorInfo.activationEpoch.toString(),\n              deactivationEpoch: validatorInfo.deactivationEpoch.toString(),\n              jailEndEpoch: validatorInfo.jailEndEpoch.toString(),\n              lastRewardUpdateEpoch: validatorInfo.lastRewardUpdateEpoch.toString(),\n            },\n          },\n        };\n\n        if (callback) {\n          await callback(responseContent);\n        }\n        return responseContent;\n      } catch (error: unknown) {\n        const errorMsg = parseErrorMessage(error);\n        coreLogger.error(\n          `Error getting validator info: ${errorMsg.message}`,\n          error instanceof Error ? error : undefined\n        );\n\n        const errorContent: Content = {\n          text: formatErrorMessage(\n            'Validator info retrieval',\n            `Failed to get validator #${params.validatorId} info from Ethereum L1`\n          ),\n          actions: ['GET_VALIDATOR_INFO'],\n          source: message.content?.source,\n          data: {\n            success: false,\n            error: `Failed to retrieve validator ${params.validatorId} info: ${errorMsg.message}`,\n            STAKE_MANAGER_ADDRESS_L1: true,\n            method: 'validators',\n          },\n          success: false,\n        };\n\n        if (callback) {\n          await callback(errorContent);\n        }\n        return errorContent;\n      }\n    } catch (error: unknown) {\n      const parsedErrorObj = parseErrorMessage(error);\n      coreLogger.error(`Error in GET_VALIDATOR_INFO handler: ${parsedErrorObj.message}`);\n\n      if (parsedErrorObj.details) {\n        coreLogger.error(`Details: ${parsedErrorObj.details}`);\n      }\n\n      if (error instanceof Error) {\n        coreLogger.error('Original error object for stack trace:', error);\n      } else if (typeof error === 'object' && error !== null) {\n        // If it was an object but not an Error instance, and we haven't logged details yet\n        // or want to see the full object structure.\n        if (!parsedErrorObj.details) {\n          coreLogger.error('Raw error object (stringified):', JSON.stringify(error));\n        }\n      }\n\n      const formattedError = formatErrorMessage(\n        'GET_VALIDATOR_INFO',\n        parsedErrorObj.message,\n        parsedErrorObj.details || undefined\n      );\n\n      const errorContent: Content = {\n        text: `Error retrieving validator information: ${formattedError}`,\n        actions: ['GET_VALIDATOR_INFO'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: formattedError,\n        },\n        success: false,\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Show details for Polygon validator 123',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'What is the commission rate of validator ID 42?',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Tell me about validator #56 on Polygon',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger as coreLogger,\n  composePromptFromState,\n  ModelType,\n} from '@elizaos/core';\nimport { formatUnits, Wallet } from 'ethers';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { getDelegatorInfoTemplate } from '../templates';\nimport { ValidationError, ServiceError, formatErrorMessage, parseErrorMessage } from '../errors';\n\n// Define input schema for the LLM-extracted parameters (matches JSON output from template)\ninterface DelegatorParams {\n  validatorId?: number; // Make optional to catch errors from LLM more gracefully\n  delegatorAddress?: string;\n  error?: string; // To catch error messages from LLM\n}\n\nexport const getDelegatorInfoAction: Action = {\n  name: 'GET_DELEGATOR_INFO',\n  similes: ['QUERY_STAKE', 'DELEGATOR_DETAILS', 'GET_MY_STAKE', 'GET_L1_DELEGATOR_INFO'],\n  description:\n    'Retrieves staking information for a specific delegator address (defaults to agent wallet).',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    coreLogger.debug('Validating GET_DELEGATOR_INFO action...');\n\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL',\n      'POLYGON_RPC_URL',\n      'POLYGON_PLUGINS_ENABLED',\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        coreLogger.error(\n          `Required setting ${setting} not configured for GET_DELEGATOR_INFO action.`\n        );\n        return false;\n      }\n    }\n\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        coreLogger.error('PolygonRpcService not initialized.');\n        return false;\n      }\n    } catch (error: unknown) {\n      coreLogger.error('Error accessing PolygonRpcService during validation:', error);\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    coreLogger.info('Handling GET_DELEGATOR_INFO action for message:', message.id);\n\n    try {\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new ServiceError('PolygonRpcService not available', PolygonRpcService.serviceType);\n      }\n\n      const prompt = composePromptFromState({\n        state,\n        template: getDelegatorInfoTemplate,\n      });\n\n      let params: DelegatorParams;\n\n      try {\n        // First try using OBJECT_LARGE model type for structured output\n        try {\n          // The plugin-evm approach is to directly use ModelType.OBJECT_LARGE\n          // and handle any potential errors in the catch block\n          params = (await runtime.useModel(ModelType.OBJECT_LARGE, {\n            prompt,\n          })) as DelegatorParams;\n          coreLogger.debug('[GET_DELEGATOR_INFO_ACTION] Parsed LLM parameters:', params);\n\n          // Check if the model returned an error field\n          if (params.error) {\n            coreLogger.error('[GET_DELEGATOR_INFO_ACTION] LLM returned an error:', params.error);\n            throw new ValidationError(params.error);\n          }\n        } catch (error) {\n          // If OBJECT_LARGE fails, fall back to TEXT_LARGE and manual parsing\n          coreLogger.debug(\n            '[GET_DELEGATOR_INFO_ACTION] OBJECT_LARGE model failed, falling back to TEXT_LARGE and manual parsing',\n            error instanceof Error ? error : undefined\n          );\n\n          const textResponse = await runtime.useModel(ModelType.LARGE, {\n            prompt,\n          });\n          coreLogger.debug('[GET_DELEGATOR_INFO_ACTION] Raw text response from LLM:', textResponse);\n\n          params = await extractParamsFromText(textResponse);\n        }\n\n        // Validate the extracted parameters\n        if (\n          typeof params.validatorId !== 'number' ||\n          params.validatorId <= 0 ||\n          !Number.isInteger(params.validatorId)\n        ) {\n          coreLogger.error(\n            '[GET_DELEGATOR_INFO_ACTION] Invalid or missing validatorId from LLM:',\n            params.validatorId\n          );\n          throw new ValidationError(\n            `Validator ID not found or invalid. Received: ${params.validatorId}. Please provide a positive integer. `\n          );\n        }\n\n        const validatorId = params.validatorId;\n        let delegatorAddress = params.delegatorAddress;\n\n        if (!delegatorAddress) {\n          const privateKey = runtime.getSetting('PRIVATE_KEY');\n          if (!privateKey) {\n            throw new ServiceError(\n              'Private key not available to determine agent wallet address.',\n              'PRIVATE_KEY'\n            );\n          }\n          const wallet = new Wallet(privateKey);\n          delegatorAddress = wallet.address;\n          coreLogger.info(\n            `[GET_DELEGATOR_INFO_ACTION] No delegatorAddress provided, using agent's wallet: ${delegatorAddress}`\n          );\n        }\n\n        coreLogger.info(\n          `GET_DELEGATOR_INFO: Fetching info for V:${validatorId} / D:${delegatorAddress}...`\n        );\n\n        const delegatorInfo = await polygonService.getDelegatorInfo(validatorId, delegatorAddress);\n\n        if (!delegatorInfo) {\n          const notFoundMsg = `No delegation found for address ${delegatorAddress} with validator ID ${validatorId}.`;\n          coreLogger.warn(notFoundMsg);\n          throw new ValidationError(notFoundMsg);\n        }\n\n        const delegatedMatic = formatUnits(delegatorInfo.delegatedAmount, 18);\n        const pendingRewardsMatic = formatUnits(delegatorInfo.pendingRewards, 18);\n\n        const responseMsg = `Delegation Info for address ${delegatorAddress} with validator ${validatorId}:\\n- Delegated Amount: ${delegatedMatic} MATIC\\n- Pending Rewards: ${pendingRewardsMatic} MATIC`;\n\n        coreLogger.info(`Retrieved delegator info for V:${validatorId} / D:${delegatorAddress}`);\n\n        const responseContent: Content = {\n          text: responseMsg,\n          actions: ['GET_DELEGATOR_INFO'],\n          source: message.content.source,\n          data: {\n            validatorId,\n            delegatorAddress,\n            delegation: {\n              delegatedAmount: delegatorInfo.delegatedAmount.toString(),\n              delegatedAmountFormatted: delegatedMatic,\n              pendingRewards: delegatorInfo.pendingRewards.toString(),\n              pendingRewardsFormatted: pendingRewardsMatic,\n            },\n            success: true,\n          },\n          success: true,\n        };\n\n        if (callback) {\n          await callback(responseContent);\n        }\n        return responseContent;\n      } catch (error: unknown) {\n        const parsedErrorObj = parseErrorMessage(error);\n        coreLogger.error(\n          'Error in GET_DELEGATOR_INFO handler:',\n          parsedErrorObj.message,\n          error instanceof Error ? error : parsedErrorObj\n        );\n\n        const formattedError = formatErrorMessage('GET_DELEGATOR_INFO', parsedErrorObj.message);\n\n        const errorContent: Content = {\n          text: `Error retrieving delegator information: ${formattedError}`,\n          actions: ['GET_DELEGATOR_INFO'],\n          source: message.content.source,\n          data: {\n            success: false,\n            error: formattedError,\n          },\n          success: false,\n        };\n\n        if (callback) {\n          await callback(errorContent);\n        }\n        return errorContent;\n      }\n    } catch (error: unknown) {\n      const parsedErrorObj = parseErrorMessage(error);\n      coreLogger.error(\n        'Error in GET_DELEGATOR_INFO handler:',\n        parsedErrorObj.message,\n        error instanceof Error ? error : parsedErrorObj\n      );\n\n      const formattedError = formatErrorMessage(\n        'GET_DELEGATOR_INFO',\n        parsedErrorObj.message,\n        parsedErrorObj.details || undefined\n      );\n\n      const errorContent: Content = {\n        text: `Error retrieving delegator information: ${formattedError}`,\n        actions: ['GET_DELEGATOR_INFO'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: formattedError,\n        },\n        success: false,\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Show my delegation details for validator 123',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'How much is address 0x1234... delegating to validator 42?',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Check my pending rewards from validator 56',\n        },\n      },\n    ],\n  ],\n};\n\n// Helper function to extract parameters from text response (including XML format)\nasync function extractParamsFromText(responseText: string): Promise<DelegatorParams> {\n  coreLogger.debug('Raw responseText:', responseText);\n\n  // First try to extract as JSON\n  try {\n    // Look for JSON code blocks\n    const jsonMatch = responseText.match(/```(?:json)?\\s*({[\\s\\S]*?})\\s*```/);\n    if (jsonMatch?.[1]) {\n      const result = JSON.parse(jsonMatch[1]);\n      coreLogger.debug('Extracted from JSON block:', result);\n      return result;\n    }\n\n    // Look for plain JSON\n    if (responseText.trim().startsWith('{') && responseText.trim().endsWith('}')) {\n      const result = JSON.parse(responseText);\n      coreLogger.debug('Extracted from plain JSON:', result);\n      return result;\n    }\n  } catch (jsonError) {\n    coreLogger.debug('Could not parse response as JSON', jsonError);\n  }\n\n  // Direct approach: look for validator numbers and addresses\n  // Look for any mention of validator followed by a number\n  const validatorPattern = /validator\\s+(?:id\\s+)?(\\d+)|validator[^\\d]*?(\\d+)|validator.*?(\\d+)/i;\n  const validatorMatch = responseText.match(validatorPattern);\n\n  // Look for Ethereum addresses\n  const addressPattern = /(0x[a-fA-F0-9]{40})/i;\n  const addressMatch = responseText.match(addressPattern);\n\n  coreLogger.debug('Validator match:', validatorMatch);\n  coreLogger.debug('Address match:', addressMatch);\n\n  const params: DelegatorParams = {};\n\n  // Extract validator ID from any of the captured groups\n  if (validatorMatch) {\n    // Find the first non-undefined group (the actual number)\n    const numberGroup = validatorMatch.slice(1).find((g) => g !== undefined);\n    if (numberGroup) {\n      params.validatorId = Number.parseInt(numberGroup, 10);\n      coreLogger.debug(`Extracted validatorId ${params.validatorId} from text`);\n    }\n  }\n\n  if (addressMatch?.[1]) {\n    params.delegatorAddress = addressMatch[1];\n    coreLogger.debug(`Extracted delegatorAddress ${params.delegatorAddress} from text`);\n  }\n\n  // If we managed to extract a validator ID, return the params\n  if (params.validatorId) {\n    return params;\n  }\n\n  // Last resort: extract any number from the text as a potential validator ID\n  const anyNumberMatch = responseText.match(/\\b(\\d+)\\b/);\n  if (anyNumberMatch?.[1]) {\n    const potentialId = Number.parseInt(anyNumberMatch[1], 10);\n    coreLogger.debug(`Extracted potential validatorId ${potentialId} from text as last resort`);\n    return { validatorId: potentialId };\n  }\n\n  // If we can't extract parameters\n  return {\n    error: 'Could not extract validator ID from the response. Please provide a valid validator ID.',\n  };\n}\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { withdrawRewardsTemplate } from '../templates';\nimport { parseErrorMessage } from '../errors';\n\n// Define input schema for the LLM-extracted parameters\ninterface WithdrawRewardsParams {\n  validatorId?: number;\n  error?: string;\n}\n\n// Helper function to extract params from text if LLM fails\nfunction extractParamsFromText(text: string): Partial<WithdrawRewardsParams> {\n  const params: Partial<WithdrawRewardsParams> = {};\n\n  // Extract validator ID (positive integer)\n  const validatorIdMatch = text.match(/validator(?: id)?\\\\s*[:#]?\\\\s*(\\\\d+)/i);\n  if (validatorIdMatch?.[1]) {\n    const id = Number.parseInt(validatorIdMatch[1], 10);\n    if (id > 0) {\n      params.validatorId = id;\n    }\n  }\n\n  return params;\n}\n\nexport const withdrawRewardsAction: Action = {\n  name: 'WITHDRAW_REWARDS_L1',\n  similes: ['CLAIM_L1_STAKING_REWARDS', 'COLLECT_VALIDATOR_REWARDS_L1'],\n  description: 'Withdraws accumulated staking rewards from a Polygon validator on Ethereum L1.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating WITHDRAW_REWARDS_L1 action...');\n\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for rewards withdrawal\n      'POLYGON_PLUGINS_ENABLED',\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(`Required setting ${setting} not configured for WITHDRAW_REWARDS_L1 action.`);\n        return false;\n      }\n    }\n\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized for WITHDRAW_REWARDS_L1.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error(\n        'Error accessing PolygonRpcService during WITHDRAW_REWARDS_L1 validation:',\n        error\n      );\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _recentMessages: Memory[] | undefined\n  ) => {\n    logger.info('Handling WITHDRAW_REWARDS_L1 action for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let params: WithdrawRewardsParams | null = null;\n\n    try {\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      const prompt = composePromptFromState({\n        state,\n        template: withdrawRewardsTemplate,\n      });\n\n      // Try using parseJSONObjectFromText with TEXT_SMALL model\n      try {\n        const result = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n\n        params = parseJSONObjectFromText(result) as WithdrawRewardsParams;\n        logger.debug('WITHDRAW_REWARDS_L1: Extracted params via TEXT_SMALL:', params);\n\n        // Check if the model response contains an error\n        if (params.error) {\n          logger.warn(`WITHDRAW_REWARDS_L1: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (e) {\n        logger.warn(\n          'WITHDRAW_REWARDS_L1: Failed to parse JSON from model response, trying manual extraction',\n          e\n        );\n\n        // Fallback to manual extraction from raw message text\n        const manualParams = extractParamsFromText(rawMessageText);\n        if (manualParams.validatorId) {\n          params = {\n            validatorId: manualParams.validatorId,\n          };\n          logger.debug('WITHDRAW_REWARDS_L1: Extracted params via manual text parsing:', params);\n        } else {\n          throw new Error('Could not determine validator ID from the message.');\n        }\n      }\n\n      // Validate the extracted parameters\n      if (!params?.validatorId) {\n        throw new Error('Validator ID is missing after extraction attempts.');\n      }\n\n      const { validatorId } = params;\n      logger.debug(`WITHDRAW_REWARDS_L1 parameters: validatorId: ${validatorId}`);\n\n      // Call the service to withdraw rewards\n      const txHash = await polygonService.withdrawRewards(validatorId);\n\n      const successMsg = `Successfully initiated withdrawal of rewards from validator ${validatorId} on L1. Transaction hash: ${txHash}`;\n      logger.info(successMsg);\n\n      const responseContent: Content = {\n        text: successMsg,\n        actions: ['WITHDRAW_REWARDS_L1'],\n        source: message.content.source,\n        data: {\n          transactionHash: txHash,\n          status: 'pending',\n          validatorId: validatorId,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    } catch (error: unknown) {\n      const parsedError = parseErrorMessage(error);\n      logger.error('Error in WITHDRAW_REWARDS_L1 handler:', parsedError);\n\n      const errorContent: Content = {\n        text: `Error withdrawing rewards: ${parsedError.message}`,\n        actions: ['WITHDRAW_REWARDS_L1'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: parsedError.message,\n          details: parsedError.details,\n        },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Withdraw my staking rewards from validator 123',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Claim rewards from Polygon validator ID 42',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  type ActionExample,\n  type TemplateType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport {\n  createConfig,\n  executeRoute,\n  type ExtendedChain,\n  getRoutes,\n  type LiFiStep,\n  type Route,\n  type ChainKey,\n  type RouteExecutionData,\n  type RouteExtended,\n} from '@lifi/sdk';\nimport {\n  createWalletClient,\n  http,\n  type WalletClient,\n  parseEther,\n  type PublicClient,\n  createPublicClient,\n  fallback,\n  type Address,\n  type Hex,\n  type Transport,\n  type Account,\n  type Chain,\n  parseUnits,\n  parseAbi,\n} from 'viem';\nimport { type WalletProvider, initWalletProvider } from '../providers/PolygonWalletProvider';\nimport { bridgeDepositPolygonTemplate } from '../templates';\nimport type { SupportedChain } from '../types';\nimport { EVM } from '@lifi/sdk';\nimport { privateKeyToAccount } from 'viem/accounts';\nimport { arbitrum, mainnet, optimism, polygon, scroll } from 'viem/chains';\n\ninterface BridgeParams {\n  fromChain: string;\n  toChain: string;\n  fromToken: Address;\n  toToken: Address;\n  amount: string;\n  toAddress?: Address;\n}\ninterface Transaction {\n  hash: `0x${string}`;\n  from: Address;\n  to: Address;\n  value: string;\n  valueRaw?: bigint;\n  chainId: number;\n  data?: Hex;\n  logs?: Array<unknown>;\n  error?: string;\n}\n\nconst tokenDecimalsAbi = parseAbi(['function decimals() view returns (uint8)']);\n\nclass PolygonBridgeActionRunner {\n  private config;\n  private walletProvider: WalletProvider;\n\n  constructor(walletProvider: WalletProvider) {\n    this.walletProvider = walletProvider;\n    const extendedChains = Object.values(this.walletProvider.chains).map((chainConfig: Chain) => {\n      const rpcUrls = chainConfig.rpcUrls.custom?.http || chainConfig.rpcUrls.default.http;\n      const blockExplorerUrl = chainConfig.blockExplorers?.default?.url || '';\n\n      return {\n        ...chainConfig,\n        key: chainConfig.name.toLowerCase().replace(/\\s+/g, '-') as ChainKey,\n        chainType: 'EVM',\n        coin: chainConfig.nativeCurrency.symbol,\n        mainnet: !chainConfig.testnet,\n        logoURI: '',\n        diamondAddress: undefined,\n        nativeToken: {\n          address: '0x0000000000000000000000000000000000000000',\n          chainId: chainConfig.id,\n          symbol: chainConfig.nativeCurrency.symbol,\n          decimals: chainConfig.nativeCurrency.decimals,\n          name: chainConfig.nativeCurrency.name,\n          priceUSD: '0',\n          logoURI: '',\n          coinKey: chainConfig.nativeCurrency.symbol,\n        },\n        metamask: {\n          chainId: `0x${chainConfig.id.toString(16)}`,\n          blockExplorerUrls: blockExplorerUrl ? [blockExplorerUrl] : [],\n          chainName: chainConfig.name,\n          nativeCurrency: chainConfig.nativeCurrency,\n          rpcUrls: rpcUrls.slice(),\n        },\n      } as ExtendedChain;\n    });\n\n    const evmProvider = EVM({\n      // Type mismatch with LiFi SDK typings is an issue, using 'as any' as a workaround\n      // This is related to a complex intersection type conflict with the Client type\n      getWalletClient: async () => this.walletProvider.getActiveWalletClient() as any,\n\n      switchChain: async (chainId) => this.walletProvider.switchChainById(chainId) as any,\n    });\n\n    this.config = createConfig({\n      integrator: 'ElizaOS-PolygonPlugin',\n      chains: extendedChains,\n      providers: [evmProvider], //  crucial line\n    });\n  }\n\n  async getTokenDecimals(chainName: string, tokenAddress: Address): Promise<number> {\n    if (\n      tokenAddress.toLowerCase() === '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' ||\n      tokenAddress.toLowerCase() === '0x0000000000000000000000000000000000000000'\n    ) {\n      return this.walletProvider.getChainConfigs(chainName as SupportedChain).nativeCurrency\n        .decimals;\n    }\n    const publicClient = this.walletProvider.getPublicClient(chainName as SupportedChain);\n    try {\n      return await publicClient.readContract({\n        address: tokenAddress,\n        abi: tokenDecimalsAbi,\n        functionName: 'decimals',\n      });\n    } catch (err: unknown) {\n      const errorMessage = err instanceof Error ? err.message : String(err);\n      logger.warn(\n        `Could not fetch decimals for ${tokenAddress} on ${chainName}, defaulting to 18. Error: ${errorMessage}`\n      );\n      return 18;\n    }\n  }\n\n  /**\n   * Helper function to execute a bridge route and immediately return the tx hash\n   * @param route The route to execute\n   * @param onTxHash Callback for when the tx hash is available\n   * @param onDone Callback for when the bridge is complete\n   */\n  private async bridgeAndStream(\n    route: Route,\n    onTxHash: (hash: Hex) => void,\n    onDone?: (execution: RouteExtended) => void,\n    onError?: (error: Error) => void\n  ): Promise<void> {\n    let txHashSent = false;\n\n    try {\n      await executeRoute(route, {\n        // Fires on every status change through updateRouteHook\n        updateRouteHook: (updatedRoute: RouteExtended) => {\n          // Check all steps' execution processes for a txHash\n          for (const step of updatedRoute.steps) {\n            if (step.execution?.process) {\n              for (const process of step.execution.process) {\n                const hash = process.txHash;\n\n                // Return hash as soon as it's available\n                if (!txHashSent && hash) {\n                  txHashSent = true;\n                  logger.info(`Bridge transaction hash available: ${hash}`);\n                  onTxHash(hash as Hex);\n                }\n              }\n            }\n          }\n\n          // Check if the bridge is complete\n          const isComplete = updatedRoute.steps.every(\n            (step) => step.execution?.status === 'DONE' || step.execution?.status === 'FAILED'\n          );\n\n          if (isComplete && onDone) {\n            logger.info(`Bridge operation completed`);\n            onDone(updatedRoute);\n          }\n        },\n      });\n    } catch (error) {\n      // Catch any errors from executeRoute and handle them properly\n      const err = error instanceof Error ? error : new Error(String(error));\n      logger.error('Bridge execution error:', err);\n\n      // Call the error callback if provided\n      if (onError) {\n        onError(err);\n      }\n    }\n  }\n\n  async bridge(params: BridgeParams): Promise<Transaction> {\n    logger.debug('Available chains in WalletProvider:', Object.keys(this.walletProvider.chains));\n    logger.debug(`Attempting to get wallet client for chain: ${params.fromChain}`);\n\n    const walletClient = this.walletProvider.getWalletClient(params.fromChain as SupportedChain);\n    const [fromAddress] = await walletClient.getAddresses();\n\n    // Get token decimals\n    const fromTokenDecimals = await this.getTokenDecimals(params.fromChain, params.fromToken);\n    const amountRaw = parseUnits(params.amount, fromTokenDecimals).toString();\n\n    logger.debug(\n      `Converted ${params.amount} tokens to ${amountRaw} base units using ${fromTokenDecimals} decimals`\n    );\n\n    // Prepare route request\n    const fromChainId = this.walletProvider.getChainConfigs(params.fromChain as SupportedChain).id;\n    const toChainId = this.walletProvider.getChainConfigs(params.toChain as SupportedChain).id;\n\n    const routeRequest = {\n      fromChainId,\n      toChainId,\n      fromTokenAddress: params.fromToken,\n      toTokenAddress: params.toToken,\n      fromAmount: amountRaw,\n      fromAddress,\n      toAddress: params.toAddress || fromAddress,\n    };\n\n    logger.debug('Requesting bridge routes with:', routeRequest);\n\n    try {\n      const routes = await getRoutes(routeRequest);\n\n      if (!routes.routes || routes.routes.length === 0) {\n        logger.error('No routes found for this bridge transaction');\n        throw new Error('No routes found for bridging tokens between these chains');\n      }\n\n      logger.debug(`Found ${routes.routes.length} routes, using the best route`);\n      const bestRoute = routes.routes[0];\n      logger.debug('Best route selected:', JSON.stringify(bestRoute, null, 2));\n\n      // Log estimated gas costs if available\n      if (bestRoute.steps[0]?.estimate?.gasCosts) {\n        logger.debug(\n          'Estimated gas costs:',\n          JSON.stringify(bestRoute.steps[0].estimate.gasCosts, null, 2)\n        );\n      }\n      if (bestRoute.steps[0]?.estimate?.feeCosts) {\n        logger.debug(\n          'Estimated fee costs:',\n          JSON.stringify(bestRoute.steps[0].estimate.feeCosts, null, 2)\n        );\n      }\n\n      logger.debug('Executing bridge route');\n\n      // Use Promise to get transaction hash as soon as it's available\n      const txHashPromise = new Promise<Hex>((resolve, reject) => {\n        // Execute the route but don't wait for completion\n        this.bridgeAndStream(\n          bestRoute,\n          // Called as soon as the hash is available\n          (hash: Hex) => {\n            resolve(hash);\n          },\n          // Called when the bridge is complete (optional)\n          (execution: RouteExtended) => {\n            logger.info(`Bridge operation completed`);\n\n            // You could implement a notification system here to inform\n            // the user when the bridge completes\n          },\n          // Error handler\n          (error: Error) => {\n            logger.error(`Bridge operation failed:`, error);\n            reject(error);\n          }\n        );\n      });\n\n      // Wait for the transaction hash only, not the entire bridge process\n      try {\n        const txHash = await txHashPromise;\n        logger.info(`Returning bridge transaction hash: ${txHash}`);\n\n        // Determine if the token is a native token (ETH, MATIC, etc.)\n        const isNativeToken =\n          params.fromToken.toLowerCase() === '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' ||\n          params.fromToken.toLowerCase() === '0x0000000000000000000000000000000000000000';\n\n        // For native tokens, set value to the parsed amount, otherwise zero\n        const txValue = isNativeToken ? parseUnits(params.amount, fromTokenDecimals) : BigInt(0);\n\n        const tx = {\n          hash: txHash,\n          from: fromAddress,\n          to: bestRoute.steps[0].estimate.approvalAddress as `0x${string}`,\n          value: txValue.toString(),\n          valueRaw: txValue,\n          chainId: fromChainId,\n        };\n\n        const txForLog = { ...tx, valueRaw: tx.valueRaw.toString() };\n\n        logger.debug('Returning transaction:', JSON.stringify(txForLog, null, 2));\n        return tx;\n      } catch (error) {\n        // Catch any errors from the bridgeAndStream process\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error(`Bridge transaction hash retrieval failed: ${errorMessage}`, error);\n\n        // Return a standardized result with the error rather than throwing\n        return {\n          hash: '0x0', // A placeholder hash indicating failure\n          from: fromAddress,\n          to: bestRoute.steps[0].estimate.approvalAddress as `0x${string}`,\n          value: '0',\n          chainId: fromChainId,\n          error: errorMessage,\n        };\n      }\n    } catch (error) {\n      // Catch any errors from the outer getRoutes or initial setup\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error(`Bridge transaction failed: ${errorMessage}`, error);\n\n      // Return a standardized result with the error rather than throwing\n      return {\n        hash: '0x0', // A placeholder hash indicating failure\n        from: '0x0' as Address,\n        to: '0x0' as Address,\n        value: '0',\n        chainId: 0,\n        error: errorMessage,\n      };\n    }\n  }\n}\n\nexport const bridgeDepositAction: Action = {\n  name: 'BRIDGE_DEPOSIT_POLYGON',\n  similes: ['POLYGON_BRIDGE_FUNDS', 'MOVE_ETH_TO_POLYGON_LIFI'],\n  description: 'Initiates a deposit/bridge using LiFi.',\n  validate: async (runtime: IAgentRuntime, _m: Memory, _s: State | undefined): Promise<boolean> => {\n    logger.debug('Validating BRIDGE_DEPOSIT_POLYGON...');\n    const checks = [\n      runtime.getSetting('WALLET_PRIVATE_KEY'),\n      runtime.getSetting('POLYGON_PLUGINS_ENABLED'),\n    ];\n    if (checks.some((check) => !check)) {\n      logger.error('Required settings (WALLET_PRIVATE_KEY, POLYGON_PLUGINS_ENABLED) missing.');\n      return false;\n    }\n    try {\n      await initWalletProvider(runtime);\n    } catch (e) {\n      const errMsg = e instanceof Error ? e.message : String(e);\n      logger.error(`WalletProvider initialization failed during validation: ${errMsg} `);\n      return false;\n    }\n    return true;\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _o: unknown,\n    cb: HandlerCallback | undefined,\n    _rs: Memory[] | undefined\n  ) => {\n    logger.info('Handling BRIDGE_DEPOSIT_POLYGON for:', message.id);\n    try {\n      const walletProvider = await initWalletProvider(runtime);\n      const actionRunner = new PolygonBridgeActionRunner(walletProvider);\n      const prompt = composePromptFromState({\n        state,\n        template: bridgeDepositPolygonTemplate as unknown as TemplateType,\n      });\n      const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n      let paramsJson: BridgeParams | { error: string };\n      let bridgeOptions: BridgeParams;\n      try {\n        paramsJson = parseJSONObjectFromText(modelResponse) as BridgeParams | { error: string };\n        logger.debug('Bridge parameters extracted:', paramsJson);\n\n        // Check if the model response contains an error\n        if ('error' in paramsJson) {\n          logger.warn(`Bridge action: Model responded with error: ${paramsJson.error}`);\n          throw new Error(paramsJson.error);\n        }\n\n        // At this point, paramsJson must be BridgeParams\n        bridgeOptions = paramsJson;\n      } catch (e) {\n        logger.error('Failed to parse LLM response for bridge params:', modelResponse, e);\n        throw new Error('Could not understand bridge parameters.');\n      }\n      if (\n        !bridgeOptions.fromChain ||\n        !bridgeOptions.toChain ||\n        !bridgeOptions.fromToken ||\n        !bridgeOptions.toToken ||\n        !bridgeOptions.amount\n      ) {\n        throw new Error('Incomplete bridge parameters extracted.');\n      }\n\n      logger.debug('Parsed bridge options:', bridgeOptions);\n\n      // Bridge the tokens and get the transaction hash immediately\n      const bridgeResp = await actionRunner.bridge(bridgeOptions);\n\n      // Check if the bridge operation encountered an error\n      if (bridgeResp.error) {\n        logger.error('Bridge operation failed:', bridgeResp.error);\n        throw new Error(bridgeResp.error);\n      }\n\n      // Format source/target chains\n      const fromChainFormatted =\n        bridgeOptions.fromChain.charAt(0).toUpperCase() + bridgeOptions.fromChain.slice(1);\n      const toChainFormatted =\n        bridgeOptions.toChain.charAt(0).toUpperCase() + bridgeOptions.toChain.slice(1);\n\n      // Create a user-friendly message\n      const successMessage = `\nBridging started! \nInitiating transfer of ${bridgeOptions.amount} tokens from ${fromChainFormatted} to ${toChainFormatted}.\nTransaction hash: ${bridgeResp.hash}\n\nThe bridge operation is now in progress and will continue in the background. This may take several minutes to complete. You can check the status by tracking the transaction hash.`;\n\n      logger.info(`Bridge transaction initiated: ${bridgeResp.hash}`);\n\n      if (cb) {\n        await cb({\n          text: successMessage,\n          content: {\n            success: true,\n            hash: bridgeResp.hash,\n            status: 'pending',\n            fromChain: bridgeOptions.fromChain,\n            toChain: bridgeOptions.toChain,\n            amount: bridgeOptions.amount,\n          },\n          actions: ['BRIDGE_DEPOSIT_POLYGON'],\n          source: message.content.source,\n        });\n      }\n\n      return {\n        success: true,\n        hash: bridgeResp.hash,\n        status: 'pending',\n        fromChain: bridgeOptions.fromChain,\n        toChain: bridgeOptions.toChain,\n        amount: bridgeOptions.amount,\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('BRIDGE_DEPOSIT_POLYGON handler error:', errMsg, error);\n      if (cb) {\n        await cb({\n          text: `Error bridging: ${errMsg}`,\n          actions: ['BRIDGE_DEPOSIT_POLYGON'],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: { text: 'Bridge 0.5 WETH from Polygon to Ethereum mainnet.' },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Move 100 USDC from Arbitrum to Polygon, send it to 0x123...',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type Content,\n  logger,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\n\nexport const getL2BlockNumberAction: Action = {\n  name: 'GET_L2_BLOCK_NUMBER',\n  similes: ['GET_POLYGON_BLOCK_NUMBER', 'CHECK_CURRENT_BLOCK', 'SHOW_LATEST_BLOCK'],\n  description: 'Gets the current block number on Polygon (L2).',\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    // Add debug logging to see if this is being called\n    logger.info(`[getL2BlockNumberAction] Validating message: \"${content}\"`);\n\n    // Check for block number related keywords\n    const blockNumberKeywords = [\n      'block number',\n      'current block',\n      'latest block',\n      'polygon block number',\n      'get polygon block',\n      'block height',\n      'current polygon block',\n      'latest polygon block',\n      'get polygon block number',\n      'show polygon block number',\n    ];\n\n    const matches = blockNumberKeywords.some((keyword) => content.includes(keyword));\n    logger.info(`[getL2BlockNumberAction] Validation result: ${matches}`);\n\n    return matches;\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getL2BlockNumberAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) {\n      throw new Error('PolygonRpcService not available');\n    }\n\n    try {\n      const blockNumber = await rpcService.getCurrentBlockNumber();\n\n      const responseContent: Content = {\n        text: `The current Polygon block number is ${blockNumber}.`,\n        actions: ['GET_L2_BLOCK_NUMBER'],\n        data: {\n          blockNumber,\n          network: 'polygon',\n          timestamp: Date.now(),\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting L2 block number:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const errorContent: Content = {\n        text: `Error retrieving current Polygon block number: ${errorMessage}`,\n        actions: ['GET_L2_BLOCK_NUMBER'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get polygon block number',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'The current Polygon block number is 65123456.',\n          actions: ['GET_L2_BLOCK_NUMBER'],\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'what is the current block number on polygon?',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'The current Polygon block number is 65123456.',\n          actions: ['GET_L2_BLOCK_NUMBER'],\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type Handler,\n  type HandlerCallback,\n  type Content,\n  logger,\n  elizaLogger,\n} from '@elizaos/core';\nimport { ethers } from 'ethers';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\nimport { initWalletProvider } from '../providers/PolygonWalletProvider.js';\n\nexport const getMaticBalanceAction: Action = {\n  name: 'GET_MATIC_BALANCE',\n  similes: ['CHECK_MATIC_BALANCE', 'SHOW_POLYGON_BALANCE', 'GET_NATIVE_BALANCE'],\n  description: \"Gets the MATIC balance for the agent's address on Polygon (L2).\",\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    // Add debug logging to see if this is being called\n    logger.info(`[getMaticBalanceAction] VALIDATION CALLED - message: \"${content}\"`);\n\n    try {\n      // Check for MATIC balance related keywords\n      const maticBalanceKeywords = [\n        'matic balance',\n        'get matic balance',\n        'show matic balance',\n        'check matic balance',\n        'my matic balance',\n        'polygon balance',\n        'balance on polygon',\n        'how much matic',\n        'matic amount',\n        'show me my matic',\n        'what is my matic balance',\n        'check my matic',\n      ];\n\n      const matches = maticBalanceKeywords.some((keyword) => content.includes(keyword));\n      logger.info(\n        `[getMaticBalanceAction] Validation result: ${matches} (keywords checked: ${maticBalanceKeywords.length})`\n      );\n\n      // Also check if we have required services\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        logger.warn(`[getMaticBalanceAction] PolygonRpcService not available - validation false`);\n        return false;\n      }\n\n      return matches;\n    } catch (error) {\n      logger.error(`[getMaticBalanceAction] Validation error:`, error);\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getMaticBalanceAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) throw new Error('PolygonRpcService not available');\n\n    try {\n      const polygonWalletProvider = await initWalletProvider(runtime);\n      if (!polygonWalletProvider) {\n        throw new Error(\n          'Failed to initialize PolygonWalletProvider - check that PRIVATE_KEY is configured correctly'\n        );\n      }\n      const agentAddress = polygonWalletProvider.getAddress();\n      if (!agentAddress) throw new Error('Could not determine agent address from provider');\n\n      logger.info(`Fetching MATIC balance for address: ${agentAddress}`);\n      const balanceWei = await rpcService.getBalance(agentAddress, 'L2');\n      elizaLogger.info(`Balance: ${balanceWei}`);\n      const balanceMatic = ethers.formatEther(balanceWei);\n\n      const responseContent: Content = {\n        text: `Your MATIC balance (${agentAddress}): ${balanceMatic} MATIC`,\n        actions: ['GET_MATIC_BALANCE'],\n        data: {\n          address: agentAddress,\n          balanceWei: balanceWei.toString(),\n          balanceMatic,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting MATIC balance:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const userMessage = errorMessage.includes('private key')\n        ? 'There was an issue with the wallet configuration. Please ensure PRIVATE_KEY is correctly set.'\n        : `Error retrieving MATIC balance: ${errorMessage}`;\n\n      const errorContent: Content = {\n        text: userMessage,\n        actions: ['GET_MATIC_BALANCE'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get matic balance',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your MATIC balance (0x1234...): 17.856183245623432226 MATIC',\n          actions: ['GET_MATIC_BALANCE'],\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'what is my polygon balance?',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your MATIC balance (0x1234...): 17.856183245623432226 MATIC',\n          actions: ['GET_MATIC_BALANCE'],\n        },\n      },\n    ],\n  ],\n};\n","import type { Action, IAgentRuntime } from '@elizaos/core';\nimport { getGasPriceEstimates, type GasPriceEstimates } from '../services/GasService.js';\n\nexport const getPolygonGasEstimatesAction: Action = {\n  name: 'GET_POLYGON_GAS_ESTIMATES',\n  description: 'Gets current gas price estimates for Polygon from PolygonScan.',\n  validate: async () => true,\n  handler: async (runtime: IAgentRuntime) => {\n    const estimates: GasPriceEstimates = await getGasPriceEstimates(runtime);\n    let text = 'Polygon Gas Estimates (Wei):\\n';\n    text += `  Safe Low Priority: ${estimates.safeLow?.maxPriorityFeePerGas?.toString() ?? 'N/A'}\\n`;\n    text += `  Average Priority:  ${estimates.average?.maxPriorityFeePerGas?.toString() ?? 'N/A'}\\n`;\n    text += `  Fast Priority:     ${estimates.fast?.maxPriorityFeePerGas?.toString() ?? 'N/A'}\\n`;\n    text += `  Estimated Base:  ${estimates.estimatedBaseFee?.toString() ?? 'N/A'}`;\n    if (estimates.fallbackGasPrice) {\n      text += `\\n  (Used Fallback Price: ${estimates.fallbackGasPrice.toString()})`;\n    }\n\n    // Create a serializable version of the estimates with BigInt values converted to strings\n    const serializableEstimates = {\n      safeLow: estimates.safeLow\n        ? {\n            maxPriorityFeePerGas: estimates.safeLow.maxPriorityFeePerGas\n              ? estimates.safeLow.maxPriorityFeePerGas.toString()\n              : null,\n          }\n        : null,\n      average: estimates.average\n        ? {\n            maxPriorityFeePerGas: estimates.average.maxPriorityFeePerGas\n              ? estimates.average.maxPriorityFeePerGas.toString()\n              : null,\n          }\n        : null,\n      fast: estimates.fast\n        ? {\n            maxPriorityFeePerGas: estimates.fast.maxPriorityFeePerGas\n              ? estimates.fast.maxPriorityFeePerGas.toString()\n              : null,\n          }\n        : null,\n      estimatedBaseFee: estimates.estimatedBaseFee ? estimates.estimatedBaseFee.toString() : null,\n      fallbackGasPrice: estimates.fallbackGasPrice ? estimates.fallbackGasPrice.toString() : null,\n    };\n\n    return {\n      text,\n      actions: ['GET_POLYGON_GAS_ESTIMATES'],\n      data: serializableEstimates,\n    };\n  },\n  examples: [\n    [\n      {\n        name: 'User',\n        content: { text: 'What are the current gas prices on Polygon?' },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'Get Polygon gas estimates' },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'Fetch gas fees for Polygon network' },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { parseUnits } from 'ethers';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { parseBigIntString } from '../utils';\nimport { undelegateL1Template } from '../templates';\nimport { parseErrorMessage } from '../errors';\n\n// Define input schema for the LLM-extracted parameters\ninterface UndelegateL1Params {\n  validatorId?: number;\n  sharesAmountWei?: string;\n  error?: string;\n}\n\n// Helper function to extract params from text if LLM fails\nfunction extractParamsFromText(text: string): Partial<UndelegateL1Params> {\n  const params: Partial<UndelegateL1Params> = {};\n\n  // Extract validator ID (positive integer)\n  const validatorIdMatch = text.match(/validator(?: id)?\\\\s*[:#]?\\\\s*(\\\\d+)/i);\n  if (validatorIdMatch?.[1]) {\n    const id = Number.parseInt(validatorIdMatch[1], 10);\n    if (id > 0) {\n      params.validatorId = id;\n    }\n  }\n\n  // Extract shares amount (e.g., \"10\", \"5.5\", \"100 shares\", \"0.25 validator shares\")\n  const sharesMatch = text.match(/(\\\\d*\\\\.?\\\\d+)\\\\s*(?:shares?|validator shares?)?/i);\n  if (sharesMatch?.[1]) {\n    try {\n      // Convert to Wei. Assumes 18 decimal places for shares.\n      params.sharesAmountWei = parseUnits(sharesMatch[1], 18).toString();\n    } catch (e) {\n      logger.warn(`Could not parse shares amount from text: ${sharesMatch[1]}`, e);\n    }\n  }\n\n  return params;\n}\n\nexport const undelegateL1Action: Action = {\n  name: 'UNDELEGATE_L1',\n  similes: ['UNSTAKE_L1_SHARES', 'UNBOND_VALIDATOR_SHARES_L1', 'SELL_VALIDATOR_SHARES_L1'],\n  description:\n    'Initiates undelegation (unbonding) of Validator Shares from a Polygon validator on Ethereum L1.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating UNDELEGATE_L1 action...');\n\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for undelegation\n      'POLYGON_PLUGINS_ENABLED', // Ensure main plugin toggle is on\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(`Required setting ${setting} not configured for UNDELEGATE_L1 action.`);\n        return false;\n      }\n    }\n\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized for UNDELEGATE_L1.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error('Error accessing PolygonRpcService during UNDELEGATE_L1 validation:', error);\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _recentMessages: Memory[] | undefined\n  ) => {\n    logger.info('Handling UNDELEGATE_L1 action for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let params: UndelegateL1Params | null = null;\n\n    try {\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      const prompt = composePromptFromState({\n        state,\n        template: undelegateL1Template,\n      });\n\n      // Try using parseJSONObjectFromText with TEXT_SMALL model\n      try {\n        const result = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n\n        params = parseJSONObjectFromText(result) as UndelegateL1Params;\n        logger.debug('UNDELEGATE_L1: Extracted params via TEXT_SMALL:', params);\n\n        // Check if the model response contains an error\n        if (params.error) {\n          logger.warn(`UNDELEGATE_L1: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (e) {\n        logger.warn(\n          'UNDELEGATE_L1: Failed to parse JSON from model response, trying manual extraction',\n          e\n        );\n\n        // Fallback to manual extraction from raw message text\n        const manualParams = extractParamsFromText(rawMessageText);\n        if (manualParams.validatorId && manualParams.sharesAmountWei) {\n          params = {\n            validatorId: manualParams.validatorId,\n            sharesAmountWei: manualParams.sharesAmountWei,\n          };\n          logger.debug('UNDELEGATE_L1: Extracted params via manual text parsing:', params);\n        } else {\n          throw new Error('Could not determine validator ID or shares amount from the message.');\n        }\n      }\n\n      // Validate the extracted parameters\n      if (!params?.validatorId || !params.sharesAmountWei) {\n        throw new Error('Validator ID or shares amount is missing after extraction attempts.');\n      }\n\n      const { validatorId, sharesAmountWei } = params;\n      logger.debug(\n        `UNDELEGATE_L1 parameters: validatorId: ${validatorId}, sharesAmountWei: ${sharesAmountWei}`\n      );\n\n      // Convert the shares amount to BigInt for the service\n      const sharesAmountBigInt = parseBigIntString(sharesAmountWei, 'shares');\n      const txHash = await rpcService.undelegate(validatorId, sharesAmountBigInt);\n\n      const successMsg = `Undelegation transaction sent to L1: ${txHash}. Unbonding period applies.`;\n      logger.info(successMsg);\n\n      const responseContent: Content = {\n        text: successMsg,\n        actions: ['UNDELEGATE_L1'],\n        source: message.content.source,\n        data: {\n          transactionHash: txHash,\n          status: 'pending',\n          validatorId: validatorId,\n          sharesAmountWei: sharesAmountWei,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    } catch (error: unknown) {\n      const parsedError = parseErrorMessage(error);\n      logger.error('Error in UNDELEGATE_L1 handler:', parsedError);\n\n      const errorContent: Content = {\n        text: `Error undelegating shares (L1): ${parsedError.message}`,\n        actions: ['UNDELEGATE_L1'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: parsedError.message,\n          details: parsedError.details,\n        },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n      return errorContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'I want to undelegate 10 shares from validator 123 on L1',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Unstake 5.5 validator shares from the Polygon validator ID 42',\n        },\n      },\n    ],\n  ],\n};\n","export function parseBigIntString(value: unknown, unitName: string): bigint {\n  if (typeof value !== 'string' || !/^-?\\d+$/.test(value)) {\n    throw new Error(`Invalid ${unitName} amount: Must be a string representing an integer.`);\n  }\n  try {\n    return BigInt(value);\n  } catch (e) {\n    throw new Error(`Invalid ${unitName} amount: Cannot parse '${value}' as BigInt.`);\n  }\n}\n","import {\n  type Action,\n  type Content,\n  type HandlerCallback,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService';\nimport { restakeRewardsL1Template } from '../templates'; // Import the new template\nimport { parseErrorMessage } from '../errors';\n\n// Define input schema for the LLM-extracted parameters\ninterface RestakeRewardsL1Params {\n  validatorId?: number;\n  error?: string;\n}\n\n// Helper function to extract params from text if LLM fails (simple version)\nfunction extractParamsFromText(text: string): Partial<RestakeRewardsL1Params> {\n  const params: Partial<RestakeRewardsL1Params> = {};\n  const validatorIdMatch = text.match(/validator(?: id)?\\s*[:#]?\\s*(\\d+)/i);\n  if (validatorIdMatch?.[1]) {\n    const id = Number.parseInt(validatorIdMatch[1], 10);\n    if (id > 0) {\n      params.validatorId = id;\n    }\n  }\n  return params;\n}\n\nexport const restakeRewardsL1Action: Action = {\n  name: 'RESTAKE_REWARDS_L1',\n  similes: ['COMPOUND_L1_REWARDS', 'REINVEST_STAKING_REWARDS_L1'],\n  description:\n    'Withdraws accumulated L1 staking rewards and re-delegates them to the same Polygon validator.',\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating RESTAKE_REWARDS_L1 action...');\n    const requiredSettings = ['PRIVATE_KEY', 'ETHEREUM_RPC_URL', 'POLYGON_PLUGINS_ENABLED'];\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(`Required setting ${setting} not configured for RESTAKE_REWARDS_L1 action.`);\n        return false;\n      }\n    }\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized for RESTAKE_REWARDS_L1.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error(\n        'Error accessing PolygonRpcService during RESTAKE_REWARDS_L1 validation:',\n        error\n      );\n      return false;\n    }\n    return true;\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown, // options are no longer used directly for params\n    callback: HandlerCallback | undefined,\n    _recentMessages: Memory[] | undefined\n  ) => {\n    logger.info('Handling RESTAKE_REWARDS_L1 action for message:', message.id);\n    const rawMessageText = message.content.text || '';\n    let params: RestakeRewardsL1Params | null = null;\n\n    try {\n      const polygonService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!polygonService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      const prompt = composePromptFromState({\n        state,\n        template: restakeRewardsL1Template, // Use the new template\n      });\n\n      try {\n        const result = await runtime.useModel(ModelType.TEXT_SMALL, { prompt });\n        params = parseJSONObjectFromText(result) as RestakeRewardsL1Params;\n        logger.debug('RESTAKE_REWARDS_L1: Extracted params via TEXT_SMALL:', params);\n        if (params.error) {\n          logger.warn(`RESTAKE_REWARDS_L1: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (e) {\n        logger.warn(\n          'RESTAKE_REWARDS_L1: Failed to parse JSON from model, trying manual extraction',\n          e\n        );\n        const manualParams = extractParamsFromText(rawMessageText);\n        if (manualParams.validatorId) {\n          params = { validatorId: manualParams.validatorId };\n          logger.debug('RESTAKE_REWARDS_L1: Extracted params via manual text parsing:', params);\n        } else {\n          throw new Error('Could not determine validator ID from the message.');\n        }\n      }\n\n      if (!params?.validatorId) {\n        throw new Error('Validator ID is missing after extraction attempts.');\n      }\n\n      const { validatorId } = params;\n      logger.info(`Action: Restaking rewards for validator ${validatorId} on L1`);\n\n      const delegateTxHash = await polygonService.restakeRewards(validatorId);\n\n      if (!delegateTxHash) {\n        const noRewardsMsg = `No rewards found to restake for validator ${validatorId}.`;\n        logger.info(noRewardsMsg);\n        const responseContent: Content = {\n          text: noRewardsMsg,\n          actions: ['RESTAKE_REWARDS_L1'],\n          source: message.content.source,\n          data: { validatorId, status: 'no_rewards', success: true }, // success: true as operation completed as expected\n        };\n        if (callback) await callback(responseContent);\n        return responseContent;\n      }\n\n      const successMsg = `Restake operation for validator ${validatorId} initiated. Final delegation transaction hash: ${delegateTxHash}.`;\n      logger.info(successMsg);\n      const responseContent: Content = {\n        text: successMsg,\n        actions: ['RESTAKE_REWARDS_L1'],\n        source: message.content.source,\n        data: {\n          validatorId,\n          transactionHash: delegateTxHash,\n          status: 'initiated',\n          success: true,\n        },\n      };\n      if (callback) await callback(responseContent);\n      return responseContent;\n    } catch (error: unknown) {\n      const parsedError = parseErrorMessage(error);\n      logger.error('Error in RESTAKE_REWARDS_L1 handler:', parsedError);\n      const errorContent: Content = {\n        text: `Error restaking rewards (L1): ${parsedError.message}`,\n        actions: ['RESTAKE_REWARDS_L1'],\n        source: message.content.source,\n        data: {\n          success: false,\n          error: parsedError.message,\n          details: parsedError.details,\n        },\n      };\n      if (callback) await callback(errorContent);\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Restake my L1 rewards for validator 7.',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Compound my staking rewards on Ethereum for validator ID 88.',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type Content,\n  type HandlerCallback,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\nimport { isL2BlockCheckpointedTemplate } from '../templates/index.js';\n\n// Add type declaration for missing method\ndeclare module '../services/PolygonRpcService.js' {\n  interface PolygonRpcService {\n    isL2BlockCheckpointed(l2BlockNumber: number | bigint): Promise<boolean>;\n  }\n}\n\n// Define input schema for the LLM-extracted parameters\ninterface CheckpointParams {\n  l2BlockNumber?: number;\n  error?: string;\n}\n\nexport const isL2BlockCheckpointedAction: Action = {\n  name: 'IS_L2_BLOCK_CHECKPOINTED',\n  description: 'Checks if a Polygon L2 block has been checkpointed on Ethereum L1.',\n\n  validate: async (\n    runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    logger.debug('Validating IS_L2_BLOCK_CHECKPOINTED action...');\n\n    // Check for required settings\n    const requiredSettings = [\n      'PRIVATE_KEY',\n      'ETHEREUM_RPC_URL', // L1 RPC needed for checkpoint verification\n      'POLYGON_RPC_URL', // L2 RPC for completeness\n      'POLYGON_PLUGINS_ENABLED',\n    ];\n\n    for (const setting of requiredSettings) {\n      if (!runtime.getSetting(setting)) {\n        logger.error(\n          `Required setting ${setting} not configured for IS_L2_BLOCK_CHECKPOINTED action.`\n        );\n        return false;\n      }\n    }\n\n    // Verify PolygonRpcService is available\n    try {\n      const service = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!service) {\n        logger.error('PolygonRpcService not initialized.');\n        return false;\n      }\n    } catch (error: unknown) {\n      logger.error('Error accessing PolygonRpcService during validation:', error);\n      return false;\n    }\n\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined,\n    _responses: Memory[] | undefined\n  ) => {\n    logger.info('Handling IS_L2_BLOCK_CHECKPOINTED action for message:', message.id);\n\n    try {\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) throw new Error('PolygonRpcService not available');\n\n      // Extract parameters using LLM with proper template\n      const prompt = composePromptFromState({\n        state: state ? state : { values: {}, data: {}, text: '' },\n        template: isL2BlockCheckpointedTemplate,\n      });\n\n      // Try using the model to extract block number\n      const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n        prompt,\n      });\n      let params: CheckpointParams;\n\n      try {\n        params = parseJSONObjectFromText(modelResponse) as CheckpointParams;\n        logger.debug('IS_L2_BLOCK_CHECKPOINTED: Extracted params:', params);\n\n        // Check if the model response contains an error\n        if (params.error) {\n          logger.warn(`IS_L2_BLOCK_CHECKPOINTED: Model responded with error: ${params.error}`);\n          throw new Error(params.error);\n        }\n      } catch (error: unknown) {\n        logger.error(\n          'Failed to parse LLM response for checkpoint parameters:',\n          modelResponse,\n          error\n        );\n        throw new Error('Could not understand checkpoint parameters.');\n      }\n\n      if (params.l2BlockNumber === undefined) {\n        throw new Error('L2 block number parameter not extracted properly.');\n      }\n\n      // Convert to bigint for the service\n      const l2BlockNumber = BigInt(params.l2BlockNumber);\n\n      logger.info(`Action: Checking checkpoint status for L2 block ${l2BlockNumber}`);\n\n      const lastCheckpointedBlock = await rpcService.getLastCheckpointedL2Block();\n\n      // Check if the specified block is checkpointed\n      const isCheckpointed = await rpcService.isL2BlockCheckpointed(l2BlockNumber);\n\n      // Format the response content\n      const currentL2Block = await rpcService.getCurrentBlockNumber();\n      const responseMsg = `Block ${l2BlockNumber} ${\n        isCheckpointed ? 'is' : 'is not'\n      } checkpointed on Ethereum L1. Last checkpointed block: ${lastCheckpointedBlock}`;\n\n      logger.info(responseMsg);\n\n      const responseContent: Content = {\n        text: responseMsg,\n        actions: ['IS_L2_BLOCK_CHECKPOINTED'],\n        source: message.content.source,\n        data: {\n          l2BlockNumber: Number(l2BlockNumber),\n          currentBlockNumber: currentL2Block,\n          lastCheckpointedBlock: lastCheckpointedBlock.toString(),\n          isCheckpointed,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    } catch (error: unknown) {\n      // Handle checkpoint retrieval errors\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      logger.error('Failed to check if block is checkpointed:', error);\n\n      const userFriendlyMessage = `Unable to verify checkpoint status. The CheckpointManager contract on Ethereum L1 encountered an error: ${errorMessage}. This could be due to a network issue or a contract configuration problem.`;\n\n      const responseContent: Content = {\n        text: userFriendlyMessage,\n        actions: ['IS_L2_BLOCK_CHECKPOINTED'],\n        source: message.content.source,\n        data: {\n          error: errorMessage,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n      return responseContent;\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Is Polygon block 15000000 checkpointed on Ethereum yet?',\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'Check if L2 block 42123456 has been checkpointed',\n        },\n      },\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n  type ActionExample,\n} from '@elizaos/core';\nimport { HeimdallService, VoteOption } from '../services/HeimdallService.js';\nimport { z } from 'zod';\nimport { heimdallVoteActionTemplate } from '../templates/index.js'; // Assuming a template will be created\n\n// --- Action Parameter Schema ---\nconst heimdallVoteParamsSchema = z.object({\n  proposalId: z\n    .union([z.string(), z.number()])\n    .describe('The ID of the Heimdall governance proposal to vote on.'),\n  option: z\n    .nativeEnum(VoteOption)\n    .describe(\n      'The vote option (e.g., VOTE_OPTION_YES, VOTE_OPTION_NO). Provide the numeric value or the string key.'\n    ),\n});\ntype HeimdallVoteParams = z.infer<typeof heimdallVoteParamsSchema>;\n\n// --- Helper to extract params from text if LLM fails ---\nfunction extractHeimdallVoteParamsFromText(text: string): Partial<HeimdallVoteParams> {\n  const params: Partial<HeimdallVoteParams> = {};\n  logger.debug(`Attempting to extract HeimdallVoteParams from text: \"${text}\".`);\n\n  const proposalIdMatch = text.match(/\\b(?:proposal\\s*id|prop\\s*id)\\s*[:\\-]?\\s*([\\w\\d\\-]+)/i);\n  if (proposalIdMatch?.[1]) {\n    const id = proposalIdMatch[1];\n    // Try to parse as number if it's purely numeric, otherwise keep as string\n    params.proposalId = /^\\d+$/.test(id) ? Number(id) : id;\n  }\n\n  // VOTE_OPTION_UNSPECIFIED = 0, VOTE_OPTION_YES = 1, VOTE_OPTION_ABSTAIN = 2, VOTE_OPTION_NO = 3, VOTE_OPTION_NO_WITH_VETO = 4\n  const optionMatch = text.match(\n    /\\b(?:vote|option|support)\\s*[:\\-]?\\s*(yes|no with veto|no|abstain|unspecified|1|2|3|4|0)/i\n  );\n  if (optionMatch?.[1]) {\n    const optionStr = optionMatch[1].toLowerCase();\n    if (optionStr === 'yes' || optionStr === '1') params.option = VoteOption.VOTE_OPTION_YES;\n    else if (optionStr === 'no' || optionStr === '3') params.option = VoteOption.VOTE_OPTION_NO;\n    else if (optionStr === 'abstain' || optionStr === '2')\n      params.option = VoteOption.VOTE_OPTION_ABSTAIN;\n    else if (optionStr === 'no with veto' || optionStr === '4')\n      params.option = VoteOption.VOTE_OPTION_NO_WITH_VETO;\n    else if (optionStr === 'unspecified' || optionStr === '0')\n      params.option = VoteOption.VOTE_OPTION_UNSPECIFIED;\n  }\n  logger.debug('Manually extracted HeimdallVoteParams:', params);\n  return params;\n}\n\n// --- Action Definition ---\nexport const heimdallVoteAction: Action = {\n  name: 'HEIMDALL_VOTE_ON_PROPOSAL',\n  similes: ['VOTE_HEIMDALL_PROPOSAL', 'CAST_VOTE_ON_HEIMDALL', 'HEIMDALL_GOVERNANCE_VOTE'],\n  description: 'Casts a vote on a Heimdall governance proposal.',\n\n  validate: async (runtime: IAgentRuntime): Promise<boolean> => {\n    logger.debug('Validating HEIMDALL_VOTE_ON_PROPOSAL action...');\n    const heimdallRpcUrl = runtime.getSetting('HEIMDALL_RPC_URL');\n    const privateKey = runtime.getSetting('PRIVATE_KEY'); // Assuming PRIVATE_KEY is the general key for the plugin\n\n    if (!heimdallRpcUrl) {\n      logger.error('HEIMDALL_RPC_URL is not configured for Heimdall actions.');\n      return false;\n    }\n    if (!privateKey) {\n      logger.error('PRIVATE_KEY is not configured for Heimdall actions.');\n      return false;\n    }\n    logger.debug('HEIMDALL_VOTE_ON_PROPOSAL validation successful based on settings.');\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown, // Action-specific options, if any, defined in action registration\n    callback: HandlerCallback | undefined\n  ) => {\n    logger.info(`Handling HEIMDALL_VOTE_ON_PROPOSAL for message: ${message.id}`);\n    const rawMessageText = message.content.text || '';\n    let extractedParams: (Partial<HeimdallVoteParams> & { error?: string }) | null = null;\n\n    try {\n      const heimdallService = runtime.getService<HeimdallService>(HeimdallService.serviceType);\n      if (!heimdallService) {\n        throw new Error('HeimdallService is not available. Ensure it is registered and started.');\n      }\n\n      // Parameter extraction using LLM (via template)\n      try {\n        const prompt = composePromptFromState({\n          state,\n          template: heimdallVoteActionTemplate, // Assumes this template is defined\n        });\n        const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n        const parsed = parseJSONObjectFromText(modelResponse);\n        if (parsed) {\n          extractedParams = parsed as Partial<HeimdallVoteParams>;\n\n          if (extractedParams && extractedParams.option !== undefined) {\n            const opt = String(extractedParams.option).toUpperCase().trim();\n            if (opt === 'YES' || opt === '1') {\n              extractedParams.option = VoteOption.VOTE_OPTION_YES;\n            } else if (opt === 'NO' || opt === '3') {\n              extractedParams.option = VoteOption.VOTE_OPTION_NO;\n            } else if (opt === 'ABSTAIN' || opt === '2') {\n              extractedParams.option = VoteOption.VOTE_OPTION_ABSTAIN;\n            } else if (\n              opt === 'NO_WITH_VETO' ||\n              opt === 'NOWITHVETO' ||\n              opt === 'NO WITH VETO' ||\n              opt === '4'\n            ) {\n              extractedParams.option = VoteOption.VOTE_OPTION_NO_WITH_VETO;\n            } else if (opt === 'UNSPECIFIED' || opt === '0') {\n              extractedParams.option = VoteOption.VOTE_OPTION_UNSPECIFIED;\n            } else {\n              const numOpt = Number.parseInt(opt, 10);\n              if (!isNaN(numOpt) && VoteOption[numOpt] !== undefined) {\n                extractedParams.option = numOpt as unknown as VoteOption;\n              } else {\n                logger.warn(\n                  `Unrecognized vote option from LLM: ${extractedParams.option}. Validation will likely fail.`\n                );\n              }\n            }\n          }\n          // ---- END MODIFICATION ----\n        }\n        logger.debug(\n          'HEIMDALL_VOTE_ON_PROPOSAL: Extracted params via TEXT_SMALL:',\n          extractedParams\n        );\n        if (extractedParams?.error) {\n          throw new Error(extractedParams.error);\n        }\n      } catch (e: unknown) {\n        const errorMsg = e instanceof Error ? e.message : String(e);\n        logger.warn(\n          `HEIMDALL_VOTE_ON_PROPOSAL: Failed to parse JSON from model response or model returned error (Proceeding to manual extraction): ${errorMsg}`\n        );\n      }\n\n      // Fallback to manual extraction if LLM fails or params are incomplete\n      if (\n        !extractedParams ||\n        extractedParams.error ||\n        !extractedParams.proposalId ||\n        extractedParams.option === undefined\n      ) {\n        logger.info(\n          'HEIMDALL_VOTE_ON_PROPOSAL: Model extraction insufficient or failed, attempting manual parameter extraction.'\n        );\n        const manualParams = extractHeimdallVoteParamsFromText(rawMessageText);\n        if (extractedParams && !extractedParams.error) {\n          extractedParams = { ...manualParams, ...extractedParams }; // Give precedence to model extracted if not error\n        } else {\n          extractedParams = manualParams;\n        }\n        logger.debug(\n          'HEIMDALL_VOTE_ON_PROPOSAL: Params after manual extraction attempt:',\n          extractedParams\n        );\n      }\n\n      // Validate parameters using Zod schema\n      const validatedParams = heimdallVoteParamsSchema.safeParse(extractedParams);\n      if (!validatedParams.success) {\n        logger.error(\n          'HEIMDALL_VOTE_ON_PROPOSAL: Invalid parameters after all extraction attempts.',\n          validatedParams.error.flatten()\n        );\n        throw new Error(\n          `Invalid parameters: ${validatedParams.error.issues.map((i) => `${i.path.join('.')}: ${i.message}`).join(', ')}`\n        );\n      }\n\n      const { proposalId, option } = validatedParams.data;\n\n      logger.debug('Heimdall vote parameters for service:', {\n        proposalId,\n        option,\n      });\n      const txHash = await heimdallService.voteOnProposal(proposalId, option);\n\n      const successMsg = `Successfully voted ${VoteOption[option]} on Heimdall proposal ${proposalId}. Transaction Hash: ${txHash}`;\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: {\n            success: true,\n            transactionHash: txHash,\n            proposalId,\n            voteOption: VoteOption[option],\n          },\n          actions: [heimdallVoteAction.name],\n          source: message.content.source,\n        });\n      }\n      return {\n        success: true,\n        transactionHash: txHash,\n        proposalId,\n        voteOption: VoteOption[option],\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in HEIMDALL_VOTE_ON_PROPOSAL handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error voting on Heimdall proposal: ${errMsg}`,\n          actions: [heimdallVoteAction.name],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'User votes YES on Heimdall',\n        id: 'heimdall-vote-ex1-user',\n        role: 'user',\n        entityId: 'user123',\n        roomId: 'room456',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_VOTE_ON_PROPOSAL'],\n        content: {\n          text: 'Vote YES on Heimdall proposal 42.',\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n    [\n      {\n        name: 'User votes NO on Heimdall',\n        id: 'heimdall-vote-ex2-user',\n        role: 'user',\n        entityId: 'user123',\n        roomId: 'room456',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_VOTE_ON_PROPOSAL'],\n        content: {\n          text: 'Cast a NO vote for Heimdall governance proposal ID 15.',\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n    [\n      {\n        name: 'User votes ABSTAIN on Heimdall',\n        id: 'heimdall-vote-ex3-user',\n        role: 'user',\n        entityId: 'user123',\n        roomId: 'room456',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_VOTE_ON_PROPOSAL'],\n        content: {\n          text: 'On Heimdall, vote ABSTAIN for proposal 77 using option 2.',\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n  ],\n};\n","import type { OfflineSigner } from '@cosmjs/proto-signing';\nimport { DirectSecp256k1HdWallet, coins, DirectSecp256k1Wallet } from '@cosmjs/proto-signing';\nimport type { SigningStargateClient, StargateClientOptions } from '@cosmjs/stargate';\nimport { SigningStargateClient as ConcreteSigningStargateClient } from '@cosmjs/stargate';\nimport { Service, type IAgentRuntime, logger } from '@elizaos/core';\n\n// Configuration keys expected from the runtime settings\nconst HEIMDALL_RPC_URL_KEY = 'HEIMDALL_RPC_URL';\nconst PRIVATE_KEY_KEY = 'PRIVATE_KEY';\n\n/**\n * Enum representing voting options for governance proposals.\n * These values match the Cosmos SDK VoteOption enum values.\n */\nexport enum VoteOption {\n  VOTE_OPTION_UNSPECIFIED = 0,\n  VOTE_OPTION_YES = 1,\n  VOTE_OPTION_ABSTAIN = 2,\n  VOTE_OPTION_NO = 3,\n  VOTE_OPTION_NO_WITH_VETO = 4,\n}\n\n// Type for standard Cosmos SDK MsgVote\ninterface MsgVote {\n  typeUrl: string;\n  value: {\n    proposalId: string | number;\n    voter: string;\n    option: VoteOption;\n  };\n}\n\n// Interface for Content types in proposals\nexport interface TextProposal {\n  title: string;\n  description: string;\n}\n\nexport interface ParamChange {\n  subspace: string;\n  key: string;\n  value: string;\n}\n\nexport interface ParameterChangeProposal {\n  title: string;\n  description: string;\n  changes: ParamChange[];\n}\n\nexport type ProposalContent = TextProposal | ParameterChangeProposal;\n\n// Interface for cosmos sdk transaction return type\ninterface BroadcastTxSuccess {\n  code: number;\n  height: number;\n  rawLog: string;\n  transactionHash: string;\n  gasUsed: number;\n  gasWanted: number;\n}\n\n/**\n * Service for interacting with the Polygon Heimdall layer,\n * primarily for governance actions.\n */\nexport class HeimdallService extends Service {\n  static override serviceType = 'heimdall';\n  override capabilityDescription =\n    'Provides access to Polygon Heimdall layer for governance operations.';\n\n  private heimdallRpcUrl: string | null = null;\n  private privateKey: string | null = null;\n\n  // Fee defaults for Heimdall transactions in MATIC - can be made configurable if needed\n  private static readonly DEFAULT_GAS_LIMIT = '200000';\n  private static readonly DEFAULT_FEE_AMOUNT = '5000000000000000'; // 0.005 MATIC\n  private static readonly DEFAULT_DENOM = 'matic';\n\n  // initializeHeimdallClient will be called by the static start method\n  private async initializeHeimdallClient(): Promise<void> {\n    if (!this.runtime) {\n      logger.error('Agent runtime is not available for HeimdallService.');\n      throw new Error('Agent runtime not available.');\n    }\n\n    this.heimdallRpcUrl = this.runtime.getSetting(HEIMDALL_RPC_URL_KEY);\n    this.privateKey = this.runtime.getSetting(PRIVATE_KEY_KEY);\n\n    if (!this.heimdallRpcUrl) {\n      logger.error(`Heimdall RPC URL setting (${HEIMDALL_RPC_URL_KEY}) not found.`);\n      throw new Error('Heimdall RPC URL is not configured.');\n    }\n    if (!this.privateKey) {\n      logger.error(`Heimdall private key setting (${PRIVATE_KEY_KEY}) not found.`);\n      throw new Error('Heimdall private key is not configured.');\n    }\n    logger.info('HeimdallService initialized with necessary configurations.');\n  }\n\n  static async start(runtime: IAgentRuntime): Promise<HeimdallService> {\n    logger.info('Starting HeimdallService...');\n    const service = new HeimdallService(runtime);\n    await service.initializeHeimdallClient();\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime): Promise<void> {\n    logger.info('Stopping HeimdallService...');\n    const service = runtime.getService<HeimdallService>(HeimdallService.serviceType);\n    if (service) {\n      await service.stop();\n    }\n  }\n\n  async stop(): Promise<void> {\n    logger.info('HeimdallService instance stopped.');\n    this.heimdallRpcUrl = null;\n    this.privateKey = null;\n  }\n\n  private async getSigner(): Promise<OfflineSigner> {\n    if (!this.privateKey) {\n      logger.error('Heimdall private key is not available in getSigner.');\n      throw new Error('Heimdall private key is not configured for HeimdallService.');\n    }\n    try {\n      // Convert hex private key to Uint8Array\n      // Ensure the private key starts with 0x for consistency, then strip it for Buffer conversion\n      const hexKey = this.privateKey.startsWith('0x')\n        ? this.privateKey.substring(2)\n        : this.privateKey;\n      if (!/^[0-9a-fA-F]{64}$/.test(hexKey)) {\n        logger.error('Invalid private key format. Expected 64 hex characters.');\n        throw new Error('Invalid private key format.');\n      }\n      const privateKeyBytes = Uint8Array.from(Buffer.from(hexKey, 'hex'));\n\n      const signer = await DirectSecp256k1Wallet.fromKey(privateKeyBytes, 'heimdall');\n      return signer;\n    } catch (error) {\n      logger.error(\n        'Failed to create Heimdall signer from private key.',\n        error instanceof Error ? error.message : String(error)\n      );\n      throw new Error('Failed to create Heimdall signer.');\n    }\n  }\n\n  public async getSigningClient(): Promise<SigningStargateClient> {\n    if (!this.heimdallRpcUrl) {\n      logger.error('Heimdall RPC URL is not available in getSigningClient.');\n      throw new Error('Heimdall RPC URL is not configured for HeimdallService.');\n    }\n\n    try {\n      const signer = await this.getSigner();\n      const options: StargateClientOptions = {};\n      const client = await ConcreteSigningStargateClient.connectWithSigner(\n        this.heimdallRpcUrl,\n        signer,\n        options\n      );\n      logger.debug('Successfully connected to Heimdall RPC with signer.');\n      return client;\n    } catch (error) {\n      logger.error(\n        'Failed to connect to Heimdall RPC with signer.',\n        error instanceof Error ? error.message : String(error)\n      );\n      throw new Error('Failed to connect to Heimdall RPC with signer.');\n    }\n  }\n\n  /**\n   * Asserts that a transaction was successful by checking its code.\n   * @param result The broadcast tx result to check\n   * @throws Error if the transaction failed\n   */\n  private assertIsBroadcastTxSuccess(result: {\n    code?: number;\n    rawLog?: string;\n  }): asserts result is BroadcastTxSuccess {\n    if ('code' in result && result.code !== 0) {\n      const message = result.rawLog || 'Transaction failed';\n      throw new Error(`Error when broadcasting tx: ${message}`);\n    }\n  }\n\n  /**\n   * Vote on a Heimdall governance proposal.\n   *\n   * @param proposalId The ID of the proposal to vote on\n   * @param option The vote option (YES, NO, etc.)\n   * @returns The transaction hash if successful\n   */\n  public async voteOnProposal(proposalId: string | number, option: VoteOption): Promise<string> {\n    logger.info(`Attempting to vote on proposal ${proposalId} with option ${VoteOption[option]}`);\n\n    try {\n      // Step 1: Get the signing client and first account/signer\n      const client = await this.getSigningClient();\n      const signer = await this.getSigner();\n      const accounts = await signer.getAccounts();\n      if (accounts.length === 0) {\n        throw new Error('No accounts found in wallet');\n      }\n      const voter = accounts[0].address;\n      logger.debug(`Voter address: ${voter}`);\n\n      // Step 2: Construct the MsgVote with the proper typeUrl\n      const msgVote: MsgVote = {\n        typeUrl: '/cosmos.gov.v1beta1.MsgVote',\n        value: {\n          proposalId: proposalId.toString(), // Ensure proposalId is a string\n          voter: voter,\n          option: option,\n        },\n      };\n\n      // Step 3: Prepare fee\n      const fee = {\n        amount: coins(HeimdallService.DEFAULT_FEE_AMOUNT, HeimdallService.DEFAULT_DENOM),\n        gas: HeimdallService.DEFAULT_GAS_LIMIT,\n      };\n\n      // Step 4: Broadcast the transaction\n      logger.debug('Broadcasting vote transaction...');\n      const result = await client.signAndBroadcast(voter, [msgVote], fee);\n\n      // Step 5: Check for success and return tx hash\n      this.assertIsBroadcastTxSuccess(result);\n      logger.info(\n        `Successfully voted on proposal ${proposalId}, tx hash: ${result.transactionHash}`\n      );\n      return result.transactionHash;\n    } catch (error) {\n      // Convert error to a more user-friendly format\n      let errorMessage: string;\n      if (error instanceof Error) {\n        errorMessage = error.message;\n        // Add more specific error handling based on error messages\n        if (errorMessage.includes('insufficient fee')) {\n          errorMessage =\n            'Insufficient fee for Heimdall transaction. Try increasing the fee amount.';\n        } else if (\n          errorMessage.includes('proposal not found') ||\n          errorMessage.includes('not found')\n        ) {\n          errorMessage = `Proposal ${proposalId} not found or no longer in voting period.`;\n        } else if (errorMessage.includes('already voted')) {\n          errorMessage = `This account has already voted on proposal ${proposalId}.`;\n        }\n      } else {\n        errorMessage = String(error);\n      }\n\n      logger.error(`Failed to vote on proposal ${proposalId}:`, errorMessage);\n      throw new Error(`Vote failed: ${errorMessage}`);\n    }\n  }\n\n  public async submitProposal(\n    content: ProposalContent,\n    initialDepositAmount: string,\n    initialDepositDenom = 'matic'\n  ): Promise<string> {\n    const contentType = 'changes' in content ? 'ParameterChangeProposal' : 'TextProposal';\n    logger.info(`Attempting to submit ${contentType}`);\n\n    try {\n      // Step 1: Get the signing client and first account/signer\n      const client = await this.getSigningClient();\n      const signer = await this.getSigner();\n      const accounts = await signer.getAccounts();\n      if (accounts.length === 0) {\n        throw new Error('No accounts found in wallet');\n      }\n      const proposer = accounts[0].address;\n      logger.debug(`Proposal from address: ${proposer}`);\n\n      // Step 2: Construct the proposal content based on its type\n      let typeUrl: string;\n      if ('changes' in content) {\n        // It's a ParameterChangeProposal\n        typeUrl = '/cosmos.params.v1beta1.ParameterChangeProposal';\n        logger.debug(`Parameter change proposal: ${content.title}`);\n        // The content is passed directly as the 'content' field in MsgSubmitProposal\n      } else {\n        // It's a TextProposal\n        typeUrl = '/cosmos.gov.v1beta1.TextProposal';\n        logger.debug(`Text proposal: ${content.title}`);\n        // The content is passed directly as the 'content' field in MsgSubmitProposal\n      }\n\n      // Step 3: Construct the MsgSubmitProposal\n      const msgSubmitProposal = {\n        typeUrl: '/cosmos.gov.v1beta1.MsgSubmitProposal',\n        value: {\n          content: {\n            typeUrl,\n            value: content, // When using cosmjs, this will get properly converted/encoded\n          },\n          initialDeposit: coins(initialDepositAmount, initialDepositDenom),\n          proposer,\n        },\n      };\n\n      // Step 4: Prepare fee\n      const fee = {\n        amount: coins(HeimdallService.DEFAULT_FEE_AMOUNT, HeimdallService.DEFAULT_DENOM),\n        gas: HeimdallService.DEFAULT_GAS_LIMIT,\n      };\n\n      // Step 5: Broadcast the transaction\n      logger.debug('Broadcasting submit proposal transaction...');\n      const result = await client.signAndBroadcast(proposer, [msgSubmitProposal], fee);\n\n      // Step 6: Check for success and return tx hash\n      this.assertIsBroadcastTxSuccess(result);\n      logger.info(`Successfully submitted proposal, tx hash: ${result.transactionHash}`);\n      return result.transactionHash;\n    } catch (error) {\n      // Convert error to a more user-friendly format\n      let errorMessage: string;\n      if (error instanceof Error) {\n        errorMessage = error.message;\n        // Add more specific error handling\n        if (errorMessage.includes('insufficient fee')) {\n          errorMessage =\n            'Insufficient fee for Heimdall transaction. Try increasing the fee amount.';\n        } else if (errorMessage.includes('minimum deposit')) {\n          errorMessage = 'The initial deposit is below the minimum required for proposals.';\n        }\n      } else {\n        errorMessage = String(error);\n      }\n\n      logger.error('Failed to submit proposal:', errorMessage);\n      throw new Error(`Proposal submission failed: ${errorMessage}`);\n    }\n  }\n\n  public async transferHeimdallTokens(\n    recipientAddress: string,\n    amount: string,\n    denom = 'matic'\n  ): Promise<string> {\n    logger.info(`Attempting to transfer ${amount} ${denom} to ${recipientAddress} on Heimdall`);\n\n    try {\n      // Step 1: Get the signing client and first account/signer\n      const client = await this.getSigningClient();\n      const signer = await this.getSigner();\n      const accounts = await signer.getAccounts();\n      if (accounts.length === 0) {\n        throw new Error('No accounts found in wallet');\n      }\n      const sender = accounts[0].address;\n      logger.debug(`Sender address: ${sender}`);\n\n      // Validate recipient address\n      if (!recipientAddress.startsWith('heimdall')) {\n        throw new Error(\n          `Invalid recipient address format: ${recipientAddress}. Must start with \"heimdall\"`\n        );\n      }\n\n      // Step 2: Construct the MsgSend for token transfer\n      const msgSend = {\n        typeUrl: '/cosmos.bank.v1beta1.MsgSend',\n        value: {\n          fromAddress: sender,\n          toAddress: recipientAddress,\n          amount: coins(amount, denom),\n        },\n      };\n\n      // Step 3: Prepare fee\n      const fee = {\n        amount: coins(HeimdallService.DEFAULT_FEE_AMOUNT, HeimdallService.DEFAULT_DENOM),\n        gas: HeimdallService.DEFAULT_GAS_LIMIT,\n      };\n\n      // Step 4: Broadcast the transaction\n      logger.debug(`Broadcasting transfer transaction to ${recipientAddress}...`);\n      const result = await client.signAndBroadcast(sender, [msgSend], fee);\n\n      // Step 5: Check for success and return tx hash\n      this.assertIsBroadcastTxSuccess(result);\n      logger.info(\n        `Successfully transferred ${amount} ${denom} to ${recipientAddress}, tx hash: ${result.transactionHash}`\n      );\n      return result.transactionHash;\n    } catch (error) {\n      // Convert error to a more user-friendly format\n      let errorMessage: string;\n      if (error instanceof Error) {\n        errorMessage = error.message;\n        // Add more specific error handling\n        if (errorMessage.includes('insufficient fee')) {\n          errorMessage =\n            'Insufficient fee for Heimdall transaction. Try increasing the fee amount.';\n        } else if (errorMessage.includes('insufficient funds')) {\n          errorMessage = `Insufficient funds to transfer ${amount} ${denom}. Check your balance on Heimdall.`;\n        }\n      } else {\n        errorMessage = String(error);\n      }\n\n      logger.error(`Failed to transfer tokens to ${recipientAddress}:`, errorMessage);\n      throw new Error(`Transfer failed: ${errorMessage}`);\n    }\n  }\n}\n\n// Example of how this service might be registered in your plugin's main file (e.g., src/index.ts)\n/*\nimport { ElizaOSAgent } from \"@elizaos/core\";\nimport { HeimdallService } from \"./services/HeimdallService\";\n\nexport default class MyPolygonPlugin extends ElizaOSAgent {\n\tasync onReady() {\n\t\tawait super.onReady();\n\n\t\t// Register the HeimdallService\n\t\tif (this.runtime) {\n\t\t\tthis.runtime.registerService(HeimdallService.serviceType, async (runtime) => {\n\t\t\t\treturn HeimdallService.start(runtime);\n\t\t\t});\n\t\t\tlogger.info(\"MyPolygonPlugin: HeimdallService registered.\");\n\t\t} else {\n\t\t\tlogger.error(\"MyPolygonPlugin: Runtime not available to register HeimdallService.\");\n\t\t}\n\n\t\t// You can now access the service via runtime.getService<HeimdallService>(HeimdallService.serviceType)\n\t\t// Example:\n\t\t// const heimdallService = this.runtime?.getService<HeimdallService>(HeimdallService.serviceType);\n\t\t// if (heimdallService) {\n\t\t//   const client = await heimdallService.getSigningClient();\n\t\t//   logger.info(\"Got Heimdall client from service:\", client?.registry?.toString());\n\t\t// }\n\t}\n}\n*/\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n  type ActionExample,\n} from '@elizaos/core';\nimport {\n  HeimdallService,\n  type TextProposal as ServiceTextProposal, // Alias to avoid name clash if needed\n  type ParameterChangeProposal as ServiceParameterChangeProposal,\n} from '../services/HeimdallService.js';\nimport { z } from 'zod';\nimport { heimdallSubmitProposalActionTemplate } from '../templates/index.js'; // Will be created\n\n// --- Action Parameter Schemas ---\nconst paramChangeSchema = z.object({\n  subspace: z.string().min(1),\n  key: z.string().min(1),\n  value: z.string(), // Value can be empty string\n});\n\nconst textProposalSchema = z.object({\n  type: z.literal('TextProposal'),\n  title: z.string().min(1).describe('Title of the text proposal.'),\n  description: z.string().min(1).describe('Description of the text proposal.'),\n});\n\nconst parameterChangeProposalSchema = z.object({\n  type: z.literal('ParameterChangeProposal'),\n  title: z.string().min(1).describe('Title of the parameter change proposal.'),\n  description: z.string().min(1).describe('Description of the parameter change proposal.'),\n  changes: z.array(paramChangeSchema).min(1).describe('Array of parameter changes.'),\n});\n\n// Discriminated union for proposal content\nconst proposalContentSchema = z.discriminatedUnion('type', [\n  textProposalSchema,\n  parameterChangeProposalSchema,\n]);\n\n// Define ZodProposalContent based on the schema used for params\ntype ZodProposalContent = z.infer<typeof proposalContentSchema>;\n\nconst heimdallSubmitProposalParamsSchema = z.object({\n  content: proposalContentSchema.describe(\n    'The content of the proposal (TextProposal or ParameterChangeProposal).'\n  ),\n  initialDepositAmount: z\n    .string()\n    .min(1)\n    .describe('The amount of the initial deposit for the proposal (e.g., \"10000000\").'),\n  initialDepositDenom: z\n    .string()\n    .optional()\n    .default('matic')\n    .describe('The denomination of the initial deposit (default: \"matic\").'),\n});\n\ntype HeimdallSubmitProposalParams = z.infer<typeof heimdallSubmitProposalParamsSchema>;\n\n// --- Helper to extract params from text (simplified, relies more on LLM template) ---\nfunction extractHeimdallSubmitProposalParamsFromText(\n  text: string\n): Partial<HeimdallSubmitProposalParams> {\n  logger.debug(`Attempting to extract HeimdallSubmitProposalParams from text: \"${text}\".`);\n  const params: Partial<HeimdallSubmitProposalParams> = {};\n  const depositAmountMatch = text.match(/deposit(?:Amount)?[:\\\\-]?\\\\s*(\\\\d+)/i);\n  if (depositAmountMatch?.[1]) params.initialDepositAmount = depositAmountMatch[1];\n\n  const depositDenomMatch = text.match(/depositDenom[:\\\\-]?\\\\s*(\\\\w+)/i);\n  if (depositDenomMatch?.[1]) params.initialDepositDenom = depositDenomMatch[1];\n\n  // Use ZodProposalContent for partialContent\n  const partialContent: Partial<ZodProposalContent> = {};\n  const titleMatch = text.match(/title[:\\\\-]?\\\\s*([\\\"\\'](.+?)[\\\"\\']|([^,\\\\n{\\\\[]+))/i);\n  if (titleMatch?.[2] || titleMatch?.[3]) {\n    partialContent.title = (titleMatch[2] || titleMatch[3]).trim();\n  }\n\n  const descriptionMatch = text.match(/description[:\\\\-]?\\\\s*([\\\"\\'](.+?)[\\\"\\']|([^,\\\\n{\\\\[]+))/i);\n  if (descriptionMatch?.[2] || descriptionMatch?.[3]) {\n    partialContent.description = (descriptionMatch[2] || descriptionMatch[3]).trim();\n  }\n\n  if (\n    text.toLowerCase().includes('parameterchange') ||\n    text.toLowerCase().includes('param change')\n  ) {\n    partialContent.type = 'ParameterChangeProposal';\n  } else if (partialContent.title) {\n    partialContent.type = 'TextProposal';\n  }\n\n  if (Object.keys(partialContent).length > 0) {\n    // Ensure the 'content' field of 'params' expects ZodProposalContent or a compatible type.\n    // heimdallSubmitProposalParamsSchema defines content based on proposalContentSchema (which is ZodProposalContent)\n    params.content = partialContent as ZodProposalContent;\n  }\n\n  logger.debug('Manually extracted HeimdallSubmitProposalParams (partial):', params);\n  return params;\n}\n\n// --- Action Definition ---\nexport const heimdallSubmitProposalAction: Action = {\n  name: 'HEIMDALL_SUBMIT_PROPOSAL',\n  similes: [\n    'SUBMIT_HEIMDALL_PROPOSAL',\n    'CREATE_HEIMDALL_GOVERNANCE_PROPOSAL',\n    'HEIMDALL_NEW_PROPOSAL',\n  ],\n  description: 'Submits a new governance proposal (Text or ParameterChange) to Heimdall.',\n\n  validate: async (runtime: IAgentRuntime): Promise<boolean> => {\n    logger.debug('Validating HEIMDALL_SUBMIT_PROPOSAL action...');\n    const heimdallRpcUrl = runtime.getSetting('HEIMDALL_RPC_URL');\n    const privateKey = runtime.getSetting('PRIVATE_KEY');\n\n    if (!heimdallRpcUrl) {\n      logger.error('HEIMDALL_RPC_URL is not configured.');\n      return false;\n    }\n    if (!privateKey) {\n      logger.error('PRIVATE_KEY is not configured.');\n      return false;\n    }\n    logger.debug('HEIMDALL_SUBMIT_PROPOSAL validation successful.');\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined\n  ) => {\n    logger.info(`Handling HEIMDALL_SUBMIT_PROPOSAL for message: ${message.id}`);\n    const rawMessageText = message.content.text || '';\n    let extractedParams: (Partial<HeimdallSubmitProposalParams> & { error?: string }) | null = null;\n\n    try {\n      const heimdallService = runtime.getService<HeimdallService>(HeimdallService.serviceType);\n      if (!heimdallService) {\n        throw new Error('HeimdallService is not available.');\n      }\n\n      try {\n        const prompt = composePromptFromState({\n          state: state ?? { values: {}, data: {}, text: '' }, // Provide a default State object if state is undefined\n          template: heimdallSubmitProposalActionTemplate,\n        });\n        const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n        logger.debug(\n          'HEIMDALL_SUBMIT_PROPOSAL: Raw modelResponse from runtime.useModel:',\n          modelResponse\n        ); // New Log\n\n        // Pre-process modelResponse to strip markdown fences\n        let jsonString = modelResponse;\n        const regex = /```(?:json)?\\s*([\\s\\S]*?)\\s*```/;\n        logger.debug('HEIMDALL_SUBMIT_PROPOSAL: Regex to be used for stripping:', regex.toString()); // New Log\n        const match = modelResponse.match(regex);\n        logger.debug('HEIMDALL_SUBMIT_PROPOSAL: Result of modelResponse.match(regex):', match); // New Log\n\n        if (match && match[1]) {\n          logger.debug('HEIMDALL_SUBMIT_PROPOSAL: Regex match found. match[1] is:', match[1]); // New Log\n          jsonString = match[1];\n          // Remove single-line comments from jsonString\n          jsonString = jsonString.replace(/\\/\\/.*$/gm, '');\n          logger.debug(\n            'HEIMDALL_SUBMIT_PROPOSAL: jsonString after stripping attempt and comment removal:',\n            jsonString\n          ); // Modified Log\n        } else {\n          logger.warn(\n            'HEIMDALL_SUBMIT_PROPOSAL: Regex did not match or match[1] was empty. jsonString remains unstripped.'\n          ); // New Log\n        }\n\n        logger.debug(\n          \"Model's json response (this is jsonString passed to parseJSONObjectFromText):\",\n          jsonString\n        ); // Modified existing log for clarity\n\n        // ---- BEGIN NEW DEBUG BLOCK ----\n        let directParseResult: any = null;\n        let directParseError: any = null;\n        try {\n          directParseResult = JSON.parse(jsonString);\n          logger.debug(\n            'HEIMDALL_SUBMIT_PROPOSAL: Direct JSON.parse(jsonString) SUCCEEDED. Result:',\n            directParseResult\n          );\n        } catch (e) {\n          directParseError = e instanceof Error ? e.message : String(e);\n          logger.error(\n            'HEIMDALL_SUBMIT_PROPOSAL: Direct JSON.parse(jsonString) FAILED. Error:',\n            directParseError\n          );\n          logger.error(\n            'HEIMDALL_SUBMIT_PROPOSAL: jsonString that failed direct parse was:',\n            jsonString\n          );\n        }\n        // ---- END NEW DEBUG BLOCK ----\n\n        const parsed = directParseResult ?? parseJSONObjectFromText(jsonString);\n        logger.debug(\n          'HEIMDALL_SUBMIT_PROPOSAL: Result from parseJSONObjectFromText(jsonString) or directParseResult:',\n          parsed\n        ); // Modified Log\n\n        if (parsed) {\n          extractedParams = parsed as Partial<HeimdallSubmitProposalParams>;\n        }\n        logger.debug('HEIMDALL_SUBMIT_PROPOSAL: Extracted params via TEXT_SMALL:', extractedParams);\n        if (extractedParams?.error) {\n          throw new Error(extractedParams.error);\n        }\n      } catch (e: unknown) {\n        const errorMsg = e instanceof Error ? e.message : String(e);\n        logger.warn(\n          `HEIMDALL_SUBMIT_PROPOSAL: Failed to parse JSON from model (Proceeding to manual): ${errorMsg}`\n        );\n      }\n\n      if (\n        !extractedParams ||\n        (extractedParams.error && extractedParams.error.trim() !== '') ||\n        !extractedParams.content ||\n        !extractedParams.initialDepositAmount\n      ) {\n        logger.info(\n          'HEIMDALL_SUBMIT_PROPOSAL: Model extraction insufficient, attempting manual parameter extraction.'\n        );\n        const manualParams = extractHeimdallSubmitProposalParamsFromText(rawMessageText);\n        if (extractedParams && !extractedParams.error) {\n          extractedParams = { ...manualParams, ...extractedParams };\n          // Deep merge for content might be needed if both provide parts of it\n          if (manualParams.content && extractedParams.content) {\n            extractedParams.content = {\n              ...manualParams.content,\n              ...extractedParams.content,\n            } as ZodProposalContent;\n          }\n        } else {\n          extractedParams = manualParams;\n        }\n        logger.debug('HEIMDALL_SUBMIT_PROPOSAL: Params after manual extraction:', extractedParams);\n      }\n\n      const validatedParams = heimdallSubmitProposalParamsSchema.safeParse(extractedParams);\n      if (!validatedParams.success) {\n        logger.error(\n          'HEIMDALL_SUBMIT_PROPOSAL: Invalid parameters.',\n          validatedParams.error.flatten()\n        );\n        throw new Error(\n          `Invalid parameters: ${validatedParams.error.issues.map((i) => `${i.path.join('.')}: ${i.message}`).join(', ')}`\n        );\n      }\n\n      const { content, initialDepositAmount, initialDepositDenom } = validatedParams.data;\n\n      // The `content` from Zod will have the `type` discriminator which we don't want in the service call directly.\n      // The service determines the type based on the presence of 'changes'.\n      // We need to pass the actual content object without the extra 'type' field.\n      const { type, ...actualContent } = content;\n\n      const txHash = await heimdallService.submitProposal(\n        actualContent as ServiceParameterChangeProposal | ServiceTextProposal, // Cast to service-level types\n        initialDepositAmount,\n        initialDepositDenom\n      );\n\n      const successMsg = `Successfully submitted Heimdall proposal. Type: ${type}, Title: ${actualContent.title}. Tx Hash: ${txHash}`;\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: {\n            success: true,\n            transactionHash: txHash,\n            proposalType: type,\n            title: actualContent.title,\n          },\n          actions: [heimdallSubmitProposalAction.name],\n          source: message.content.source,\n        });\n      }\n      return {\n        success: true,\n        transactionHash: txHash,\n        proposalType: type,\n        title: actualContent.title,\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in HEIMDALL_SUBMIT_PROPOSAL handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error submitting Heimdall proposal: ${errMsg}`,\n          actions: [heimdallSubmitProposalAction.name],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'User submits Heimdall TextProposal',\n        id: 'hsp-ex1-user',\n        role: 'user',\n        entityId: 'u1',\n        roomId: 'r1',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_SUBMIT_PROPOSAL'],\n        content: {\n          text: \"Submit a Heimdall text proposal titled 'Network Upgrade Info' with description 'Details about upcoming v2 upgrade.' and deposit 10000000 matic.\",\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n    [\n      {\n        name: 'User submits Heimdall ParameterChangeProposal',\n        id: 'hsp-ex2-user',\n        role: 'user',\n        entityId: 'u1',\n        roomId: 'r1',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_SUBMIT_PROPOSAL'],\n        content: {\n          text: \"Propose a parameter change on Heimdall. Title: 'Update Staking Param', Description: 'Increase max validators'. Change subspace 'staking', key 'MaxValidators', value '120'. Initial deposit: 5000000 matic.\",\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  logger,\n  composePromptFromState,\n  ModelType,\n  parseJSONObjectFromText,\n  type ActionExample,\n} from '@elizaos/core';\nimport { HeimdallService } from '../services/HeimdallService';\nimport { z } from 'zod';\nimport { heimdallTransferTokensActionTemplate } from '../templates'; // Will be created\n\n// --- Action Parameter Schema ---\nconst heimdallTransferTokensParamsSchema = z.object({\n  recipientAddress: z\n    .string()\n    .startsWith(\n      'heimdallvaloper',\n      'Recipient address must start with \"heimdallvaloper\" for validators or \"heimdall\" for regular addresses.'\n    )\n    .or(\n      z\n        .string()\n        .startsWith(\n          'heimdall',\n          'Recipient address must start with \"heimdallvaloper\" for validators or \"heimdall\" for regular addresses.'\n        )\n    )\n    .describe(\n      'The Heimdall address of the recipient (must start with \"heimdall\" or \"heimdallvaloper\").'\n    ),\n  amount: z\n    .string()\n    .min(1)\n    .regex(/^\\\\d+$/, 'Amount must be a string containing only digits (Wei).')\n    .describe('The amount of tokens to transfer in Wei (e.g., \"1000000000000000000\").'),\n  denom: z\n    .string()\n    .optional()\n    .default('matic')\n    .describe('The denomination of the tokens (default: \"matic\").'),\n});\ntype HeimdallTransferTokensParams = z.infer<typeof heimdallTransferTokensParamsSchema>;\n\n// --- Helper to extract params from text ---\nfunction extractHeimdallTransferTokensParamsFromText(\n  text: string\n): Partial<HeimdallTransferTokensParams> {\n  const params: Partial<HeimdallTransferTokensParams> = {};\n  logger.debug(`Attempting to extract HeimdallTransferTokensParams from text: \\\"${text}\\\".`);\n\n  const recipientMatch = text.match(\n    /\\\\b(?:to|recipient|receiver)\\\\s*[:\\\\-]?\\\\s*(heimdall(?:valoper)?[a-zA-Z0-9]+)/i\n  );\n  if (recipientMatch?.[1]) params.recipientAddress = recipientMatch[1];\n\n  const amountMatch = text.match(/\\\\b(amount|sum)\\\\s*[:\\\\-]?\\\\s*(\\\\d+)/i);\n  if (amountMatch?.[2]) params.amount = amountMatch[2];\n\n  const denomMatch = text.match(/\\\\b(denom|denomination|currency)\\\\s*[:\\\\-]?\\\\s*(\\\\w+)/i);\n  if (denomMatch?.[2]) params.denom = denomMatch[2].toLowerCase();\n\n  logger.debug('Manually extracted HeimdallTransferTokensParams:', params);\n  return params;\n}\n\n// --- Action Definition ---\nexport const heimdallTransferTokensAction: Action = {\n  name: 'HEIMDALL_TRANSFER_TOKENS',\n  similes: ['TRANSFER_HEIMDALL_MATIC', 'SEND_HEIMDALL_TOKENS', 'HEIMDALL_TOKEN_TRANSFER'],\n  description: 'Transfers native tokens (e.g., MATIC) on the Heimdall network.',\n\n  validate: async (runtime: IAgentRuntime): Promise<boolean> => {\n    logger.debug('Validating HEIMDALL_TRANSFER_TOKENS action...');\n    const heimdallRpcUrl = runtime.getSetting('HEIMDALL_RPC_URL');\n    const privateKey = runtime.getSetting('PRIVATE_KEY');\n\n    if (!heimdallRpcUrl) {\n      logger.error('HEIMDALL_RPC_URL is not configured.');\n      return false;\n    }\n    if (!privateKey) {\n      logger.error('PRIVATE_KEY is not configured.');\n      return false;\n    }\n    logger.debug('HEIMDALL_TRANSFER_TOKENS validation successful.');\n    return true;\n  },\n\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state: State | undefined,\n    _options: unknown,\n    callback: HandlerCallback | undefined\n  ) => {\n    logger.info(`Handling HEIMDALL_TRANSFER_TOKENS for message: ${message.id}`);\n    const rawMessageText = message.content.text || '';\n    let extractedParams: (Partial<HeimdallTransferTokensParams> & { error?: string }) | null = null;\n\n    try {\n      const heimdallService = runtime.getService<HeimdallService>(HeimdallService.serviceType);\n      if (!heimdallService) {\n        throw new Error('HeimdallService is not available.');\n      }\n\n      try {\n        const prompt = composePromptFromState({\n          state,\n          template: heimdallTransferTokensActionTemplate,\n        });\n        const modelResponse = await runtime.useModel(ModelType.TEXT_SMALL, {\n          prompt,\n        });\n        const parsed = parseJSONObjectFromText(modelResponse);\n        if (parsed) {\n          extractedParams = parsed as Partial<HeimdallTransferTokensParams>;\n        }\n        logger.debug('HEIMDALL_TRANSFER_TOKENS: Extracted params via TEXT_SMALL:', extractedParams);\n        if (extractedParams?.error) {\n          throw new Error(extractedParams.error);\n        }\n      } catch (e: unknown) {\n        const errorMsg = e instanceof Error ? e.message : String(e);\n        logger.warn(\n          `HEIMDALL_TRANSFER_TOKENS: Failed to parse JSON from model (Proceeding to manual): ${errorMsg}`\n        );\n      }\n\n      if (\n        !extractedParams ||\n        extractedParams.error ||\n        !extractedParams.recipientAddress ||\n        !extractedParams.amount\n      ) {\n        logger.info(\n          'HEIMDALL_TRANSFER_TOKENS: Model extraction insufficient, attempting manual extraction.'\n        );\n        const manualParams = extractHeimdallTransferTokensParamsFromText(rawMessageText);\n        if (extractedParams && !extractedParams.error) {\n          extractedParams = { ...manualParams, ...extractedParams };\n        } else {\n          extractedParams = manualParams;\n        }\n        logger.debug('HEIMDALL_TRANSFER_TOKENS: Params after manual extraction:', extractedParams);\n      }\n\n      const validatedParams = heimdallTransferTokensParamsSchema.safeParse(extractedParams);\n      if (!validatedParams.success) {\n        logger.error(\n          'HEIMDALL_TRANSFER_TOKENS: Invalid parameters.',\n          validatedParams.error.flatten()\n        );\n        throw new Error(\n          `Invalid parameters: ${validatedParams.error.issues.map((i) => `${i.path.join('.')}: ${i.message}`).join(', ')}`\n        );\n      }\n\n      const { recipientAddress, amount, denom } = validatedParams.data;\n\n      const txHash = await heimdallService.transferHeimdallTokens(recipientAddress, amount, denom);\n\n      const successMsg = `Successfully transferred ${amount} ${denom || 'matic'} to ${recipientAddress} on Heimdall. Tx Hash: ${txHash}`;\n      logger.info(successMsg);\n\n      if (callback) {\n        await callback({\n          text: successMsg,\n          content: {\n            success: true,\n            transactionHash: txHash,\n            recipientAddress,\n            amount,\n            denom,\n          },\n          actions: [heimdallTransferTokensAction.name],\n          source: message.content.source,\n        });\n      }\n      return {\n        success: true,\n        transactionHash: txHash,\n        recipientAddress,\n        amount,\n        denom,\n      };\n    } catch (error) {\n      const errMsg = error instanceof Error ? error.message : String(error);\n      logger.error('Error in HEIMDALL_TRANSFER_TOKENS handler:', errMsg, error);\n      if (callback) {\n        await callback({\n          text: `Error transferring Heimdall tokens: ${errMsg}`,\n          actions: [heimdallTransferTokensAction.name],\n          source: message.content.source,\n        });\n      }\n      return { success: false, error: errMsg };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: 'User transfers Heimdall MATIC',\n        id: 'htt-ex1-user',\n        role: 'user',\n        entityId: 'u1',\n        roomId: 'r1',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_TRANSFER_TOKENS'],\n        content: {\n          text: 'Send 0.5 MATIC on Heimdall to heimdall1recipientaddress. The amount is 500000000000000000 in wei.',\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n    [\n      {\n        name: 'User transfers Heimdall tokens with different denom',\n        id: 'htt-ex2-user',\n        role: 'user',\n        entityId: 'u1',\n        roomId: 'r1',\n        timestamp: new Date().toISOString(),\n        actions: ['HEIMDALL_TRANSFER_TOKENS'],\n        content: {\n          text: 'Transfer 100000 uatom on Heimdall to heimdallvaloper1validatoraddress.',\n          source: 'user-input',\n        },\n      } as ActionExample,\n    ],\n  ],\n};\n","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type Content,\n  logger,\n} from '@elizaos/core';\nimport { ethers } from 'ethers';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\nimport { initWalletProvider } from '../providers/PolygonWalletProvider.js';\n\n// Common token addresses on Polygon\nconst USDC_ADDRESS = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174'; // USDC on Polygon\nconst WETH_ADDRESS = '0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619'; // WETH on Polygon\n\nexport const getUSDCBalanceAction: Action = {\n  name: 'GET_USDC_BALANCE',\n  similes: ['CHECK_USDC_BALANCE', 'SHOW_USDC_BALANCE', 'GET_USDC_AMOUNT'],\n  description: 'Gets the USDC balance for the agent wallet on Polygon.',\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    logger.info(`[getUSDCBalanceAction] VALIDATION CALLED - message: \"${content}\"`);\n\n    try {\n      // Check for USDC balance related keywords\n      const usdcKeywords = [\n        'usdc balance',\n        'usdc amount',\n        'my usdc',\n        'get usdc',\n        'show usdc',\n        'check usdc',\n        'usdc wallet',\n        'balance usdc',\n        'how much usdc',\n      ];\n\n      const matches = usdcKeywords.some((keyword) => content.includes(keyword));\n      logger.info(`[getUSDCBalanceAction] Validation result: ${matches}`);\n\n      // Also check if we have required services\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        logger.warn(`[getUSDCBalanceAction] PolygonRpcService not available - validation false`);\n        return false;\n      }\n\n      return matches;\n    } catch (error) {\n      logger.error(`[getUSDCBalanceAction] Validation error:`, error);\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getUSDCBalanceAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) {\n      throw new Error('PolygonRpcService not available');\n    }\n\n    try {\n      // Get agent wallet address using the wallet provider\n      const polygonWalletProvider = await initWalletProvider(runtime);\n      if (!polygonWalletProvider) {\n        throw new Error(\n          'Failed to initialize PolygonWalletProvider - check that PRIVATE_KEY is configured correctly'\n        );\n      }\n      const agentAddress = polygonWalletProvider.getAddress();\n      if (!agentAddress) {\n        throw new Error('Could not determine agent address from provider');\n      }\n\n      logger.info(`Getting USDC balance for address: ${agentAddress}`);\n\n      // Get USDC balance\n      const balance = await rpcService.getErc20Balance(USDC_ADDRESS, agentAddress);\n\n      // USDC has 6 decimals on Polygon\n      const formattedBalance = ethers.formatUnits(balance, 6);\n\n      const responseContent: Content = {\n        text: `Your USDC balance (${agentAddress}): ${formattedBalance} USDC`,\n        actions: ['GET_USDC_BALANCE'],\n        data: {\n          address: agentAddress,\n          tokenAddress: USDC_ADDRESS,\n          balance: balance.toString(),\n          formattedBalance,\n          symbol: 'USDC',\n          decimals: 6,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting USDC balance:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const errorContent: Content = {\n        text: `Error retrieving USDC balance: ${errorMessage}`,\n        actions: ['GET_USDC_BALANCE'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get my usdc balance',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your USDC balance (0x1234...): 1,250.50 USDC',\n          actions: ['GET_USDC_BALANCE'],\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'how much usdc do i have',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your USDC balance (0x1234...): 1,250.50 USDC',\n          actions: ['GET_USDC_BALANCE'],\n        },\n      },\n    ],\n  ],\n};\n\nexport const getWETHBalanceAction: Action = {\n  name: 'GET_WETH_BALANCE',\n  similes: ['CHECK_WETH_BALANCE', 'SHOW_WETH_BALANCE', 'GET_WETH_AMOUNT'],\n  description: 'Gets the WETH balance for the agent wallet on Polygon.',\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    logger.info(`[getWETHBalanceAction] VALIDATION CALLED - message: \"${content}\"`);\n\n    try {\n      // Check for WETH balance related keywords\n      const wethKeywords = [\n        'weth balance',\n        'weth amount',\n        'my weth',\n        'get weth',\n        'show weth',\n        'check weth',\n        'weth wallet',\n        'balance weth',\n        'how much weth',\n        'wrapped eth',\n        'wrapped ethereum',\n      ];\n\n      const matches = wethKeywords.some((keyword) => content.includes(keyword));\n      logger.info(`[getWETHBalanceAction] Validation result: ${matches}`);\n\n      // Also check if we have required services\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        logger.warn(`[getWETHBalanceAction] PolygonRpcService not available - validation false`);\n        return false;\n      }\n\n      return matches;\n    } catch (error) {\n      logger.error(`[getWETHBalanceAction] Validation error:`, error);\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getWETHBalanceAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) {\n      throw new Error('PolygonRpcService not available');\n    }\n\n    try {\n      // Get agent wallet address using the wallet provider\n      const polygonWalletProvider = await initWalletProvider(runtime);\n      if (!polygonWalletProvider) {\n        throw new Error(\n          'Failed to initialize PolygonWalletProvider - check that PRIVATE_KEY is configured correctly'\n        );\n      }\n      const agentAddress = polygonWalletProvider.getAddress();\n      if (!agentAddress) {\n        throw new Error('Could not determine agent address from provider');\n      }\n\n      logger.info(`Getting WETH balance for address: ${agentAddress}`);\n\n      // Get WETH balance\n      const balance = await rpcService.getErc20Balance(WETH_ADDRESS, agentAddress);\n\n      // WETH has 18 decimals like regular ETH\n      const formattedBalance = ethers.formatEther(balance);\n\n      const responseContent: Content = {\n        text: `Your WETH balance (${agentAddress}): ${formattedBalance} WETH`,\n        actions: ['GET_WETH_BALANCE'],\n        data: {\n          address: agentAddress,\n          tokenAddress: WETH_ADDRESS,\n          balance: balance.toString(),\n          formattedBalance,\n          symbol: 'WETH',\n          decimals: 18,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting WETH balance:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const errorContent: Content = {\n        text: `Error retrieving WETH balance: ${errorMessage}`,\n        actions: ['GET_WETH_BALANCE'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get my weth balance',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your WETH balance (0x1234...): 0.5 WETH',\n          actions: ['GET_WETH_BALANCE'],\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'check me weth balance',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your WETH balance (0x1234...): 0.5 WETH',\n          actions: ['GET_WETH_BALANCE'],\n        },\n      },\n    ],\n  ],\n};\n\nexport const getERC20BalanceAction: Action = {\n  name: 'GET_ERC20_BALANCE',\n  similes: ['CHECK_TOKEN_BALANCE', 'SHOW_TOKEN_BALANCE', 'GET_TOKEN_AMOUNT'],\n  description: 'Gets the ERC-20 token balance for a specific token contract address.',\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    logger.info(`[getERC20BalanceAction] VALIDATION CALLED - message: \"${content}\"`);\n\n    try {\n      // Check for ERC-20 token balance related keywords\n      const tokenKeywords = [\n        'token balance',\n        'erc20 balance',\n        'token amount',\n        'balance of token',\n        'get token balance',\n        'show token balance',\n        'check token balance',\n      ];\n\n      const matches = tokenKeywords.some((keyword) => content.includes(keyword));\n      logger.info(`[getERC20BalanceAction] Validation result: ${matches}`);\n\n      // Also check if we have required services\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        logger.warn(`[getERC20BalanceAction] PolygonRpcService not available - validation false`);\n        return false;\n      }\n\n      return matches;\n    } catch (error) {\n      logger.error(`[getERC20BalanceAction] Validation error:`, error);\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getERC20BalanceAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) {\n      throw new Error('PolygonRpcService not available');\n    }\n\n    try {\n      // Get agent wallet address using the wallet provider\n      const polygonWalletProvider = await initWalletProvider(runtime);\n      if (!polygonWalletProvider) {\n        throw new Error(\n          'Failed to initialize PolygonWalletProvider - check that PRIVATE_KEY is configured correctly'\n        );\n      }\n      const agentAddress = polygonWalletProvider.getAddress();\n      if (!agentAddress) {\n        throw new Error('Could not determine agent address from provider');\n      }\n\n      // Get token address from options (this would need to be provided)\n      const tokenAddress = options?.tokenAddress as string;\n      if (!tokenAddress) {\n        throw new Error('Token address is required for ERC-20 balance check');\n      }\n\n      logger.info(`Getting ERC-20 balance for token: ${tokenAddress}, address: ${agentAddress}`);\n\n      // Get token balance\n      const balance = await rpcService.getErc20Balance(tokenAddress, agentAddress);\n\n      // Format with 18 decimals as default (could be refined later)\n      const formattedBalance = ethers.formatUnits(balance, 18);\n\n      const responseContent: Content = {\n        text: `Your token balance (${agentAddress}): ${formattedBalance} tokens`,\n        actions: ['GET_ERC20_BALANCE'],\n        data: {\n          address: agentAddress,\n          tokenAddress,\n          balance: balance.toString(),\n          formattedBalance,\n          symbol: 'TOKEN',\n          decimals: 18,\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting ERC-20 balance:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const errorContent: Content = {\n        text: `Error retrieving token balance: ${errorMessage}`,\n        actions: ['GET_ERC20_BALANCE'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get token balance',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Your TOKEN balance (0x1234...): 1,250.50 TOKEN',\n          actions: ['GET_ERC20_BALANCE'],\n        },\n      },\n    ],\n  ],\n};\n\n// Legacy actions - keeping for backward compatibility but not exported\nconst getNativeBalanceAction: Action = {\n  name: 'GET_NATIVE_BALANCE_LEGACY',\n  description: 'Legacy action - use getMaticBalanceAction instead',\n  validate: async () => false, // Disabled\n  handler: async () => ({ text: 'This action is deprecated', actions: [] }),\n  examples: [],\n};\n","import { type Action, logger, type IAgentRuntime, type Memory, type State } from '@elizaos/core';\nimport { z } from 'zod';\nimport { formatUnits } from '../utils/formatters.js';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\nimport { BlockInfo } from '../types.js';\n\n// Action to get current block number from Polygon L2\nexport const getBlockNumberAction: Action = {\n  name: 'GET_L2_BLOCK_NUMBER',\n  description: 'Gets the current block number on Polygon (L2).',\n\n  // Define examples for how to use this action\n  examples: [\n    [\n      {\n        name: 'User',\n        content: { text: 'What is the current block number on Polygon?' },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'Get latest Polygon block height' },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'Fetch current block number for L2' },\n      },\n    ],\n  ],\n\n  // Validation function\n  validate: async (runtime: IAgentRuntime, message: Memory) => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    // Check for block number related keywords\n    const blockNumberKeywords = [\n      'block number',\n      'current block',\n      'latest block',\n      'polygon block number',\n      'get polygon block',\n      'block height',\n      'current polygon block',\n      'latest polygon block',\n    ];\n\n    return blockNumberKeywords.some((keyword) => content.includes(keyword));\n  },\n\n  // Actual handler function that performs the operation\n  handler: async (runtime: IAgentRuntime, message: Memory, state?: State) => {\n    logger.info('Getting current Polygon block number');\n\n    // Get RPC service\n    const rpcService = runtime.getService(PolygonRpcService.serviceType) as PolygonRpcService;\n    if (!rpcService) {\n      logger.error('PolygonRpcService not available');\n      throw new Error('PolygonRpcService not available');\n    }\n\n    logger.info('Fetching the current block number from Polygon network...');\n\n    // Fetch the current block number\n    const blockNumber = await rpcService.getCurrentBlockNumber();\n\n    logger.info(`Successfully retrieved current block number: ${blockNumber}`);\n\n    return {\n      text: `Current Polygon block number: ${blockNumber}`,\n      actions: ['GET_L2_BLOCK_NUMBER'],\n      data: { blockNumber },\n    };\n  },\n};\n\n// Block identifier schema using Zod\nconst blockIdentifierSchema = z.union([\n  z.number().positive('Block number must be positive'),\n  z.string().regex(/^0x[a-fA-F0-9]{64}$/, 'Block hash must be a valid hex string'),\n]);\n\n// Action to get detailed information about a specific block\nexport const getBlockDetailsAction: Action = {\n  name: 'GET_L2_BLOCK_DETAILS',\n  description: 'Gets detailed information about a specific block on Polygon (L2).',\n\n  // Define examples for how to use this action\n  examples: [\n    [\n      {\n        name: 'User',\n        content: { text: 'Show me details for block 12345678 on Polygon' },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: {\n          text: 'Get information about Polygon block 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',\n        },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'What transactions are in Polygon block 12345678?' },\n      },\n    ],\n  ],\n\n  // Validation function\n  validate: async (options: any, runtime: IAgentRuntime) => {\n    try {\n      // Check if POLYGON_RPC_URL is set in environment\n      const polygonRpcUrl = runtime.getSetting('POLYGON_RPC_URL');\n      if (!polygonRpcUrl) {\n        return 'POLYGON_RPC_URL setting is required to get block information';\n      }\n\n      // If blockIdentifier is provided in options, validate it\n      if (options?.blockIdentifier !== undefined) {\n        blockIdentifierSchema.parse(options.blockIdentifier);\n        return true;\n      }\n\n      // If no blockIdentifier in options, check environment settings\n      const envBlockIdentifier = runtime.getSetting('BLOCK_IDENTIFIER');\n\n      if (envBlockIdentifier) {\n        // Try to parse as number first\n        if (!isNaN(Number(envBlockIdentifier))) {\n          const blockNumber = Number(envBlockIdentifier);\n          if (blockNumber <= 0) {\n            return 'Block number from environment must be positive';\n          }\n          return true;\n        }\n\n        // Try as hash\n        if (\n          typeof envBlockIdentifier === 'string' &&\n          envBlockIdentifier.match(/^0x[a-fA-F0-9]{64}$/)\n        ) {\n          return true;\n        }\n\n        return 'BLOCK_IDENTIFIER in environment settings is not a valid block number or hash';\n      }\n\n      return 'Block identifier (number or hash) is required';\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        return error.errors[0].message;\n      }\n      return 'Invalid block identifier format';\n    }\n  },\n\n  // Actual handler function that performs the operation\n  handler: async (runtime: IAgentRuntime, message: any, state: any, options: any) => {\n    // Get RPC service\n    const rpcService = runtime.getService(PolygonRpcService.serviceType) as PolygonRpcService;\n    if (!rpcService) {\n      logger.error('PolygonRpcService not available');\n      throw new Error('PolygonRpcService not available');\n    }\n\n    // Get block identifier from options or environment\n    let blockIdentifier = options?.blockIdentifier;\n\n    // If not in options, try to get from environment\n    if (blockIdentifier === undefined) {\n      logger.debug('Block identifier not found in options, checking environment settings');\n      const envBlockIdentifier = runtime.getSetting('BLOCK_IDENTIFIER');\n\n      if (!envBlockIdentifier) {\n        logger.error('Block identifier missing from both options and environment settings');\n        throw new Error('Block identifier (number or hash) is required');\n      }\n\n      // Convert to number if it's a numeric string\n      if (!isNaN(Number(envBlockIdentifier))) {\n        blockIdentifier = Number(envBlockIdentifier);\n      } else {\n        blockIdentifier = envBlockIdentifier;\n      }\n\n      logger.info(`Using block identifier from environment settings: ${blockIdentifier}`);\n    } else {\n      logger.info(`Using block identifier from options: ${blockIdentifier}`);\n    }\n\n    logger.info(`Getting details for block ${blockIdentifier} from Polygon network...`);\n\n    // Fetch block details\n    const blockDetails = await rpcService.getBlockDetails(blockIdentifier);\n    if (!blockDetails) {\n      logger.warn(`Block ${blockIdentifier} not found on Polygon network`);\n      return {\n        text: `Block ${blockIdentifier} not found on Polygon.`,\n        actions: ['GET_L2_BLOCK_DETAILS'],\n        data: { blockIdentifier, found: false },\n      };\n    }\n\n    logger.info(\n      `Successfully retrieved details for block ${blockDetails.number} (hash: ${blockDetails.hash})`\n    );\n    logger.debug(\n      `Block timestamp: ${new Date(Number(blockDetails.timestamp) * 1000).toISOString()}`\n    );\n    logger.debug(\n      `Block gas used: ${blockDetails.gasUsed.toString()} / ${blockDetails.gasLimit.toString()}`\n    );\n\n    // Format timestamp for readability\n    const timestamp = new Date(Number(blockDetails.timestamp) * 1000).toISOString();\n\n    // Format the response\n    const formattedGasLimit = formatUnits(blockDetails.gasLimit, 0);\n    const formattedGasUsed = formatUnits(blockDetails.gasUsed, 0);\n    const baseFeePerGas = blockDetails.baseFeePerGas\n      ? formatUnits(blockDetails.baseFeePerGas, 9)\n      : 'N/A';\n\n    // Create human-readable response\n    const text =\n      `Block ${blockDetails.number} (${blockIdentifier}):\\n` +\n      `Hash: ${blockDetails.hash}\\n` +\n      `Parent Hash: ${blockDetails.parentHash}\\n` +\n      `Timestamp: ${timestamp}\\n` +\n      `Miner: ${blockDetails.miner}\\n` +\n      `Gas Limit: ${formattedGasLimit}\\n` +\n      `Gas Used: ${formattedGasUsed} (${((Number(blockDetails.gasUsed) * 100) / Number(blockDetails.gasLimit)).toFixed(2)}%)\\n` +\n      `Base Fee: ${baseFeePerGas} Gwei\\n` +\n      `Transaction Count: ${Array.isArray(blockDetails.transactions) ? blockDetails.transactions.length : 'Unknown'}`;\n\n    logger.info(`Returning formatted block details for block ${blockDetails.number}`);\n\n    return {\n      text,\n      actions: ['GET_L2_BLOCK_DETAILS'],\n      data: { blockIdentifier, blockDetails, found: true },\n    };\n  },\n};\n\nconst blockOptionsSchema = z\n  .object({\n    blockNumber: z.number().int().positive().optional(),\n    blockHash: z\n      .string()\n      .regex(/^0x[a-fA-F0-9]{64}$/)\n      .optional(),\n  })\n  .refine((data) => data.blockNumber !== undefined || data.blockHash !== undefined, {\n    message: 'Either blockNumber or blockHash must be provided',\n  });\n\n/**\n * Action to get block information from Polygon (L2)\n */\nexport const getBlockInfoAction: Action = {\n  name: 'GET_L2_BLOCK_INFO',\n  description: 'Gets detailed information about a specific block on Polygon (L2).',\n\n  // Define examples\n  examples: [\n    [\n      {\n        name: 'User',\n        content: { text: \"What's in block 42000000 on Polygon?\" },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: {\n          text: 'Show me the details of block 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',\n        },\n      },\n    ],\n    [\n      {\n        name: 'User',\n        content: { text: 'Get information about Polygon block 42000000' },\n      },\n    ],\n  ],\n\n  validate: async (options: any, runtime: IAgentRuntime) => {\n    try {\n      // Check if POLYGON_RPC_URL is set in environment\n      const polygonRpcUrl = runtime.getSetting('POLYGON_RPC_URL');\n      if (!polygonRpcUrl) {\n        return 'POLYGON_RPC_URL setting is required to get block information';\n      }\n\n      // If no options provided, check if we have a default block number\n      if (!options || (options && !options.blockNumber && !options.blockHash)) {\n        return 'Either blockNumber or blockHash must be provided';\n      }\n\n      // Validate options format\n      blockOptionsSchema.parse(options);\n      return true;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        logger.error('Validation error:', error.errors);\n        return error.errors[0].message;\n      }\n      logger.error('Unexpected validation error:', error);\n      return 'Invalid block options';\n    }\n  },\n\n  execute: async (options: any, runtime: IAgentRuntime) => {\n    try {\n      // Get block identifier from options\n      const blockIdentifier = options.blockNumber || options.blockHash;\n\n      logger.info(`Getting details for block ${blockIdentifier}`);\n\n      // Get the RPC service\n      const rpcService = runtime.getService(PolygonRpcService.serviceType) as PolygonRpcService;\n      if (!rpcService) {\n        throw new Error('PolygonRpcService not available');\n      }\n\n      // Get block details\n      logger.info(`Fetching block details from Polygon network...`);\n      const blockInfo = await rpcService.getBlockDetails(blockIdentifier);\n\n      if (!blockInfo) {\n        logger.warn(`Block ${blockIdentifier} not found`);\n        return {\n          actions: ['GET_L2_BLOCK_INFO'],\n          data: { error: `Block ${blockIdentifier} not found` },\n        };\n      }\n\n      logger.info(`Successfully retrieved details for block ${blockInfo.number}`);\n\n      // Format values for readability\n      const timestamp = new Date(Number(blockInfo.timestamp) * 1000).toISOString();\n      const gasLimit = formatUnits(blockInfo.gasLimit, 0);\n      const gasUsed = formatUnits(blockInfo.gasUsed, 0);\n      const baseFeePerGas = blockInfo.baseFeePerGas\n        ? formatUnits(blockInfo.baseFeePerGas, 9)\n        : 'N/A';\n\n      logger.info(`Block number: ${blockInfo.number}`);\n      logger.info(`Block timestamp: ${timestamp}`);\n      logger.info(\n        `Gas used: ${gasUsed} / ${gasLimit} (${((Number(blockInfo.gasUsed) * 100) / Number(blockInfo.gasLimit)).toFixed(2)}%)`\n      );\n      logger.info(`Transactions: ${blockInfo.transactions.length}`);\n\n      return {\n        actions: ['GET_L2_BLOCK_INFO'],\n        data: {\n          number: blockInfo.number,\n          hash: blockInfo.hash,\n          parentHash: blockInfo.parentHash,\n          timestamp,\n          gasLimit,\n          gasUsed,\n          baseFeePerGas,\n          miner: blockInfo.miner,\n          transactionCount: blockInfo.transactions.length,\n        },\n      };\n    } catch (error) {\n      logger.error(`Error getting block details:`, error);\n      return {\n        actions: ['GET_L2_BLOCK_INFO'],\n        data: { error: error instanceof Error ? error.message : String(error) },\n      };\n    }\n  },\n};\n","/**\n * Utility functions for formatting values in the Polygon plugin\n */\n\nimport { formatUnits as viemFormatUnits, parseUnits as viemParseUnits } from 'viem';\n\n/**\n * Formats a wei amount to a human-readable string with the specified number of decimals\n * \n * @param amount Amount in wei (as bigint or string)\n * @param decimals Number of decimals to format with (default: 18 for ETH/MATIC)\n * @param displayDecimals Number of decimal places to display (default: 4)\n * @returns Formatted string with the specified number of decimals\n */\nexport function formatUnits(amount: bigint | string, decimals: number = 18, displayDecimals: number = 4): string {\n  const amountBigInt = typeof amount === 'string' ? BigInt(amount) : amount;\n  const formatted = viemFormatUnits(amountBigInt, decimals);\n  \n  // If display decimals is specified, format to that precision\n  if (displayDecimals >= 0) {\n    const parts = formatted.split('.');\n    if (parts.length === 1) return parts[0];\n    return `${parts[0]}.${parts[1].substring(0, displayDecimals)}`;\n  }\n  \n  return formatted;\n}\n\n/**\n * Parses a human-readable amount string to wei\n * \n * @param amount Amount as a string (e.g., \"1.5\")\n * @param decimals Number of decimals to parse with (default: 18 for ETH/MATIC)\n * @returns Amount in wei as a bigint\n */\nexport function parseUnits(amount: string, decimals: number = 18): bigint {\n  return viemParseUnits(amount, decimals);\n}\n\n/**\n * Formats a wei amount to a human-readable string with appropriate units\n * \n * @param weiAmount Amount in wei as bigint\n * @param decimals Number of decimals (default: 18 for ETH/MATIC)\n * @param symbol Token symbol to append (optional)\n * @returns Formatted string with appropriate units\n */\nexport function formatWei(weiAmount: bigint, decimals: number = 18, symbol?: string): string {\n  const formatted = formatUnits(weiAmount, decimals);\n  return symbol ? `${formatted} ${symbol}` : formatted;\n}\n\n/**\n * Formats a gas price from wei to gwei\n * \n * @param weiAmount Gas price in wei\n * @returns Formatted gas price in gwei\n */\nexport function formatGasPrice(weiAmount: bigint): string {\n  return formatUnits(weiAmount, 9, 2) + ' gwei';\n}\n\n/**\n * Formats a timestamp to a human-readable date string\n * \n * @param timestamp Unix timestamp in seconds\n * @returns Formatted date string\n */\nexport function formatTimestamp(timestamp: number): string {\n  return new Date(timestamp * 1000).toLocaleString();\n}\n\n/**\n * Truncates an address for display purposes\n * \n * @param address Full Ethereum/Polygon address\n * @param startChars Number of characters to show at the start\n * @param endChars Number of characters to show at the end\n * @returns Truncated address\n */\nexport function truncateAddress(address: string, startChars: number = 6, endChars: number = 4): string {\n  if (!address) return '';\n  if (address.length <= startChars + endChars) return address;\n  \n  return `${address.substring(0, startChars)}...${address.substring(address.length - endChars)}`;\n}\n\n/**\n * Formats a number with thousands separators\n * \n * @param num Number to format\n * @returns Formatted number with thousands separators\n */\nexport function formatNumber(num: number): string {\n  return new Intl.NumberFormat().format(num);\n}\n\n/**\n * Formats a token balance with symbol and proper units\n * \n * @param balance - The BigInt token balance\n * @param decimals - Number of decimal places\n * @param symbol - Token symbol to append (e.g., \"MATIC\")\n * @returns Formatted balance string with symbol\n */\nexport function formatTokenBalance(balance: bigint, decimals: number, symbol: string): string {\n  const formatted = formatUnits(balance, decimals);\n  return `${formatted} ${symbol}`;\n}\n\n/**\n * Parse address string to normalized format with 0x prefix\n * \n * @param address - Address string, with or without 0x prefix\n * @returns Normalized address with 0x prefix\n */\nexport function normalizeAddress(address: string): `0x${string}` {\n  if (!address) throw new Error('Address cannot be empty');\n  \n  // Add 0x prefix if missing\n  if (!address.startsWith('0x')) {\n    return `0x${address}` as `0x${string}`;\n  }\n  \n  return address as `0x${string}`;\n} ","import {\n  type Action,\n  type IAgentRuntime,\n  type Memory,\n  type State,\n  type HandlerCallback,\n  type Content,\n  logger,\n} from '@elizaos/core';\nimport { PolygonRpcService } from '../services/PolygonRpcService.js';\n\nexport const getPolygonBlockDetailsAction: Action = {\n  name: 'GET_POLYGON_BLOCK_DETAILS',\n  similes: ['SHOW_BLOCK_INFO', 'GET_BLOCK_DATA', 'CHECK_BLOCK_DETAILS', 'GET_POLYGON_BLOCK_INFO'],\n  description: 'Gets details for a specific Polygon block when a block number is mentioned.',\n  validate: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<boolean> => {\n    const content = message.content?.text?.toLowerCase() || '';\n\n    // Add debug logging to see if this is being called\n    logger.info(`[getPolygonBlockDetailsAction] VALIDATION CALLED - message: \"${content}\"`);\n\n    try {\n      // Check for block details related keywords\n      const blockDetailsKeywords = [\n        'block details',\n        'details of block',\n        'details of the block',\n        'get the details of block',\n        'get the details of the block',\n        'get details of block',\n        'get details of the block',\n        'polygon block details',\n        'polygon block information',\n        'block information',\n        'get details',\n        'show me block',\n        'details for block',\n        'get me the polygon block',\n        'show polygon block',\n        'polygon block info',\n        'block info',\n        'show block details',\n        'get block details',\n        'block data',\n        'get block data',\n      ];\n\n      const matches = blockDetailsKeywords.some((keyword) => content.includes(keyword));\n\n      // Also check if there's a block number mentioned\n      const hasBlockNumber = /block\\s+\\d+|details.*\\d+/.test(content);\n\n      const result = matches || hasBlockNumber;\n      logger.info(\n        `[getPolygonBlockDetailsAction] Validation result: ${result} (keywords: ${matches}, hasBlockNumber: ${hasBlockNumber})`\n      );\n\n      // Also check if we have required services\n      const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n      if (!rpcService) {\n        logger.warn(\n          `[getPolygonBlockDetailsAction] PolygonRpcService not available - validation false`\n        );\n        return false;\n      }\n\n      return result;\n    } catch (error) {\n      logger.error(`[getPolygonBlockDetailsAction] Validation error:`, error);\n      return false;\n    }\n  },\n  handler: async (\n    runtime: IAgentRuntime,\n    message: Memory,\n    state?: State,\n    options?: { [key: string]: unknown },\n    callback?: HandlerCallback\n  ): Promise<Content> => {\n    logger.info('[getPolygonBlockDetailsAction] Handler called!');\n\n    const rpcService = runtime.getService<PolygonRpcService>(PolygonRpcService.serviceType);\n    if (!rpcService) {\n      throw new Error('PolygonRpcService not available');\n    }\n\n    try {\n      // Extract block number from the message or use current block\n      const content = message.content?.text || '';\n      let blockNumber: number;\n\n      // Try to extract block number from message with improved regex\n      const blockNumberMatches = [\n        /block\\s+(\\d+)/i,\n        /details.*block\\s+(\\d+)/i,\n        /details.*of.*(\\d+)/i,\n        /get.*details.*(\\d+)/i,\n        /(\\d{7,})/, // Match any large number (likely a block number)\n      ];\n\n      let extractedBlockNumber: string | null = null;\n      for (const regex of blockNumberMatches) {\n        const match = content.match(regex);\n        if (match) {\n          extractedBlockNumber = match[1];\n          break;\n        }\n      }\n\n      if (extractedBlockNumber) {\n        blockNumber = parseInt(extractedBlockNumber);\n        logger.info(`Extracted block number ${blockNumber} from message: \"${content}\"`);\n      } else {\n        // If no specific block number, use current block\n        blockNumber = await rpcService.getCurrentBlockNumber();\n        logger.info(`No block number found in message, using current block: ${blockNumber}`);\n      }\n\n      logger.info(`Getting details for Polygon block: ${blockNumber}`);\n      const blockDetails = await rpcService.getBlockDetails(blockNumber);\n\n      if (!blockDetails) {\n        const notFoundContent: Content = {\n          text: `Block ${blockNumber} not found on Polygon.`,\n          actions: ['GET_POLYGON_BLOCK_DETAILS'],\n          data: { blockNumber, found: false },\n        };\n\n        if (callback) {\n          await callback(notFoundContent);\n        }\n\n        return notFoundContent;\n      }\n\n      const responseContent: Content = {\n        text:\n          `Polygon Block ${blockNumber} Details:\\n` +\n          `- Hash: ${blockDetails.hash}\\n` +\n          `- Parent Hash: ${blockDetails.parentHash}\\n` +\n          `- Timestamp: ${new Date(blockDetails.timestamp * 1000).toISOString()}\\n` +\n          `- Gas Used: ${blockDetails.gasUsed.toString()}\\n` +\n          `- Gas Limit: ${blockDetails.gasLimit.toString()}\\n` +\n          `- Transaction Count: ${blockDetails.transactions.length}\\n` +\n          `- Miner: ${blockDetails.miner}`,\n        actions: ['GET_POLYGON_BLOCK_DETAILS'],\n        data: {\n          blockNumber,\n          blockDetails: {\n            hash: blockDetails.hash,\n            parentHash: blockDetails.parentHash,\n            timestamp: blockDetails.timestamp,\n            gasUsed: blockDetails.gasUsed.toString(),\n            gasLimit: blockDetails.gasLimit.toString(),\n            transactionCount: blockDetails.transactions.length,\n            miner: blockDetails.miner,\n          },\n        },\n      };\n\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      return responseContent;\n    } catch (error) {\n      logger.error('Error getting Polygon block details:', error);\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      const errorContent: Content = {\n        text: `Error retrieving Polygon block details: ${errorMessage}`,\n        actions: ['GET_POLYGON_BLOCK_DETAILS'],\n        data: { error: errorMessage },\n      };\n\n      if (callback) {\n        await callback(errorContent);\n      }\n\n      return errorContent;\n    }\n  },\n  examples: [\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'get me the details of polygon block 42000000',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Polygon Block 42000000 Details:\\n- Hash: 0x1234...\\n- Parent Hash: 0x5678...\\n- Timestamp: 2024-01-01T00:00:00.000Z\\n- Gas Used: 15000000\\n- Gas Limit: 30000000\\n- Transaction Count: 150\\n- Miner: 0xabcd...',\n          actions: ['GET_POLYGON_BLOCK_DETAILS'],\n        },\n      },\n    ],\n    [\n      {\n        name: 'user',\n        content: {\n          text: 'show me the polygon block details',\n        },\n      },\n      {\n        name: 'assistant',\n        content: {\n          text: 'Polygon Block 65123456 Details:\\n- Hash: 0x1234...\\n- Parent Hash: 0x5678...\\n- Timestamp: 2024-01-01T00:00:00.000Z\\n- Gas Used: 15000000\\n- Gas Limit: 30000000\\n- Transaction Count: 150\\n- Miner: 0xabcd...',\n          actions: ['GET_POLYGON_BLOCK_DETAILS'],\n        },\n      },\n    ],\n  ],\n};\n"],"mappings":"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","names":["logger","z","ethers","logger","ModelType","composePromptFromState","ethers","parseUnits","logger","elizaLogger","logger","maxPriorityFeePerGas","maxFeePerGas","parseUnits","logger","composePromptFromState","ModelType","ethers","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","parseUnits","logger","parseUnits","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","encodeFunctionData","logger","encodeFunctionData","composePromptFromState","ModelType","parseJSONObjectFromText","composePromptFromState","ModelType","formatUnits","composePromptFromState","ModelType","formatUnits","coreLogger","composePromptFromState","ModelType","formatUnits","Wallet","coreLogger","composePromptFromState","ModelType","extractParamsFromText","Wallet","formatUnits","logger","composePromptFromState","ModelType","parseJSONObjectFromText","extractParamsFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","parseUnits","logger","process","parseUnits","composePromptFromState","ModelType","parseJSONObjectFromText","logger","logger","logger","elizaLogger","ethers","logger","polygonWalletProvider","elizaLogger","ethers","logger","composePromptFromState","ModelType","parseJSONObjectFromText","parseUnits","extractParamsFromText","parseUnits","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","extractParamsFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","responseContent","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","Service","logger","VoteOption","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","z","z","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","composePromptFromState","ModelType","parseJSONObjectFromText","z","z","logger","composePromptFromState","ModelType","parseJSONObjectFromText","logger","ethers","logger","polygonWalletProvider","ethers","logger","z","logger","z","z","logger","logger","logger","z","ethers"]}